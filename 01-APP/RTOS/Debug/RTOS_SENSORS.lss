
RTOS_SENSORS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00004638  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  00004638  000046cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000492  0080007c  0080007c  000046e8  2**0
                  ALLOC
  3 .stab         00005664  00000000  00000000  000046e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00003116  00000000  00000000  00009d4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000ce62  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000cfa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000d112  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000ed5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000fc46  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  000109f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00010b54  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00010de1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000115af  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 e5 16 	jmp	0x2dca	; 0x2dca <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 55 06 	jmp	0xcaa	; 0xcaa <__vector_16>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e3       	ldi	r30, 0x38	; 56
      68:	f6 e4       	ldi	r31, 0x46	; 70
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 37       	cpi	r26, 0x7C	; 124
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	ac e7       	ldi	r26, 0x7C	; 124
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 30       	cpi	r26, 0x0E	; 14
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2e 13 	call	0x265c	; 0x265c <main>
      8a:	0c 94 1a 23 	jmp	0x4634	; 0x4634 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 c4 22 	jmp	0x4588	; 0x4588 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	af e6       	ldi	r26, 0x6F	; 111
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e0 22 	jmp	0x45c0	; 0x45c0 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 c4 22 	jmp	0x4588	; 0x4588 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8f e6       	ldi	r24, 0x6F	; 111
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e0 22 	jmp	0x45c0	; 0x45c0 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 d0 22 	jmp	0x45a0	; 0x45a0 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 ec 22 	jmp	0x45d8	; 0x45d8 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 d4 22 	jmp	0x45a8	; 0x45a8 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 f0 22 	jmp	0x45e0	; 0x45e0 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <ADC_SetCallBack>:
	#include "BIT_MATH.h"
	#include "ADC_interface.h"
	#include "ADC_register.h"

	static void(*Gptr)(u16 ADC_Adress)=NULL;
	void ADC_SetCallBack(void (*LocPtr)(u16 ADC_Adress)){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <ADC_SetCallBack+0x6>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01

		if(LocPtr!=NULL){
     b54:	89 81       	ldd	r24, Y+1	; 0x01
     b56:	9a 81       	ldd	r25, Y+2	; 0x02
     b58:	00 97       	sbiw	r24, 0x00	; 0
     b5a:	31 f0       	breq	.+12     	; 0xb68 <ADC_SetCallBack+0x22>
			Gptr=LocPtr;
     b5c:	89 81       	ldd	r24, Y+1	; 0x01
     b5e:	9a 81       	ldd	r25, Y+2	; 0x02
     b60:	90 93 7d 00 	sts	0x007D, r25
     b64:	80 93 7c 00 	sts	0x007C, r24
			}

	}
     b68:	0f 90       	pop	r0
     b6a:	0f 90       	pop	r0
     b6c:	cf 91       	pop	r28
     b6e:	df 91       	pop	r29
     b70:	08 95       	ret

00000b72 <ADC_VidInit>:
	void ADC_VidInit(void){
     b72:	df 93       	push	r29
     b74:	cf 93       	push	r28
     b76:	cd b7       	in	r28, 0x3d	; 61
     b78:	de b7       	in	r29, 0x3e	; 62
	//CHOOSE THE Vref//
	  SET_BIT(ADMUX,PIN6);
     b7a:	a7 e2       	ldi	r26, 0x27	; 39
     b7c:	b0 e0       	ldi	r27, 0x00	; 0
     b7e:	e7 e2       	ldi	r30, 0x27	; 39
     b80:	f0 e0       	ldi	r31, 0x00	; 0
     b82:	80 81       	ld	r24, Z
     b84:	80 64       	ori	r24, 0x40	; 64
     b86:	8c 93       	st	X, r24
	  CLR_BIT(ADMUX,PIN7);
     b88:	a7 e2       	ldi	r26, 0x27	; 39
     b8a:	b0 e0       	ldi	r27, 0x00	; 0
     b8c:	e7 e2       	ldi	r30, 0x27	; 39
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	80 81       	ld	r24, Z
     b92:	8f 77       	andi	r24, 0x7F	; 127
     b94:	8c 93       	st	X, r24

	#if DATA_READING==RIGHT  
	   CLR_BIT(ADMUX,PIN5);//choose the right adjest//
     b96:	a7 e2       	ldi	r26, 0x27	; 39
     b98:	b0 e0       	ldi	r27, 0x00	; 0
     b9a:	e7 e2       	ldi	r30, 0x27	; 39
     b9c:	f0 e0       	ldi	r31, 0x00	; 0
     b9e:	80 81       	ld	r24, Z
     ba0:	8f 7d       	andi	r24, 0xDF	; 223
     ba2:	8c 93       	st	X, r24
	#elif DATA_READING==LEFT  
	   SET_BIT(ADMUX,PIN5);//choose the LEFT adjest//  
	#endif   

	#if AUTO_TRIG==OFF
	   CLR_BIT(ADCSRA,PIN5);//auto trigger OFF//
     ba4:	a6 e2       	ldi	r26, 0x26	; 38
     ba6:	b0 e0       	ldi	r27, 0x00	; 0
     ba8:	e6 e2       	ldi	r30, 0x26	; 38
     baa:	f0 e0       	ldi	r31, 0x00	; 0
     bac:	80 81       	ld	r24, Z
     bae:	8f 7d       	andi	r24, 0xDF	; 223
     bb0:	8c 93       	st	X, r24

			  #endif

	#endif   
	   
		CLR_BIT(ADCSRA,PIN0);  //pre scaller 64//
     bb2:	a6 e2       	ldi	r26, 0x26	; 38
     bb4:	b0 e0       	ldi	r27, 0x00	; 0
     bb6:	e6 e2       	ldi	r30, 0x26	; 38
     bb8:	f0 e0       	ldi	r31, 0x00	; 0
     bba:	80 81       	ld	r24, Z
     bbc:	8e 7f       	andi	r24, 0xFE	; 254
     bbe:	8c 93       	st	X, r24
		SET_BIT(ADCSRA,PIN1);
     bc0:	a6 e2       	ldi	r26, 0x26	; 38
     bc2:	b0 e0       	ldi	r27, 0x00	; 0
     bc4:	e6 e2       	ldi	r30, 0x26	; 38
     bc6:	f0 e0       	ldi	r31, 0x00	; 0
     bc8:	80 81       	ld	r24, Z
     bca:	82 60       	ori	r24, 0x02	; 2
     bcc:	8c 93       	st	X, r24
		SET_BIT(ADCSRA,PIN2);
     bce:	a6 e2       	ldi	r26, 0x26	; 38
     bd0:	b0 e0       	ldi	r27, 0x00	; 0
     bd2:	e6 e2       	ldi	r30, 0x26	; 38
     bd4:	f0 e0       	ldi	r31, 0x00	; 0
     bd6:	80 81       	ld	r24, Z
     bd8:	84 60       	ori	r24, 0x04	; 4
     bda:	8c 93       	st	X, r24
		
	  
		SET_BIT(ADCSRA ,PIN7);//ADC ENABLBE//
     bdc:	a6 e2       	ldi	r26, 0x26	; 38
     bde:	b0 e0       	ldi	r27, 0x00	; 0
     be0:	e6 e2       	ldi	r30, 0x26	; 38
     be2:	f0 e0       	ldi	r31, 0x00	; 0
     be4:	80 81       	ld	r24, Z
     be6:	80 68       	ori	r24, 0x80	; 128
     be8:	8c 93       	st	X, r24

	}
     bea:	cf 91       	pop	r28
     bec:	df 91       	pop	r29
     bee:	08 95       	ret

00000bf0 <ADC_VidGetReadingPooling>:

	u16 ADC_VidGetReadingPooling(u8 LOC_u8AdcNum){
     bf0:	df 93       	push	r29
     bf2:	cf 93       	push	r28
     bf4:	0f 92       	push	r0
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	89 83       	std	Y+1, r24	; 0x01
		
		ADMUX&=0b11100000;
     bfc:	a7 e2       	ldi	r26, 0x27	; 39
     bfe:	b0 e0       	ldi	r27, 0x00	; 0
     c00:	e7 e2       	ldi	r30, 0x27	; 39
     c02:	f0 e0       	ldi	r31, 0x00	; 0
     c04:	80 81       	ld	r24, Z
     c06:	80 7e       	andi	r24, 0xE0	; 224
     c08:	8c 93       	st	X, r24
		ADMUX|=LOC_u8AdcNum;
     c0a:	a7 e2       	ldi	r26, 0x27	; 39
     c0c:	b0 e0       	ldi	r27, 0x00	; 0
     c0e:	e7 e2       	ldi	r30, 0x27	; 39
     c10:	f0 e0       	ldi	r31, 0x00	; 0
     c12:	90 81       	ld	r25, Z
     c14:	89 81       	ldd	r24, Y+1	; 0x01
     c16:	89 2b       	or	r24, r25
     c18:	8c 93       	st	X, r24
		
		SET_BIT(ADCSRA,PIN6);//start the conversion//
     c1a:	a6 e2       	ldi	r26, 0x26	; 38
     c1c:	b0 e0       	ldi	r27, 0x00	; 0
     c1e:	e6 e2       	ldi	r30, 0x26	; 38
     c20:	f0 e0       	ldi	r31, 0x00	; 0
     c22:	80 81       	ld	r24, Z
     c24:	80 64       	ori	r24, 0x40	; 64
     c26:	8c 93       	st	X, r24
		
		while(0==GET_BIT(ADCSRA,PIN4)){
     c28:	e6 e2       	ldi	r30, 0x26	; 38
     c2a:	f0 e0       	ldi	r31, 0x00	; 0
     c2c:	80 81       	ld	r24, Z
     c2e:	82 95       	swap	r24
     c30:	8f 70       	andi	r24, 0x0F	; 15
     c32:	88 2f       	mov	r24, r24
     c34:	90 e0       	ldi	r25, 0x00	; 0
     c36:	81 70       	andi	r24, 0x01	; 1
     c38:	90 70       	andi	r25, 0x00	; 0
     c3a:	00 97       	sbiw	r24, 0x00	; 0
     c3c:	a9 f3       	breq	.-22     	; 0xc28 <ADC_VidGetReadingPooling+0x38>
			
		}
		SET_BIT(ADCSRA,PIN4);
     c3e:	a6 e2       	ldi	r26, 0x26	; 38
     c40:	b0 e0       	ldi	r27, 0x00	; 0
     c42:	e6 e2       	ldi	r30, 0x26	; 38
     c44:	f0 e0       	ldi	r31, 0x00	; 0
     c46:	80 81       	ld	r24, Z
     c48:	80 61       	ori	r24, 0x10	; 16
     c4a:	8c 93       	st	X, r24
		
		return ADC;
     c4c:	e4 e2       	ldi	r30, 0x24	; 36
     c4e:	f0 e0       	ldi	r31, 0x00	; 0
     c50:	80 81       	ld	r24, Z
     c52:	91 81       	ldd	r25, Z+1	; 0x01
	}
     c54:	0f 90       	pop	r0
     c56:	cf 91       	pop	r28
     c58:	df 91       	pop	r29
     c5a:	08 95       	ret

00000c5c <ADC_VidGetReadingInterrupt>:

	void ADC_VidGetReadingInterrupt(u8 LOC_u8AdcNum){
     c5c:	df 93       	push	r29
     c5e:	cf 93       	push	r28
     c60:	0f 92       	push	r0
     c62:	cd b7       	in	r28, 0x3d	; 61
     c64:	de b7       	in	r29, 0x3e	; 62
     c66:	89 83       	std	Y+1, r24	; 0x01
		ADMUX&=0b11100000;
     c68:	a7 e2       	ldi	r26, 0x27	; 39
     c6a:	b0 e0       	ldi	r27, 0x00	; 0
     c6c:	e7 e2       	ldi	r30, 0x27	; 39
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	80 7e       	andi	r24, 0xE0	; 224
     c74:	8c 93       	st	X, r24
		ADMUX|=LOC_u8AdcNum;
     c76:	a7 e2       	ldi	r26, 0x27	; 39
     c78:	b0 e0       	ldi	r27, 0x00	; 0
     c7a:	e7 e2       	ldi	r30, 0x27	; 39
     c7c:	f0 e0       	ldi	r31, 0x00	; 0
     c7e:	90 81       	ld	r25, Z
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	89 2b       	or	r24, r25
     c84:	8c 93       	st	X, r24

	#if	INTERRUPT_ADC==ON
	 SET_BIT(ADCSRA,PIN3);//enable the ADC interrupt on//
	#elif  INTERRUPT_ADC==OFF
	 CLR_BIT(ADCSRA,PIN3);//Disable the ADC interrupt on//
     c86:	a6 e2       	ldi	r26, 0x26	; 38
     c88:	b0 e0       	ldi	r27, 0x00	; 0
     c8a:	e6 e2       	ldi	r30, 0x26	; 38
     c8c:	f0 e0       	ldi	r31, 0x00	; 0
     c8e:	80 81       	ld	r24, Z
     c90:	87 7f       	andi	r24, 0xF7	; 247
     c92:	8c 93       	st	X, r24
	#endif
	SET_BIT(ADCSRA,PIN6);//start the conversion//
     c94:	a6 e2       	ldi	r26, 0x26	; 38
     c96:	b0 e0       	ldi	r27, 0x00	; 0
     c98:	e6 e2       	ldi	r30, 0x26	; 38
     c9a:	f0 e0       	ldi	r31, 0x00	; 0
     c9c:	80 81       	ld	r24, Z
     c9e:	80 64       	ori	r24, 0x40	; 64
     ca0:	8c 93       	st	X, r24

	}
     ca2:	0f 90       	pop	r0
     ca4:	cf 91       	pop	r28
     ca6:	df 91       	pop	r29
     ca8:	08 95       	ret

00000caa <__vector_16>:

	void __vector_16( void ){
     caa:	1f 92       	push	r1
     cac:	0f 92       	push	r0
     cae:	0f b6       	in	r0, 0x3f	; 63
     cb0:	0f 92       	push	r0
     cb2:	11 24       	eor	r1, r1
     cb4:	2f 93       	push	r18
     cb6:	3f 93       	push	r19
     cb8:	4f 93       	push	r20
     cba:	5f 93       	push	r21
     cbc:	6f 93       	push	r22
     cbe:	7f 93       	push	r23
     cc0:	8f 93       	push	r24
     cc2:	9f 93       	push	r25
     cc4:	af 93       	push	r26
     cc6:	bf 93       	push	r27
     cc8:	ef 93       	push	r30
     cca:	ff 93       	push	r31
     ccc:	df 93       	push	r29
     cce:	cf 93       	push	r28
     cd0:	cd b7       	in	r28, 0x3d	; 61
     cd2:	de b7       	in	r29, 0x3e	; 62

	 if(Gptr!=NULL){
     cd4:	80 91 7c 00 	lds	r24, 0x007C
     cd8:	90 91 7d 00 	lds	r25, 0x007D
     cdc:	00 97       	sbiw	r24, 0x00	; 0
     cde:	49 f0       	breq	.+18     	; 0xcf2 <__vector_16+0x48>
		Gptr(ADC);
     ce0:	e0 91 7c 00 	lds	r30, 0x007C
     ce4:	f0 91 7d 00 	lds	r31, 0x007D
     ce8:	a4 e2       	ldi	r26, 0x24	; 36
     cea:	b0 e0       	ldi	r27, 0x00	; 0
     cec:	8d 91       	ld	r24, X+
     cee:	9c 91       	ld	r25, X
     cf0:	09 95       	icall
		}

	}
     cf2:	cf 91       	pop	r28
     cf4:	df 91       	pop	r29
     cf6:	ff 91       	pop	r31
     cf8:	ef 91       	pop	r30
     cfa:	bf 91       	pop	r27
     cfc:	af 91       	pop	r26
     cfe:	9f 91       	pop	r25
     d00:	8f 91       	pop	r24
     d02:	7f 91       	pop	r23
     d04:	6f 91       	pop	r22
     d06:	5f 91       	pop	r21
     d08:	4f 91       	pop	r20
     d0a:	3f 91       	pop	r19
     d0c:	2f 91       	pop	r18
     d0e:	0f 90       	pop	r0
     d10:	0f be       	out	0x3f, r0	; 63
     d12:	0f 90       	pop	r0
     d14:	1f 90       	pop	r1
     d16:	18 95       	reti

00000d18 <DIO_VidSetPinDirection>:
/*
loc_u8port=port name 
loc_u8pin =pin number
loc_u8state=pin direction
*/
void DIO_VidSetPinDirection(u8 loc_u8port,u8 loc_u8pin, u8 loc_u8state){
     d18:	df 93       	push	r29
     d1a:	cf 93       	push	r28
     d1c:	cd b7       	in	r28, 0x3d	; 61
     d1e:	de b7       	in	r29, 0x3e	; 62
     d20:	27 97       	sbiw	r28, 0x07	; 7
     d22:	0f b6       	in	r0, 0x3f	; 63
     d24:	f8 94       	cli
     d26:	de bf       	out	0x3e, r29	; 62
     d28:	0f be       	out	0x3f, r0	; 63
     d2a:	cd bf       	out	0x3d, r28	; 61
     d2c:	89 83       	std	Y+1, r24	; 0x01
     d2e:	6a 83       	std	Y+2, r22	; 0x02
     d30:	4b 83       	std	Y+3, r20	; 0x03
	
	if(1==loc_u8state){
     d32:	8b 81       	ldd	r24, Y+3	; 0x03
     d34:	81 30       	cpi	r24, 0x01	; 1
     d36:	09 f0       	breq	.+2      	; 0xd3a <DIO_VidSetPinDirection+0x22>
     d38:	6f c0       	rjmp	.+222    	; 0xe18 <DIO_VidSetPinDirection+0x100>
	    switch(loc_u8port){
     d3a:	89 81       	ldd	r24, Y+1	; 0x01
     d3c:	28 2f       	mov	r18, r24
     d3e:	30 e0       	ldi	r19, 0x00	; 0
     d40:	3f 83       	std	Y+7, r19	; 0x07
     d42:	2e 83       	std	Y+6, r18	; 0x06
     d44:	8e 81       	ldd	r24, Y+6	; 0x06
     d46:	9f 81       	ldd	r25, Y+7	; 0x07
     d48:	81 30       	cpi	r24, 0x01	; 1
     d4a:	91 05       	cpc	r25, r1
     d4c:	49 f1       	breq	.+82     	; 0xda0 <DIO_VidSetPinDirection+0x88>
     d4e:	2e 81       	ldd	r18, Y+6	; 0x06
     d50:	3f 81       	ldd	r19, Y+7	; 0x07
     d52:	22 30       	cpi	r18, 0x02	; 2
     d54:	31 05       	cpc	r19, r1
     d56:	2c f4       	brge	.+10     	; 0xd62 <DIO_VidSetPinDirection+0x4a>
     d58:	8e 81       	ldd	r24, Y+6	; 0x06
     d5a:	9f 81       	ldd	r25, Y+7	; 0x07
     d5c:	00 97       	sbiw	r24, 0x00	; 0
     d5e:	61 f0       	breq	.+24     	; 0xd78 <DIO_VidSetPinDirection+0x60>
     d60:	d2 c0       	rjmp	.+420    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
     d62:	2e 81       	ldd	r18, Y+6	; 0x06
     d64:	3f 81       	ldd	r19, Y+7	; 0x07
     d66:	22 30       	cpi	r18, 0x02	; 2
     d68:	31 05       	cpc	r19, r1
     d6a:	71 f1       	breq	.+92     	; 0xdc8 <DIO_VidSetPinDirection+0xb0>
     d6c:	8e 81       	ldd	r24, Y+6	; 0x06
     d6e:	9f 81       	ldd	r25, Y+7	; 0x07
     d70:	83 30       	cpi	r24, 0x03	; 3
     d72:	91 05       	cpc	r25, r1
     d74:	e9 f1       	breq	.+122    	; 0xdf0 <DIO_VidSetPinDirection+0xd8>
     d76:	c7 c0       	rjmp	.+398    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 0:SET_BIT(DDRA,loc_u8pin);break;
     d78:	aa e3       	ldi	r26, 0x3A	; 58
     d7a:	b0 e0       	ldi	r27, 0x00	; 0
     d7c:	ea e3       	ldi	r30, 0x3A	; 58
     d7e:	f0 e0       	ldi	r31, 0x00	; 0
     d80:	80 81       	ld	r24, Z
     d82:	48 2f       	mov	r20, r24
     d84:	8a 81       	ldd	r24, Y+2	; 0x02
     d86:	28 2f       	mov	r18, r24
     d88:	30 e0       	ldi	r19, 0x00	; 0
     d8a:	81 e0       	ldi	r24, 0x01	; 1
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	02 2e       	mov	r0, r18
     d90:	02 c0       	rjmp	.+4      	; 0xd96 <DIO_VidSetPinDirection+0x7e>
     d92:	88 0f       	add	r24, r24
     d94:	99 1f       	adc	r25, r25
     d96:	0a 94       	dec	r0
     d98:	e2 f7       	brpl	.-8      	; 0xd92 <DIO_VidSetPinDirection+0x7a>
     d9a:	84 2b       	or	r24, r20
     d9c:	8c 93       	st	X, r24
     d9e:	b3 c0       	rjmp	.+358    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 1:SET_BIT(DDRB,loc_u8pin);break;
     da0:	a7 e3       	ldi	r26, 0x37	; 55
     da2:	b0 e0       	ldi	r27, 0x00	; 0
     da4:	e7 e3       	ldi	r30, 0x37	; 55
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	80 81       	ld	r24, Z
     daa:	48 2f       	mov	r20, r24
     dac:	8a 81       	ldd	r24, Y+2	; 0x02
     dae:	28 2f       	mov	r18, r24
     db0:	30 e0       	ldi	r19, 0x00	; 0
     db2:	81 e0       	ldi	r24, 0x01	; 1
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	02 2e       	mov	r0, r18
     db8:	02 c0       	rjmp	.+4      	; 0xdbe <DIO_VidSetPinDirection+0xa6>
     dba:	88 0f       	add	r24, r24
     dbc:	99 1f       	adc	r25, r25
     dbe:	0a 94       	dec	r0
     dc0:	e2 f7       	brpl	.-8      	; 0xdba <DIO_VidSetPinDirection+0xa2>
     dc2:	84 2b       	or	r24, r20
     dc4:	8c 93       	st	X, r24
     dc6:	9f c0       	rjmp	.+318    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 2:SET_BIT(DDRC,loc_u8pin);break;
     dc8:	a4 e3       	ldi	r26, 0x34	; 52
     dca:	b0 e0       	ldi	r27, 0x00	; 0
     dcc:	e4 e3       	ldi	r30, 0x34	; 52
     dce:	f0 e0       	ldi	r31, 0x00	; 0
     dd0:	80 81       	ld	r24, Z
     dd2:	48 2f       	mov	r20, r24
     dd4:	8a 81       	ldd	r24, Y+2	; 0x02
     dd6:	28 2f       	mov	r18, r24
     dd8:	30 e0       	ldi	r19, 0x00	; 0
     dda:	81 e0       	ldi	r24, 0x01	; 1
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	02 2e       	mov	r0, r18
     de0:	02 c0       	rjmp	.+4      	; 0xde6 <DIO_VidSetPinDirection+0xce>
     de2:	88 0f       	add	r24, r24
     de4:	99 1f       	adc	r25, r25
     de6:	0a 94       	dec	r0
     de8:	e2 f7       	brpl	.-8      	; 0xde2 <DIO_VidSetPinDirection+0xca>
     dea:	84 2b       	or	r24, r20
     dec:	8c 93       	st	X, r24
     dee:	8b c0       	rjmp	.+278    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 3:SET_BIT(DDRD,loc_u8pin);break;
     df0:	a1 e3       	ldi	r26, 0x31	; 49
     df2:	b0 e0       	ldi	r27, 0x00	; 0
     df4:	e1 e3       	ldi	r30, 0x31	; 49
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	80 81       	ld	r24, Z
     dfa:	48 2f       	mov	r20, r24
     dfc:	8a 81       	ldd	r24, Y+2	; 0x02
     dfe:	28 2f       	mov	r18, r24
     e00:	30 e0       	ldi	r19, 0x00	; 0
     e02:	81 e0       	ldi	r24, 0x01	; 1
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	02 2e       	mov	r0, r18
     e08:	02 c0       	rjmp	.+4      	; 0xe0e <DIO_VidSetPinDirection+0xf6>
     e0a:	88 0f       	add	r24, r24
     e0c:	99 1f       	adc	r25, r25
     e0e:	0a 94       	dec	r0
     e10:	e2 f7       	brpl	.-8      	; 0xe0a <DIO_VidSetPinDirection+0xf2>
     e12:	84 2b       	or	r24, r20
     e14:	8c 93       	st	X, r24
     e16:	77 c0       	rjmp	.+238    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
	 }
	}
	else if(0==loc_u8state){
     e18:	8b 81       	ldd	r24, Y+3	; 0x03
     e1a:	88 23       	and	r24, r24
     e1c:	09 f0       	breq	.+2      	; 0xe20 <DIO_VidSetPinDirection+0x108>
     e1e:	73 c0       	rjmp	.+230    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
	    switch(loc_u8port){
     e20:	89 81       	ldd	r24, Y+1	; 0x01
     e22:	28 2f       	mov	r18, r24
     e24:	30 e0       	ldi	r19, 0x00	; 0
     e26:	3d 83       	std	Y+5, r19	; 0x05
     e28:	2c 83       	std	Y+4, r18	; 0x04
     e2a:	8c 81       	ldd	r24, Y+4	; 0x04
     e2c:	9d 81       	ldd	r25, Y+5	; 0x05
     e2e:	81 30       	cpi	r24, 0x01	; 1
     e30:	91 05       	cpc	r25, r1
     e32:	59 f1       	breq	.+86     	; 0xe8a <DIO_VidSetPinDirection+0x172>
     e34:	2c 81       	ldd	r18, Y+4	; 0x04
     e36:	3d 81       	ldd	r19, Y+5	; 0x05
     e38:	22 30       	cpi	r18, 0x02	; 2
     e3a:	31 05       	cpc	r19, r1
     e3c:	2c f4       	brge	.+10     	; 0xe48 <DIO_VidSetPinDirection+0x130>
     e3e:	8c 81       	ldd	r24, Y+4	; 0x04
     e40:	9d 81       	ldd	r25, Y+5	; 0x05
     e42:	00 97       	sbiw	r24, 0x00	; 0
     e44:	69 f0       	breq	.+26     	; 0xe60 <DIO_VidSetPinDirection+0x148>
     e46:	5f c0       	rjmp	.+190    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
     e48:	2c 81       	ldd	r18, Y+4	; 0x04
     e4a:	3d 81       	ldd	r19, Y+5	; 0x05
     e4c:	22 30       	cpi	r18, 0x02	; 2
     e4e:	31 05       	cpc	r19, r1
     e50:	89 f1       	breq	.+98     	; 0xeb4 <DIO_VidSetPinDirection+0x19c>
     e52:	8c 81       	ldd	r24, Y+4	; 0x04
     e54:	9d 81       	ldd	r25, Y+5	; 0x05
     e56:	83 30       	cpi	r24, 0x03	; 3
     e58:	91 05       	cpc	r25, r1
     e5a:	09 f4       	brne	.+2      	; 0xe5e <DIO_VidSetPinDirection+0x146>
     e5c:	40 c0       	rjmp	.+128    	; 0xede <DIO_VidSetPinDirection+0x1c6>
     e5e:	53 c0       	rjmp	.+166    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 0:CLR_BIT(DDRA,loc_u8pin);break;
     e60:	aa e3       	ldi	r26, 0x3A	; 58
     e62:	b0 e0       	ldi	r27, 0x00	; 0
     e64:	ea e3       	ldi	r30, 0x3A	; 58
     e66:	f0 e0       	ldi	r31, 0x00	; 0
     e68:	80 81       	ld	r24, Z
     e6a:	48 2f       	mov	r20, r24
     e6c:	8a 81       	ldd	r24, Y+2	; 0x02
     e6e:	28 2f       	mov	r18, r24
     e70:	30 e0       	ldi	r19, 0x00	; 0
     e72:	81 e0       	ldi	r24, 0x01	; 1
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	02 2e       	mov	r0, r18
     e78:	02 c0       	rjmp	.+4      	; 0xe7e <DIO_VidSetPinDirection+0x166>
     e7a:	88 0f       	add	r24, r24
     e7c:	99 1f       	adc	r25, r25
     e7e:	0a 94       	dec	r0
     e80:	e2 f7       	brpl	.-8      	; 0xe7a <DIO_VidSetPinDirection+0x162>
     e82:	80 95       	com	r24
     e84:	84 23       	and	r24, r20
     e86:	8c 93       	st	X, r24
     e88:	3e c0       	rjmp	.+124    	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 1:CLR_BIT(DDRB,loc_u8pin);break;
     e8a:	a7 e3       	ldi	r26, 0x37	; 55
     e8c:	b0 e0       	ldi	r27, 0x00	; 0
     e8e:	e7 e3       	ldi	r30, 0x37	; 55
     e90:	f0 e0       	ldi	r31, 0x00	; 0
     e92:	80 81       	ld	r24, Z
     e94:	48 2f       	mov	r20, r24
     e96:	8a 81       	ldd	r24, Y+2	; 0x02
     e98:	28 2f       	mov	r18, r24
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	81 e0       	ldi	r24, 0x01	; 1
     e9e:	90 e0       	ldi	r25, 0x00	; 0
     ea0:	02 2e       	mov	r0, r18
     ea2:	02 c0       	rjmp	.+4      	; 0xea8 <DIO_VidSetPinDirection+0x190>
     ea4:	88 0f       	add	r24, r24
     ea6:	99 1f       	adc	r25, r25
     ea8:	0a 94       	dec	r0
     eaa:	e2 f7       	brpl	.-8      	; 0xea4 <DIO_VidSetPinDirection+0x18c>
     eac:	80 95       	com	r24
     eae:	84 23       	and	r24, r20
     eb0:	8c 93       	st	X, r24
     eb2:	29 c0       	rjmp	.+82     	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 2:CLR_BIT(DDRC,loc_u8pin);break;
     eb4:	a4 e3       	ldi	r26, 0x34	; 52
     eb6:	b0 e0       	ldi	r27, 0x00	; 0
     eb8:	e4 e3       	ldi	r30, 0x34	; 52
     eba:	f0 e0       	ldi	r31, 0x00	; 0
     ebc:	80 81       	ld	r24, Z
     ebe:	48 2f       	mov	r20, r24
     ec0:	8a 81       	ldd	r24, Y+2	; 0x02
     ec2:	28 2f       	mov	r18, r24
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	81 e0       	ldi	r24, 0x01	; 1
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	02 2e       	mov	r0, r18
     ecc:	02 c0       	rjmp	.+4      	; 0xed2 <DIO_VidSetPinDirection+0x1ba>
     ece:	88 0f       	add	r24, r24
     ed0:	99 1f       	adc	r25, r25
     ed2:	0a 94       	dec	r0
     ed4:	e2 f7       	brpl	.-8      	; 0xece <DIO_VidSetPinDirection+0x1b6>
     ed6:	80 95       	com	r24
     ed8:	84 23       	and	r24, r20
     eda:	8c 93       	st	X, r24
     edc:	14 c0       	rjmp	.+40     	; 0xf06 <DIO_VidSetPinDirection+0x1ee>
		case 3:CLR_BIT(DDRD,loc_u8pin);break;
     ede:	a1 e3       	ldi	r26, 0x31	; 49
     ee0:	b0 e0       	ldi	r27, 0x00	; 0
     ee2:	e1 e3       	ldi	r30, 0x31	; 49
     ee4:	f0 e0       	ldi	r31, 0x00	; 0
     ee6:	80 81       	ld	r24, Z
     ee8:	48 2f       	mov	r20, r24
     eea:	8a 81       	ldd	r24, Y+2	; 0x02
     eec:	28 2f       	mov	r18, r24
     eee:	30 e0       	ldi	r19, 0x00	; 0
     ef0:	81 e0       	ldi	r24, 0x01	; 1
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	02 2e       	mov	r0, r18
     ef6:	02 c0       	rjmp	.+4      	; 0xefc <DIO_VidSetPinDirection+0x1e4>
     ef8:	88 0f       	add	r24, r24
     efa:	99 1f       	adc	r25, r25
     efc:	0a 94       	dec	r0
     efe:	e2 f7       	brpl	.-8      	; 0xef8 <DIO_VidSetPinDirection+0x1e0>
     f00:	80 95       	com	r24
     f02:	84 23       	and	r24, r20
     f04:	8c 93       	st	X, r24
	 }
	}
	
	
}
     f06:	27 96       	adiw	r28, 0x07	; 7
     f08:	0f b6       	in	r0, 0x3f	; 63
     f0a:	f8 94       	cli
     f0c:	de bf       	out	0x3e, r29	; 62
     f0e:	0f be       	out	0x3f, r0	; 63
     f10:	cd bf       	out	0x3d, r28	; 61
     f12:	cf 91       	pop	r28
     f14:	df 91       	pop	r29
     f16:	08 95       	ret

00000f18 <DIO_VidSetPinValue>:
void DIO_VidSetPinValue(u8 loc_u8port,u8 loc_u8pin, u8 loc_u8value){
     f18:	df 93       	push	r29
     f1a:	cf 93       	push	r28
     f1c:	cd b7       	in	r28, 0x3d	; 61
     f1e:	de b7       	in	r29, 0x3e	; 62
     f20:	27 97       	sbiw	r28, 0x07	; 7
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	f8 94       	cli
     f26:	de bf       	out	0x3e, r29	; 62
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	cd bf       	out	0x3d, r28	; 61
     f2c:	89 83       	std	Y+1, r24	; 0x01
     f2e:	6a 83       	std	Y+2, r22	; 0x02
     f30:	4b 83       	std	Y+3, r20	; 0x03
	
	if(1==loc_u8value){
     f32:	8b 81       	ldd	r24, Y+3	; 0x03
     f34:	81 30       	cpi	r24, 0x01	; 1
     f36:	09 f0       	breq	.+2      	; 0xf3a <DIO_VidSetPinValue+0x22>
     f38:	6f c0       	rjmp	.+222    	; 0x1018 <DIO_VidSetPinValue+0x100>
	    switch(loc_u8port){
     f3a:	89 81       	ldd	r24, Y+1	; 0x01
     f3c:	28 2f       	mov	r18, r24
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	3f 83       	std	Y+7, r19	; 0x07
     f42:	2e 83       	std	Y+6, r18	; 0x06
     f44:	8e 81       	ldd	r24, Y+6	; 0x06
     f46:	9f 81       	ldd	r25, Y+7	; 0x07
     f48:	81 30       	cpi	r24, 0x01	; 1
     f4a:	91 05       	cpc	r25, r1
     f4c:	49 f1       	breq	.+82     	; 0xfa0 <DIO_VidSetPinValue+0x88>
     f4e:	2e 81       	ldd	r18, Y+6	; 0x06
     f50:	3f 81       	ldd	r19, Y+7	; 0x07
     f52:	22 30       	cpi	r18, 0x02	; 2
     f54:	31 05       	cpc	r19, r1
     f56:	2c f4       	brge	.+10     	; 0xf62 <DIO_VidSetPinValue+0x4a>
     f58:	8e 81       	ldd	r24, Y+6	; 0x06
     f5a:	9f 81       	ldd	r25, Y+7	; 0x07
     f5c:	00 97       	sbiw	r24, 0x00	; 0
     f5e:	61 f0       	breq	.+24     	; 0xf78 <DIO_VidSetPinValue+0x60>
     f60:	d2 c0       	rjmp	.+420    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
     f62:	2e 81       	ldd	r18, Y+6	; 0x06
     f64:	3f 81       	ldd	r19, Y+7	; 0x07
     f66:	22 30       	cpi	r18, 0x02	; 2
     f68:	31 05       	cpc	r19, r1
     f6a:	71 f1       	breq	.+92     	; 0xfc8 <DIO_VidSetPinValue+0xb0>
     f6c:	8e 81       	ldd	r24, Y+6	; 0x06
     f6e:	9f 81       	ldd	r25, Y+7	; 0x07
     f70:	83 30       	cpi	r24, 0x03	; 3
     f72:	91 05       	cpc	r25, r1
     f74:	e9 f1       	breq	.+122    	; 0xff0 <DIO_VidSetPinValue+0xd8>
     f76:	c7 c0       	rjmp	.+398    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 0:SET_BIT(PORTA,loc_u8pin);break;
     f78:	ab e3       	ldi	r26, 0x3B	; 59
     f7a:	b0 e0       	ldi	r27, 0x00	; 0
     f7c:	eb e3       	ldi	r30, 0x3B	; 59
     f7e:	f0 e0       	ldi	r31, 0x00	; 0
     f80:	80 81       	ld	r24, Z
     f82:	48 2f       	mov	r20, r24
     f84:	8a 81       	ldd	r24, Y+2	; 0x02
     f86:	28 2f       	mov	r18, r24
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	02 2e       	mov	r0, r18
     f90:	02 c0       	rjmp	.+4      	; 0xf96 <DIO_VidSetPinValue+0x7e>
     f92:	88 0f       	add	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	0a 94       	dec	r0
     f98:	e2 f7       	brpl	.-8      	; 0xf92 <DIO_VidSetPinValue+0x7a>
     f9a:	84 2b       	or	r24, r20
     f9c:	8c 93       	st	X, r24
     f9e:	b3 c0       	rjmp	.+358    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 1:SET_BIT(PORTB,loc_u8pin);break;
     fa0:	a8 e3       	ldi	r26, 0x38	; 56
     fa2:	b0 e0       	ldi	r27, 0x00	; 0
     fa4:	e8 e3       	ldi	r30, 0x38	; 56
     fa6:	f0 e0       	ldi	r31, 0x00	; 0
     fa8:	80 81       	ld	r24, Z
     faa:	48 2f       	mov	r20, r24
     fac:	8a 81       	ldd	r24, Y+2	; 0x02
     fae:	28 2f       	mov	r18, r24
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	02 2e       	mov	r0, r18
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <DIO_VidSetPinValue+0xa6>
     fba:	88 0f       	add	r24, r24
     fbc:	99 1f       	adc	r25, r25
     fbe:	0a 94       	dec	r0
     fc0:	e2 f7       	brpl	.-8      	; 0xfba <DIO_VidSetPinValue+0xa2>
     fc2:	84 2b       	or	r24, r20
     fc4:	8c 93       	st	X, r24
     fc6:	9f c0       	rjmp	.+318    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 2:SET_BIT(PORTC,loc_u8pin);break;
     fc8:	a5 e3       	ldi	r26, 0x35	; 53
     fca:	b0 e0       	ldi	r27, 0x00	; 0
     fcc:	e5 e3       	ldi	r30, 0x35	; 53
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	80 81       	ld	r24, Z
     fd2:	48 2f       	mov	r20, r24
     fd4:	8a 81       	ldd	r24, Y+2	; 0x02
     fd6:	28 2f       	mov	r18, r24
     fd8:	30 e0       	ldi	r19, 0x00	; 0
     fda:	81 e0       	ldi	r24, 0x01	; 1
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	02 2e       	mov	r0, r18
     fe0:	02 c0       	rjmp	.+4      	; 0xfe6 <DIO_VidSetPinValue+0xce>
     fe2:	88 0f       	add	r24, r24
     fe4:	99 1f       	adc	r25, r25
     fe6:	0a 94       	dec	r0
     fe8:	e2 f7       	brpl	.-8      	; 0xfe2 <DIO_VidSetPinValue+0xca>
     fea:	84 2b       	or	r24, r20
     fec:	8c 93       	st	X, r24
     fee:	8b c0       	rjmp	.+278    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 3:SET_BIT(PORTD,loc_u8pin);break;
     ff0:	a2 e3       	ldi	r26, 0x32	; 50
     ff2:	b0 e0       	ldi	r27, 0x00	; 0
     ff4:	e2 e3       	ldi	r30, 0x32	; 50
     ff6:	f0 e0       	ldi	r31, 0x00	; 0
     ff8:	80 81       	ld	r24, Z
     ffa:	48 2f       	mov	r20, r24
     ffc:	8a 81       	ldd	r24, Y+2	; 0x02
     ffe:	28 2f       	mov	r18, r24
    1000:	30 e0       	ldi	r19, 0x00	; 0
    1002:	81 e0       	ldi	r24, 0x01	; 1
    1004:	90 e0       	ldi	r25, 0x00	; 0
    1006:	02 2e       	mov	r0, r18
    1008:	02 c0       	rjmp	.+4      	; 0x100e <DIO_VidSetPinValue+0xf6>
    100a:	88 0f       	add	r24, r24
    100c:	99 1f       	adc	r25, r25
    100e:	0a 94       	dec	r0
    1010:	e2 f7       	brpl	.-8      	; 0x100a <DIO_VidSetPinValue+0xf2>
    1012:	84 2b       	or	r24, r20
    1014:	8c 93       	st	X, r24
    1016:	77 c0       	rjmp	.+238    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
	 }
	}
	else if(0==loc_u8value){
    1018:	8b 81       	ldd	r24, Y+3	; 0x03
    101a:	88 23       	and	r24, r24
    101c:	09 f0       	breq	.+2      	; 0x1020 <DIO_VidSetPinValue+0x108>
    101e:	73 c0       	rjmp	.+230    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
	    switch(loc_u8port){
    1020:	89 81       	ldd	r24, Y+1	; 0x01
    1022:	28 2f       	mov	r18, r24
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	3d 83       	std	Y+5, r19	; 0x05
    1028:	2c 83       	std	Y+4, r18	; 0x04
    102a:	8c 81       	ldd	r24, Y+4	; 0x04
    102c:	9d 81       	ldd	r25, Y+5	; 0x05
    102e:	81 30       	cpi	r24, 0x01	; 1
    1030:	91 05       	cpc	r25, r1
    1032:	59 f1       	breq	.+86     	; 0x108a <DIO_VidSetPinValue+0x172>
    1034:	2c 81       	ldd	r18, Y+4	; 0x04
    1036:	3d 81       	ldd	r19, Y+5	; 0x05
    1038:	22 30       	cpi	r18, 0x02	; 2
    103a:	31 05       	cpc	r19, r1
    103c:	2c f4       	brge	.+10     	; 0x1048 <DIO_VidSetPinValue+0x130>
    103e:	8c 81       	ldd	r24, Y+4	; 0x04
    1040:	9d 81       	ldd	r25, Y+5	; 0x05
    1042:	00 97       	sbiw	r24, 0x00	; 0
    1044:	69 f0       	breq	.+26     	; 0x1060 <DIO_VidSetPinValue+0x148>
    1046:	5f c0       	rjmp	.+190    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
    1048:	2c 81       	ldd	r18, Y+4	; 0x04
    104a:	3d 81       	ldd	r19, Y+5	; 0x05
    104c:	22 30       	cpi	r18, 0x02	; 2
    104e:	31 05       	cpc	r19, r1
    1050:	89 f1       	breq	.+98     	; 0x10b4 <DIO_VidSetPinValue+0x19c>
    1052:	8c 81       	ldd	r24, Y+4	; 0x04
    1054:	9d 81       	ldd	r25, Y+5	; 0x05
    1056:	83 30       	cpi	r24, 0x03	; 3
    1058:	91 05       	cpc	r25, r1
    105a:	09 f4       	brne	.+2      	; 0x105e <DIO_VidSetPinValue+0x146>
    105c:	40 c0       	rjmp	.+128    	; 0x10de <DIO_VidSetPinValue+0x1c6>
    105e:	53 c0       	rjmp	.+166    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 0:CLR_BIT(PORTA,loc_u8pin);break;
    1060:	ab e3       	ldi	r26, 0x3B	; 59
    1062:	b0 e0       	ldi	r27, 0x00	; 0
    1064:	eb e3       	ldi	r30, 0x3B	; 59
    1066:	f0 e0       	ldi	r31, 0x00	; 0
    1068:	80 81       	ld	r24, Z
    106a:	48 2f       	mov	r20, r24
    106c:	8a 81       	ldd	r24, Y+2	; 0x02
    106e:	28 2f       	mov	r18, r24
    1070:	30 e0       	ldi	r19, 0x00	; 0
    1072:	81 e0       	ldi	r24, 0x01	; 1
    1074:	90 e0       	ldi	r25, 0x00	; 0
    1076:	02 2e       	mov	r0, r18
    1078:	02 c0       	rjmp	.+4      	; 0x107e <DIO_VidSetPinValue+0x166>
    107a:	88 0f       	add	r24, r24
    107c:	99 1f       	adc	r25, r25
    107e:	0a 94       	dec	r0
    1080:	e2 f7       	brpl	.-8      	; 0x107a <DIO_VidSetPinValue+0x162>
    1082:	80 95       	com	r24
    1084:	84 23       	and	r24, r20
    1086:	8c 93       	st	X, r24
    1088:	3e c0       	rjmp	.+124    	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 1:CLR_BIT(PORTB,loc_u8pin);break;
    108a:	a8 e3       	ldi	r26, 0x38	; 56
    108c:	b0 e0       	ldi	r27, 0x00	; 0
    108e:	e8 e3       	ldi	r30, 0x38	; 56
    1090:	f0 e0       	ldi	r31, 0x00	; 0
    1092:	80 81       	ld	r24, Z
    1094:	48 2f       	mov	r20, r24
    1096:	8a 81       	ldd	r24, Y+2	; 0x02
    1098:	28 2f       	mov	r18, r24
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	81 e0       	ldi	r24, 0x01	; 1
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	02 2e       	mov	r0, r18
    10a2:	02 c0       	rjmp	.+4      	; 0x10a8 <DIO_VidSetPinValue+0x190>
    10a4:	88 0f       	add	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	0a 94       	dec	r0
    10aa:	e2 f7       	brpl	.-8      	; 0x10a4 <DIO_VidSetPinValue+0x18c>
    10ac:	80 95       	com	r24
    10ae:	84 23       	and	r24, r20
    10b0:	8c 93       	st	X, r24
    10b2:	29 c0       	rjmp	.+82     	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 2:CLR_BIT(PORTC,loc_u8pin);break;
    10b4:	a5 e3       	ldi	r26, 0x35	; 53
    10b6:	b0 e0       	ldi	r27, 0x00	; 0
    10b8:	e5 e3       	ldi	r30, 0x35	; 53
    10ba:	f0 e0       	ldi	r31, 0x00	; 0
    10bc:	80 81       	ld	r24, Z
    10be:	48 2f       	mov	r20, r24
    10c0:	8a 81       	ldd	r24, Y+2	; 0x02
    10c2:	28 2f       	mov	r18, r24
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	90 e0       	ldi	r25, 0x00	; 0
    10ca:	02 2e       	mov	r0, r18
    10cc:	02 c0       	rjmp	.+4      	; 0x10d2 <DIO_VidSetPinValue+0x1ba>
    10ce:	88 0f       	add	r24, r24
    10d0:	99 1f       	adc	r25, r25
    10d2:	0a 94       	dec	r0
    10d4:	e2 f7       	brpl	.-8      	; 0x10ce <DIO_VidSetPinValue+0x1b6>
    10d6:	80 95       	com	r24
    10d8:	84 23       	and	r24, r20
    10da:	8c 93       	st	X, r24
    10dc:	14 c0       	rjmp	.+40     	; 0x1106 <DIO_VidSetPinValue+0x1ee>
		case 3:CLR_BIT(PORTD,loc_u8pin);break;
    10de:	a2 e3       	ldi	r26, 0x32	; 50
    10e0:	b0 e0       	ldi	r27, 0x00	; 0
    10e2:	e2 e3       	ldi	r30, 0x32	; 50
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	80 81       	ld	r24, Z
    10e8:	48 2f       	mov	r20, r24
    10ea:	8a 81       	ldd	r24, Y+2	; 0x02
    10ec:	28 2f       	mov	r18, r24
    10ee:	30 e0       	ldi	r19, 0x00	; 0
    10f0:	81 e0       	ldi	r24, 0x01	; 1
    10f2:	90 e0       	ldi	r25, 0x00	; 0
    10f4:	02 2e       	mov	r0, r18
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <DIO_VidSetPinValue+0x1e4>
    10f8:	88 0f       	add	r24, r24
    10fa:	99 1f       	adc	r25, r25
    10fc:	0a 94       	dec	r0
    10fe:	e2 f7       	brpl	.-8      	; 0x10f8 <DIO_VidSetPinValue+0x1e0>
    1100:	80 95       	com	r24
    1102:	84 23       	and	r24, r20
    1104:	8c 93       	st	X, r24
	 }
	}
}
    1106:	27 96       	adiw	r28, 0x07	; 7
    1108:	0f b6       	in	r0, 0x3f	; 63
    110a:	f8 94       	cli
    110c:	de bf       	out	0x3e, r29	; 62
    110e:	0f be       	out	0x3f, r0	; 63
    1110:	cd bf       	out	0x3d, r28	; 61
    1112:	cf 91       	pop	r28
    1114:	df 91       	pop	r29
    1116:	08 95       	ret

00001118 <DIO_VidSetPortDirection>:
void DIO_VidSetPortDirection(u8 loc_u8port,u8 loc_u8value){
    1118:	df 93       	push	r29
    111a:	cf 93       	push	r28
    111c:	00 d0       	rcall	.+0      	; 0x111e <DIO_VidSetPortDirection+0x6>
    111e:	00 d0       	rcall	.+0      	; 0x1120 <DIO_VidSetPortDirection+0x8>
    1120:	cd b7       	in	r28, 0x3d	; 61
    1122:	de b7       	in	r29, 0x3e	; 62
    1124:	89 83       	std	Y+1, r24	; 0x01
    1126:	6a 83       	std	Y+2, r22	; 0x02
	

			switch(loc_u8port){
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	28 2f       	mov	r18, r24
    112c:	30 e0       	ldi	r19, 0x00	; 0
    112e:	3c 83       	std	Y+4, r19	; 0x04
    1130:	2b 83       	std	Y+3, r18	; 0x03
    1132:	8b 81       	ldd	r24, Y+3	; 0x03
    1134:	9c 81       	ldd	r25, Y+4	; 0x04
    1136:	81 30       	cpi	r24, 0x01	; 1
    1138:	91 05       	cpc	r25, r1
    113a:	d1 f0       	breq	.+52     	; 0x1170 <DIO_VidSetPortDirection+0x58>
    113c:	2b 81       	ldd	r18, Y+3	; 0x03
    113e:	3c 81       	ldd	r19, Y+4	; 0x04
    1140:	22 30       	cpi	r18, 0x02	; 2
    1142:	31 05       	cpc	r19, r1
    1144:	2c f4       	brge	.+10     	; 0x1150 <DIO_VidSetPortDirection+0x38>
    1146:	8b 81       	ldd	r24, Y+3	; 0x03
    1148:	9c 81       	ldd	r25, Y+4	; 0x04
    114a:	00 97       	sbiw	r24, 0x00	; 0
    114c:	61 f0       	breq	.+24     	; 0x1166 <DIO_VidSetPortDirection+0x4e>
    114e:	1e c0       	rjmp	.+60     	; 0x118c <DIO_VidSetPortDirection+0x74>
    1150:	2b 81       	ldd	r18, Y+3	; 0x03
    1152:	3c 81       	ldd	r19, Y+4	; 0x04
    1154:	22 30       	cpi	r18, 0x02	; 2
    1156:	31 05       	cpc	r19, r1
    1158:	81 f0       	breq	.+32     	; 0x117a <DIO_VidSetPortDirection+0x62>
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	9c 81       	ldd	r25, Y+4	; 0x04
    115e:	83 30       	cpi	r24, 0x03	; 3
    1160:	91 05       	cpc	r25, r1
    1162:	81 f0       	breq	.+32     	; 0x1184 <DIO_VidSetPortDirection+0x6c>
    1164:	13 c0       	rjmp	.+38     	; 0x118c <DIO_VidSetPortDirection+0x74>

			case 0:DDRA=loc_u8value;break;
    1166:	ea e3       	ldi	r30, 0x3A	; 58
    1168:	f0 e0       	ldi	r31, 0x00	; 0
    116a:	8a 81       	ldd	r24, Y+2	; 0x02
    116c:	80 83       	st	Z, r24
    116e:	0e c0       	rjmp	.+28     	; 0x118c <DIO_VidSetPortDirection+0x74>
			case 1:DDRB=loc_u8value;break;
    1170:	e7 e3       	ldi	r30, 0x37	; 55
    1172:	f0 e0       	ldi	r31, 0x00	; 0
    1174:	8a 81       	ldd	r24, Y+2	; 0x02
    1176:	80 83       	st	Z, r24
    1178:	09 c0       	rjmp	.+18     	; 0x118c <DIO_VidSetPortDirection+0x74>
			case 2:DDRC=loc_u8value;break;
    117a:	e4 e3       	ldi	r30, 0x34	; 52
    117c:	f0 e0       	ldi	r31, 0x00	; 0
    117e:	8a 81       	ldd	r24, Y+2	; 0x02
    1180:	80 83       	st	Z, r24
    1182:	04 c0       	rjmp	.+8      	; 0x118c <DIO_VidSetPortDirection+0x74>
			case 3:DDRD=loc_u8value;break;
    1184:	e1 e3       	ldi	r30, 0x31	; 49
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	8a 81       	ldd	r24, Y+2	; 0x02
    118a:	80 83       	st	Z, r24

			}
		
}
    118c:	0f 90       	pop	r0
    118e:	0f 90       	pop	r0
    1190:	0f 90       	pop	r0
    1192:	0f 90       	pop	r0
    1194:	cf 91       	pop	r28
    1196:	df 91       	pop	r29
    1198:	08 95       	ret

0000119a <DIO_VidSetPortValue>:
void DIO_VidSetPortValue(u8 loc_u8port,u8 loc_u8value){
    119a:	df 93       	push	r29
    119c:	cf 93       	push	r28
    119e:	00 d0       	rcall	.+0      	; 0x11a0 <DIO_VidSetPortValue+0x6>
    11a0:	00 d0       	rcall	.+0      	; 0x11a2 <DIO_VidSetPortValue+0x8>
    11a2:	cd b7       	in	r28, 0x3d	; 61
    11a4:	de b7       	in	r29, 0x3e	; 62
    11a6:	89 83       	std	Y+1, r24	; 0x01
    11a8:	6a 83       	std	Y+2, r22	; 0x02
	
			switch(loc_u8port){
    11aa:	89 81       	ldd	r24, Y+1	; 0x01
    11ac:	28 2f       	mov	r18, r24
    11ae:	30 e0       	ldi	r19, 0x00	; 0
    11b0:	3c 83       	std	Y+4, r19	; 0x04
    11b2:	2b 83       	std	Y+3, r18	; 0x03
    11b4:	8b 81       	ldd	r24, Y+3	; 0x03
    11b6:	9c 81       	ldd	r25, Y+4	; 0x04
    11b8:	81 30       	cpi	r24, 0x01	; 1
    11ba:	91 05       	cpc	r25, r1
    11bc:	d1 f0       	breq	.+52     	; 0x11f2 <DIO_VidSetPortValue+0x58>
    11be:	2b 81       	ldd	r18, Y+3	; 0x03
    11c0:	3c 81       	ldd	r19, Y+4	; 0x04
    11c2:	22 30       	cpi	r18, 0x02	; 2
    11c4:	31 05       	cpc	r19, r1
    11c6:	2c f4       	brge	.+10     	; 0x11d2 <DIO_VidSetPortValue+0x38>
    11c8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ca:	9c 81       	ldd	r25, Y+4	; 0x04
    11cc:	00 97       	sbiw	r24, 0x00	; 0
    11ce:	61 f0       	breq	.+24     	; 0x11e8 <DIO_VidSetPortValue+0x4e>
    11d0:	1e c0       	rjmp	.+60     	; 0x120e <DIO_VidSetPortValue+0x74>
    11d2:	2b 81       	ldd	r18, Y+3	; 0x03
    11d4:	3c 81       	ldd	r19, Y+4	; 0x04
    11d6:	22 30       	cpi	r18, 0x02	; 2
    11d8:	31 05       	cpc	r19, r1
    11da:	81 f0       	breq	.+32     	; 0x11fc <DIO_VidSetPortValue+0x62>
    11dc:	8b 81       	ldd	r24, Y+3	; 0x03
    11de:	9c 81       	ldd	r25, Y+4	; 0x04
    11e0:	83 30       	cpi	r24, 0x03	; 3
    11e2:	91 05       	cpc	r25, r1
    11e4:	81 f0       	breq	.+32     	; 0x1206 <DIO_VidSetPortValue+0x6c>
    11e6:	13 c0       	rjmp	.+38     	; 0x120e <DIO_VidSetPortValue+0x74>

			case 0:PORTA=loc_u8value;break;
    11e8:	eb e3       	ldi	r30, 0x3B	; 59
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	8a 81       	ldd	r24, Y+2	; 0x02
    11ee:	80 83       	st	Z, r24
    11f0:	0e c0       	rjmp	.+28     	; 0x120e <DIO_VidSetPortValue+0x74>
			case 1:PORTB=loc_u8value;break;
    11f2:	e8 e3       	ldi	r30, 0x38	; 56
    11f4:	f0 e0       	ldi	r31, 0x00	; 0
    11f6:	8a 81       	ldd	r24, Y+2	; 0x02
    11f8:	80 83       	st	Z, r24
    11fa:	09 c0       	rjmp	.+18     	; 0x120e <DIO_VidSetPortValue+0x74>
			case 2:PORTC=loc_u8value;break;
    11fc:	e5 e3       	ldi	r30, 0x35	; 53
    11fe:	f0 e0       	ldi	r31, 0x00	; 0
    1200:	8a 81       	ldd	r24, Y+2	; 0x02
    1202:	80 83       	st	Z, r24
    1204:	04 c0       	rjmp	.+8      	; 0x120e <DIO_VidSetPortValue+0x74>
			case 3:PORTD=loc_u8value;break;
    1206:	e2 e3       	ldi	r30, 0x32	; 50
    1208:	f0 e0       	ldi	r31, 0x00	; 0
    120a:	8a 81       	ldd	r24, Y+2	; 0x02
    120c:	80 83       	st	Z, r24

			}
	
}
    120e:	0f 90       	pop	r0
    1210:	0f 90       	pop	r0
    1212:	0f 90       	pop	r0
    1214:	0f 90       	pop	r0
    1216:	cf 91       	pop	r28
    1218:	df 91       	pop	r29
    121a:	08 95       	ret

0000121c <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 loc_u8port,u8 loc_u8pin){
    121c:	df 93       	push	r29
    121e:	cf 93       	push	r28
    1220:	00 d0       	rcall	.+0      	; 0x1222 <DIO_u8GetPinValue+0x6>
    1222:	00 d0       	rcall	.+0      	; 0x1224 <DIO_u8GetPinValue+0x8>
    1224:	0f 92       	push	r0
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
    122a:	8a 83       	std	Y+2, r24	; 0x02
    122c:	6b 83       	std	Y+3, r22	; 0x03
	u8 VALUE;
	switch(loc_u8port){
    122e:	8a 81       	ldd	r24, Y+2	; 0x02
    1230:	28 2f       	mov	r18, r24
    1232:	30 e0       	ldi	r19, 0x00	; 0
    1234:	3d 83       	std	Y+5, r19	; 0x05
    1236:	2c 83       	std	Y+4, r18	; 0x04
    1238:	4c 81       	ldd	r20, Y+4	; 0x04
    123a:	5d 81       	ldd	r21, Y+5	; 0x05
    123c:	41 30       	cpi	r20, 0x01	; 1
    123e:	51 05       	cpc	r21, r1
    1240:	41 f1       	breq	.+80     	; 0x1292 <DIO_u8GetPinValue+0x76>
    1242:	8c 81       	ldd	r24, Y+4	; 0x04
    1244:	9d 81       	ldd	r25, Y+5	; 0x05
    1246:	82 30       	cpi	r24, 0x02	; 2
    1248:	91 05       	cpc	r25, r1
    124a:	34 f4       	brge	.+12     	; 0x1258 <DIO_u8GetPinValue+0x3c>
    124c:	2c 81       	ldd	r18, Y+4	; 0x04
    124e:	3d 81       	ldd	r19, Y+5	; 0x05
    1250:	21 15       	cp	r18, r1
    1252:	31 05       	cpc	r19, r1
    1254:	61 f0       	breq	.+24     	; 0x126e <DIO_u8GetPinValue+0x52>
    1256:	52 c0       	rjmp	.+164    	; 0x12fc <DIO_u8GetPinValue+0xe0>
    1258:	4c 81       	ldd	r20, Y+4	; 0x04
    125a:	5d 81       	ldd	r21, Y+5	; 0x05
    125c:	42 30       	cpi	r20, 0x02	; 2
    125e:	51 05       	cpc	r21, r1
    1260:	51 f1       	breq	.+84     	; 0x12b6 <DIO_u8GetPinValue+0x9a>
    1262:	8c 81       	ldd	r24, Y+4	; 0x04
    1264:	9d 81       	ldd	r25, Y+5	; 0x05
    1266:	83 30       	cpi	r24, 0x03	; 3
    1268:	91 05       	cpc	r25, r1
    126a:	b9 f1       	breq	.+110    	; 0x12da <DIO_u8GetPinValue+0xbe>
    126c:	47 c0       	rjmp	.+142    	; 0x12fc <DIO_u8GetPinValue+0xe0>
		case 0:VALUE=GET_BIT(PINA,loc_u8pin); break;
    126e:	e9 e3       	ldi	r30, 0x39	; 57
    1270:	f0 e0       	ldi	r31, 0x00	; 0
    1272:	80 81       	ld	r24, Z
    1274:	28 2f       	mov	r18, r24
    1276:	30 e0       	ldi	r19, 0x00	; 0
    1278:	8b 81       	ldd	r24, Y+3	; 0x03
    127a:	88 2f       	mov	r24, r24
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	a9 01       	movw	r20, r18
    1280:	02 c0       	rjmp	.+4      	; 0x1286 <DIO_u8GetPinValue+0x6a>
    1282:	55 95       	asr	r21
    1284:	47 95       	ror	r20
    1286:	8a 95       	dec	r24
    1288:	e2 f7       	brpl	.-8      	; 0x1282 <DIO_u8GetPinValue+0x66>
    128a:	ca 01       	movw	r24, r20
    128c:	81 70       	andi	r24, 0x01	; 1
    128e:	89 83       	std	Y+1, r24	; 0x01
    1290:	35 c0       	rjmp	.+106    	; 0x12fc <DIO_u8GetPinValue+0xe0>
		case 1:VALUE=GET_BIT(PINB,loc_u8pin); break;
    1292:	e6 e3       	ldi	r30, 0x36	; 54
    1294:	f0 e0       	ldi	r31, 0x00	; 0
    1296:	80 81       	ld	r24, Z
    1298:	28 2f       	mov	r18, r24
    129a:	30 e0       	ldi	r19, 0x00	; 0
    129c:	8b 81       	ldd	r24, Y+3	; 0x03
    129e:	88 2f       	mov	r24, r24
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	a9 01       	movw	r20, r18
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <DIO_u8GetPinValue+0x8e>
    12a6:	55 95       	asr	r21
    12a8:	47 95       	ror	r20
    12aa:	8a 95       	dec	r24
    12ac:	e2 f7       	brpl	.-8      	; 0x12a6 <DIO_u8GetPinValue+0x8a>
    12ae:	ca 01       	movw	r24, r20
    12b0:	81 70       	andi	r24, 0x01	; 1
    12b2:	89 83       	std	Y+1, r24	; 0x01
    12b4:	23 c0       	rjmp	.+70     	; 0x12fc <DIO_u8GetPinValue+0xe0>
		case 2:VALUE=GET_BIT(PINC,loc_u8pin); break;
    12b6:	e3 e3       	ldi	r30, 0x33	; 51
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	80 81       	ld	r24, Z
    12bc:	28 2f       	mov	r18, r24
    12be:	30 e0       	ldi	r19, 0x00	; 0
    12c0:	8b 81       	ldd	r24, Y+3	; 0x03
    12c2:	88 2f       	mov	r24, r24
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	a9 01       	movw	r20, r18
    12c8:	02 c0       	rjmp	.+4      	; 0x12ce <DIO_u8GetPinValue+0xb2>
    12ca:	55 95       	asr	r21
    12cc:	47 95       	ror	r20
    12ce:	8a 95       	dec	r24
    12d0:	e2 f7       	brpl	.-8      	; 0x12ca <DIO_u8GetPinValue+0xae>
    12d2:	ca 01       	movw	r24, r20
    12d4:	81 70       	andi	r24, 0x01	; 1
    12d6:	89 83       	std	Y+1, r24	; 0x01
    12d8:	11 c0       	rjmp	.+34     	; 0x12fc <DIO_u8GetPinValue+0xe0>
		case 3:VALUE=GET_BIT(PIND,loc_u8pin); break;
    12da:	e0 e3       	ldi	r30, 0x30	; 48
    12dc:	f0 e0       	ldi	r31, 0x00	; 0
    12de:	80 81       	ld	r24, Z
    12e0:	28 2f       	mov	r18, r24
    12e2:	30 e0       	ldi	r19, 0x00	; 0
    12e4:	8b 81       	ldd	r24, Y+3	; 0x03
    12e6:	88 2f       	mov	r24, r24
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	a9 01       	movw	r20, r18
    12ec:	02 c0       	rjmp	.+4      	; 0x12f2 <DIO_u8GetPinValue+0xd6>
    12ee:	55 95       	asr	r21
    12f0:	47 95       	ror	r20
    12f2:	8a 95       	dec	r24
    12f4:	e2 f7       	brpl	.-8      	; 0x12ee <DIO_u8GetPinValue+0xd2>
    12f6:	ca 01       	movw	r24, r20
    12f8:	81 70       	andi	r24, 0x01	; 1
    12fa:	89 83       	std	Y+1, r24	; 0x01
	 }
	 return VALUE;
    12fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    12fe:	0f 90       	pop	r0
    1300:	0f 90       	pop	r0
    1302:	0f 90       	pop	r0
    1304:	0f 90       	pop	r0
    1306:	0f 90       	pop	r0
    1308:	cf 91       	pop	r28
    130a:	df 91       	pop	r29
    130c:	08 95       	ret

0000130e <DIO_VidTogBit>:

void DIO_VidTogBit(u8 loc_u8port,u8 LOC_u8BitNum){
    130e:	df 93       	push	r29
    1310:	cf 93       	push	r28
    1312:	00 d0       	rcall	.+0      	; 0x1314 <DIO_VidTogBit+0x6>
    1314:	00 d0       	rcall	.+0      	; 0x1316 <DIO_VidTogBit+0x8>
    1316:	cd b7       	in	r28, 0x3d	; 61
    1318:	de b7       	in	r29, 0x3e	; 62
    131a:	89 83       	std	Y+1, r24	; 0x01
    131c:	6a 83       	std	Y+2, r22	; 0x02
	switch(loc_u8port){
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	28 2f       	mov	r18, r24
    1322:	30 e0       	ldi	r19, 0x00	; 0
    1324:	3c 83       	std	Y+4, r19	; 0x04
    1326:	2b 83       	std	Y+3, r18	; 0x03
    1328:	8b 81       	ldd	r24, Y+3	; 0x03
    132a:	9c 81       	ldd	r25, Y+4	; 0x04
    132c:	81 30       	cpi	r24, 0x01	; 1
    132e:	91 05       	cpc	r25, r1
    1330:	49 f1       	breq	.+82     	; 0x1384 <DIO_VidTogBit+0x76>
    1332:	2b 81       	ldd	r18, Y+3	; 0x03
    1334:	3c 81       	ldd	r19, Y+4	; 0x04
    1336:	22 30       	cpi	r18, 0x02	; 2
    1338:	31 05       	cpc	r19, r1
    133a:	2c f4       	brge	.+10     	; 0x1346 <DIO_VidTogBit+0x38>
    133c:	8b 81       	ldd	r24, Y+3	; 0x03
    133e:	9c 81       	ldd	r25, Y+4	; 0x04
    1340:	00 97       	sbiw	r24, 0x00	; 0
    1342:	61 f0       	breq	.+24     	; 0x135c <DIO_VidTogBit+0x4e>
    1344:	5a c0       	rjmp	.+180    	; 0x13fa <DIO_VidTogBit+0xec>
    1346:	2b 81       	ldd	r18, Y+3	; 0x03
    1348:	3c 81       	ldd	r19, Y+4	; 0x04
    134a:	22 30       	cpi	r18, 0x02	; 2
    134c:	31 05       	cpc	r19, r1
    134e:	71 f1       	breq	.+92     	; 0x13ac <DIO_VidTogBit+0x9e>
    1350:	8b 81       	ldd	r24, Y+3	; 0x03
    1352:	9c 81       	ldd	r25, Y+4	; 0x04
    1354:	83 30       	cpi	r24, 0x03	; 3
    1356:	91 05       	cpc	r25, r1
    1358:	e9 f1       	breq	.+122    	; 0x13d4 <DIO_VidTogBit+0xc6>
    135a:	4f c0       	rjmp	.+158    	; 0x13fa <DIO_VidTogBit+0xec>
		case 0: TOG_BIT(PORTA,LOC_u8BitNum); break;
    135c:	ab e3       	ldi	r26, 0x3B	; 59
    135e:	b0 e0       	ldi	r27, 0x00	; 0
    1360:	eb e3       	ldi	r30, 0x3B	; 59
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	48 2f       	mov	r20, r24
    1368:	8a 81       	ldd	r24, Y+2	; 0x02
    136a:	28 2f       	mov	r18, r24
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	81 e0       	ldi	r24, 0x01	; 1
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	02 2e       	mov	r0, r18
    1374:	02 c0       	rjmp	.+4      	; 0x137a <DIO_VidTogBit+0x6c>
    1376:	88 0f       	add	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	0a 94       	dec	r0
    137c:	e2 f7       	brpl	.-8      	; 0x1376 <DIO_VidTogBit+0x68>
    137e:	84 27       	eor	r24, r20
    1380:	8c 93       	st	X, r24
    1382:	3b c0       	rjmp	.+118    	; 0x13fa <DIO_VidTogBit+0xec>
		case 1: TOG_BIT(PORTB,LOC_u8BitNum); break;
    1384:	a8 e3       	ldi	r26, 0x38	; 56
    1386:	b0 e0       	ldi	r27, 0x00	; 0
    1388:	e8 e3       	ldi	r30, 0x38	; 56
    138a:	f0 e0       	ldi	r31, 0x00	; 0
    138c:	80 81       	ld	r24, Z
    138e:	48 2f       	mov	r20, r24
    1390:	8a 81       	ldd	r24, Y+2	; 0x02
    1392:	28 2f       	mov	r18, r24
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	81 e0       	ldi	r24, 0x01	; 1
    1398:	90 e0       	ldi	r25, 0x00	; 0
    139a:	02 2e       	mov	r0, r18
    139c:	02 c0       	rjmp	.+4      	; 0x13a2 <DIO_VidTogBit+0x94>
    139e:	88 0f       	add	r24, r24
    13a0:	99 1f       	adc	r25, r25
    13a2:	0a 94       	dec	r0
    13a4:	e2 f7       	brpl	.-8      	; 0x139e <DIO_VidTogBit+0x90>
    13a6:	84 27       	eor	r24, r20
    13a8:	8c 93       	st	X, r24
    13aa:	27 c0       	rjmp	.+78     	; 0x13fa <DIO_VidTogBit+0xec>
		case 2: TOG_BIT(PORTC,LOC_u8BitNum); break;
    13ac:	a5 e3       	ldi	r26, 0x35	; 53
    13ae:	b0 e0       	ldi	r27, 0x00	; 0
    13b0:	e5 e3       	ldi	r30, 0x35	; 53
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
    13b4:	80 81       	ld	r24, Z
    13b6:	48 2f       	mov	r20, r24
    13b8:	8a 81       	ldd	r24, Y+2	; 0x02
    13ba:	28 2f       	mov	r18, r24
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	81 e0       	ldi	r24, 0x01	; 1
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	02 2e       	mov	r0, r18
    13c4:	02 c0       	rjmp	.+4      	; 0x13ca <DIO_VidTogBit+0xbc>
    13c6:	88 0f       	add	r24, r24
    13c8:	99 1f       	adc	r25, r25
    13ca:	0a 94       	dec	r0
    13cc:	e2 f7       	brpl	.-8      	; 0x13c6 <DIO_VidTogBit+0xb8>
    13ce:	84 27       	eor	r24, r20
    13d0:	8c 93       	st	X, r24
    13d2:	13 c0       	rjmp	.+38     	; 0x13fa <DIO_VidTogBit+0xec>
		case 3: TOG_BIT(PORTD,LOC_u8BitNum); break;
    13d4:	a2 e3       	ldi	r26, 0x32	; 50
    13d6:	b0 e0       	ldi	r27, 0x00	; 0
    13d8:	e2 e3       	ldi	r30, 0x32	; 50
    13da:	f0 e0       	ldi	r31, 0x00	; 0
    13dc:	80 81       	ld	r24, Z
    13de:	48 2f       	mov	r20, r24
    13e0:	8a 81       	ldd	r24, Y+2	; 0x02
    13e2:	28 2f       	mov	r18, r24
    13e4:	30 e0       	ldi	r19, 0x00	; 0
    13e6:	81 e0       	ldi	r24, 0x01	; 1
    13e8:	90 e0       	ldi	r25, 0x00	; 0
    13ea:	02 2e       	mov	r0, r18
    13ec:	02 c0       	rjmp	.+4      	; 0x13f2 <DIO_VidTogBit+0xe4>
    13ee:	88 0f       	add	r24, r24
    13f0:	99 1f       	adc	r25, r25
    13f2:	0a 94       	dec	r0
    13f4:	e2 f7       	brpl	.-8      	; 0x13ee <DIO_VidTogBit+0xe0>
    13f6:	84 27       	eor	r24, r20
    13f8:	8c 93       	st	X, r24
	}	
}
    13fa:	0f 90       	pop	r0
    13fc:	0f 90       	pop	r0
    13fe:	0f 90       	pop	r0
    1400:	0f 90       	pop	r0
    1402:	cf 91       	pop	r28
    1404:	df 91       	pop	r29
    1406:	08 95       	ret

00001408 <LCD_VidEnable>:
	#include "BIT_MATH.h"
	#include "DIO_interface.h"
	#include "LCD_interface.h"
	#include "avr/delay.h"

	void LCD_VidEnable(void){
    1408:	df 93       	push	r29
    140a:	cf 93       	push	r28
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	6c 97       	sbiw	r28, 0x1c	; 28
    1412:	0f b6       	in	r0, 0x3f	; 63
    1414:	f8 94       	cli
    1416:	de bf       	out	0x3e, r29	; 62
    1418:	0f be       	out	0x3f, r0	; 63
    141a:	cd bf       	out	0x3d, r28	; 61
		DIO_VidSetPinValue(CTRL_PORT,ES_PIN,HIGH); // EN raising edge//
    141c:	83 e0       	ldi	r24, 0x03	; 3
    141e:	62 e0       	ldi	r22, 0x02	; 2
    1420:	41 e0       	ldi	r20, 0x01	; 1
    1422:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
    1426:	80 e0       	ldi	r24, 0x00	; 0
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	a0 e8       	ldi	r26, 0x80	; 128
    142c:	bf e3       	ldi	r27, 0x3F	; 63
    142e:	89 8f       	std	Y+25, r24	; 0x19
    1430:	9a 8f       	std	Y+26, r25	; 0x1a
    1432:	ab 8f       	std	Y+27, r26	; 0x1b
    1434:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1436:	69 8d       	ldd	r22, Y+25	; 0x19
    1438:	7a 8d       	ldd	r23, Y+26	; 0x1a
    143a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    143c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    143e:	20 e0       	ldi	r18, 0x00	; 0
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	4a ef       	ldi	r20, 0xFA	; 250
    1444:	54 e4       	ldi	r21, 0x44	; 68
    1446:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    144a:	dc 01       	movw	r26, r24
    144c:	cb 01       	movw	r24, r22
    144e:	8d 8b       	std	Y+21, r24	; 0x15
    1450:	9e 8b       	std	Y+22, r25	; 0x16
    1452:	af 8b       	std	Y+23, r26	; 0x17
    1454:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1456:	6d 89       	ldd	r22, Y+21	; 0x15
    1458:	7e 89       	ldd	r23, Y+22	; 0x16
    145a:	8f 89       	ldd	r24, Y+23	; 0x17
    145c:	98 8d       	ldd	r25, Y+24	; 0x18
    145e:	20 e0       	ldi	r18, 0x00	; 0
    1460:	30 e0       	ldi	r19, 0x00	; 0
    1462:	40 e8       	ldi	r20, 0x80	; 128
    1464:	5f e3       	ldi	r21, 0x3F	; 63
    1466:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    146a:	88 23       	and	r24, r24
    146c:	2c f4       	brge	.+10     	; 0x1478 <LCD_VidEnable+0x70>
		__ticks = 1;
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	9c 8b       	std	Y+20, r25	; 0x14
    1474:	8b 8b       	std	Y+19, r24	; 0x13
    1476:	3f c0       	rjmp	.+126    	; 0x14f6 <LCD_VidEnable+0xee>
	else if (__tmp > 65535)
    1478:	6d 89       	ldd	r22, Y+21	; 0x15
    147a:	7e 89       	ldd	r23, Y+22	; 0x16
    147c:	8f 89       	ldd	r24, Y+23	; 0x17
    147e:	98 8d       	ldd	r25, Y+24	; 0x18
    1480:	20 e0       	ldi	r18, 0x00	; 0
    1482:	3f ef       	ldi	r19, 0xFF	; 255
    1484:	4f e7       	ldi	r20, 0x7F	; 127
    1486:	57 e4       	ldi	r21, 0x47	; 71
    1488:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    148c:	18 16       	cp	r1, r24
    148e:	4c f5       	brge	.+82     	; 0x14e2 <LCD_VidEnable+0xda>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1490:	69 8d       	ldd	r22, Y+25	; 0x19
    1492:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1494:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1496:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1498:	20 e0       	ldi	r18, 0x00	; 0
    149a:	30 e0       	ldi	r19, 0x00	; 0
    149c:	40 e2       	ldi	r20, 0x20	; 32
    149e:	51 e4       	ldi	r21, 0x41	; 65
    14a0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14a4:	dc 01       	movw	r26, r24
    14a6:	cb 01       	movw	r24, r22
    14a8:	bc 01       	movw	r22, r24
    14aa:	cd 01       	movw	r24, r26
    14ac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14b0:	dc 01       	movw	r26, r24
    14b2:	cb 01       	movw	r24, r22
    14b4:	9c 8b       	std	Y+20, r25	; 0x14
    14b6:	8b 8b       	std	Y+19, r24	; 0x13
    14b8:	0f c0       	rjmp	.+30     	; 0x14d8 <LCD_VidEnable+0xd0>
    14ba:	88 ec       	ldi	r24, 0xC8	; 200
    14bc:	90 e0       	ldi	r25, 0x00	; 0
    14be:	9a 8b       	std	Y+18, r25	; 0x12
    14c0:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    14c2:	89 89       	ldd	r24, Y+17	; 0x11
    14c4:	9a 89       	ldd	r25, Y+18	; 0x12
    14c6:	01 97       	sbiw	r24, 0x01	; 1
    14c8:	f1 f7       	brne	.-4      	; 0x14c6 <LCD_VidEnable+0xbe>
    14ca:	9a 8b       	std	Y+18, r25	; 0x12
    14cc:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    14ce:	8b 89       	ldd	r24, Y+19	; 0x13
    14d0:	9c 89       	ldd	r25, Y+20	; 0x14
    14d2:	01 97       	sbiw	r24, 0x01	; 1
    14d4:	9c 8b       	std	Y+20, r25	; 0x14
    14d6:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    14d8:	8b 89       	ldd	r24, Y+19	; 0x13
    14da:	9c 89       	ldd	r25, Y+20	; 0x14
    14dc:	00 97       	sbiw	r24, 0x00	; 0
    14de:	69 f7       	brne	.-38     	; 0x14ba <LCD_VidEnable+0xb2>
    14e0:	14 c0       	rjmp	.+40     	; 0x150a <LCD_VidEnable+0x102>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    14e2:	6d 89       	ldd	r22, Y+21	; 0x15
    14e4:	7e 89       	ldd	r23, Y+22	; 0x16
    14e6:	8f 89       	ldd	r24, Y+23	; 0x17
    14e8:	98 8d       	ldd	r25, Y+24	; 0x18
    14ea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    14ee:	dc 01       	movw	r26, r24
    14f0:	cb 01       	movw	r24, r22
    14f2:	9c 8b       	std	Y+20, r25	; 0x14
    14f4:	8b 8b       	std	Y+19, r24	; 0x13
    14f6:	8b 89       	ldd	r24, Y+19	; 0x13
    14f8:	9c 89       	ldd	r25, Y+20	; 0x14
    14fa:	98 8b       	std	Y+16, r25	; 0x10
    14fc:	8f 87       	std	Y+15, r24	; 0x0f
    14fe:	8f 85       	ldd	r24, Y+15	; 0x0f
    1500:	98 89       	ldd	r25, Y+16	; 0x10
    1502:	01 97       	sbiw	r24, 0x01	; 1
    1504:	f1 f7       	brne	.-4      	; 0x1502 <LCD_VidEnable+0xfa>
    1506:	98 8b       	std	Y+16, r25	; 0x10
    1508:	8f 87       	std	Y+15, r24	; 0x0f
		_delay_ms(1);
		DIO_VidSetPinValue(CTRL_PORT,ES_PIN,LOW);// EN falling edge//
    150a:	83 e0       	ldi	r24, 0x03	; 3
    150c:	62 e0       	ldi	r22, 0x02	; 2
    150e:	40 e0       	ldi	r20, 0x00	; 0
    1510:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
    1514:	80 e0       	ldi	r24, 0x00	; 0
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	a0 e8       	ldi	r26, 0x80	; 128
    151a:	bf e3       	ldi	r27, 0x3F	; 63
    151c:	8b 87       	std	Y+11, r24	; 0x0b
    151e:	9c 87       	std	Y+12, r25	; 0x0c
    1520:	ad 87       	std	Y+13, r26	; 0x0d
    1522:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1524:	6b 85       	ldd	r22, Y+11	; 0x0b
    1526:	7c 85       	ldd	r23, Y+12	; 0x0c
    1528:	8d 85       	ldd	r24, Y+13	; 0x0d
    152a:	9e 85       	ldd	r25, Y+14	; 0x0e
    152c:	20 e0       	ldi	r18, 0x00	; 0
    152e:	30 e0       	ldi	r19, 0x00	; 0
    1530:	4a ef       	ldi	r20, 0xFA	; 250
    1532:	54 e4       	ldi	r21, 0x44	; 68
    1534:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1538:	dc 01       	movw	r26, r24
    153a:	cb 01       	movw	r24, r22
    153c:	8f 83       	std	Y+7, r24	; 0x07
    153e:	98 87       	std	Y+8, r25	; 0x08
    1540:	a9 87       	std	Y+9, r26	; 0x09
    1542:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1544:	6f 81       	ldd	r22, Y+7	; 0x07
    1546:	78 85       	ldd	r23, Y+8	; 0x08
    1548:	89 85       	ldd	r24, Y+9	; 0x09
    154a:	9a 85       	ldd	r25, Y+10	; 0x0a
    154c:	20 e0       	ldi	r18, 0x00	; 0
    154e:	30 e0       	ldi	r19, 0x00	; 0
    1550:	40 e8       	ldi	r20, 0x80	; 128
    1552:	5f e3       	ldi	r21, 0x3F	; 63
    1554:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1558:	88 23       	and	r24, r24
    155a:	2c f4       	brge	.+10     	; 0x1566 <LCD_VidEnable+0x15e>
		__ticks = 1;
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	90 e0       	ldi	r25, 0x00	; 0
    1560:	9e 83       	std	Y+6, r25	; 0x06
    1562:	8d 83       	std	Y+5, r24	; 0x05
    1564:	3f c0       	rjmp	.+126    	; 0x15e4 <LCD_VidEnable+0x1dc>
	else if (__tmp > 65535)
    1566:	6f 81       	ldd	r22, Y+7	; 0x07
    1568:	78 85       	ldd	r23, Y+8	; 0x08
    156a:	89 85       	ldd	r24, Y+9	; 0x09
    156c:	9a 85       	ldd	r25, Y+10	; 0x0a
    156e:	20 e0       	ldi	r18, 0x00	; 0
    1570:	3f ef       	ldi	r19, 0xFF	; 255
    1572:	4f e7       	ldi	r20, 0x7F	; 127
    1574:	57 e4       	ldi	r21, 0x47	; 71
    1576:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    157a:	18 16       	cp	r1, r24
    157c:	4c f5       	brge	.+82     	; 0x15d0 <LCD_VidEnable+0x1c8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    157e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1580:	7c 85       	ldd	r23, Y+12	; 0x0c
    1582:	8d 85       	ldd	r24, Y+13	; 0x0d
    1584:	9e 85       	ldd	r25, Y+14	; 0x0e
    1586:	20 e0       	ldi	r18, 0x00	; 0
    1588:	30 e0       	ldi	r19, 0x00	; 0
    158a:	40 e2       	ldi	r20, 0x20	; 32
    158c:	51 e4       	ldi	r21, 0x41	; 65
    158e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1592:	dc 01       	movw	r26, r24
    1594:	cb 01       	movw	r24, r22
    1596:	bc 01       	movw	r22, r24
    1598:	cd 01       	movw	r24, r26
    159a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    159e:	dc 01       	movw	r26, r24
    15a0:	cb 01       	movw	r24, r22
    15a2:	9e 83       	std	Y+6, r25	; 0x06
    15a4:	8d 83       	std	Y+5, r24	; 0x05
    15a6:	0f c0       	rjmp	.+30     	; 0x15c6 <LCD_VidEnable+0x1be>
    15a8:	88 ec       	ldi	r24, 0xC8	; 200
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	9c 83       	std	Y+4, r25	; 0x04
    15ae:	8b 83       	std	Y+3, r24	; 0x03
    15b0:	8b 81       	ldd	r24, Y+3	; 0x03
    15b2:	9c 81       	ldd	r25, Y+4	; 0x04
    15b4:	01 97       	sbiw	r24, 0x01	; 1
    15b6:	f1 f7       	brne	.-4      	; 0x15b4 <LCD_VidEnable+0x1ac>
    15b8:	9c 83       	std	Y+4, r25	; 0x04
    15ba:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    15bc:	8d 81       	ldd	r24, Y+5	; 0x05
    15be:	9e 81       	ldd	r25, Y+6	; 0x06
    15c0:	01 97       	sbiw	r24, 0x01	; 1
    15c2:	9e 83       	std	Y+6, r25	; 0x06
    15c4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    15c6:	8d 81       	ldd	r24, Y+5	; 0x05
    15c8:	9e 81       	ldd	r25, Y+6	; 0x06
    15ca:	00 97       	sbiw	r24, 0x00	; 0
    15cc:	69 f7       	brne	.-38     	; 0x15a8 <LCD_VidEnable+0x1a0>
    15ce:	14 c0       	rjmp	.+40     	; 0x15f8 <LCD_VidEnable+0x1f0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    15d0:	6f 81       	ldd	r22, Y+7	; 0x07
    15d2:	78 85       	ldd	r23, Y+8	; 0x08
    15d4:	89 85       	ldd	r24, Y+9	; 0x09
    15d6:	9a 85       	ldd	r25, Y+10	; 0x0a
    15d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    15dc:	dc 01       	movw	r26, r24
    15de:	cb 01       	movw	r24, r22
    15e0:	9e 83       	std	Y+6, r25	; 0x06
    15e2:	8d 83       	std	Y+5, r24	; 0x05
    15e4:	8d 81       	ldd	r24, Y+5	; 0x05
    15e6:	9e 81       	ldd	r25, Y+6	; 0x06
    15e8:	9a 83       	std	Y+2, r25	; 0x02
    15ea:	89 83       	std	Y+1, r24	; 0x01
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	9a 81       	ldd	r25, Y+2	; 0x02
    15f0:	01 97       	sbiw	r24, 0x01	; 1
    15f2:	f1 f7       	brne	.-4      	; 0x15f0 <LCD_VidEnable+0x1e8>
    15f4:	9a 83       	std	Y+2, r25	; 0x02
    15f6:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(1);
		
	}
    15f8:	6c 96       	adiw	r28, 0x1c	; 28
    15fa:	0f b6       	in	r0, 0x3f	; 63
    15fc:	f8 94       	cli
    15fe:	de bf       	out	0x3e, r29	; 62
    1600:	0f be       	out	0x3f, r0	; 63
    1602:	cd bf       	out	0x3d, r28	; 61
    1604:	cf 91       	pop	r28
    1606:	df 91       	pop	r29
    1608:	08 95       	ret

0000160a <LCD_VidInit>:


	/*u8 loc_u8DataPort=the port that connected from D0 to D7
	u8   loc_u8ControlPort=the port that connected to RS&RW&EN
	*/
	void LCD_VidInit(void){
    160a:	df 93       	push	r29
    160c:	cf 93       	push	r28
    160e:	cd b7       	in	r28, 0x3d	; 61
    1610:	de b7       	in	r29, 0x3e	; 62
    1612:	c1 54       	subi	r28, 0x41	; 65
    1614:	d0 40       	sbci	r29, 0x00	; 0
    1616:	0f b6       	in	r0, 0x3f	; 63
    1618:	f8 94       	cli
    161a:	de bf       	out	0x3e, r29	; 62
    161c:	0f be       	out	0x3f, r0	; 63
    161e:	cd bf       	out	0x3d, r28	; 61
    1620:	80 e0       	ldi	r24, 0x00	; 0
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	a8 e4       	ldi	r26, 0x48	; 72
    1626:	b2 e4       	ldi	r27, 0x42	; 66
    1628:	8d ab       	std	Y+53, r24	; 0x35
    162a:	9e ab       	std	Y+54, r25	; 0x36
    162c:	af ab       	std	Y+55, r26	; 0x37
    162e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1630:	6d a9       	ldd	r22, Y+53	; 0x35
    1632:	7e a9       	ldd	r23, Y+54	; 0x36
    1634:	8f a9       	ldd	r24, Y+55	; 0x37
    1636:	98 ad       	ldd	r25, Y+56	; 0x38
    1638:	20 e0       	ldi	r18, 0x00	; 0
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	4a ef       	ldi	r20, 0xFA	; 250
    163e:	54 e4       	ldi	r21, 0x44	; 68
    1640:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1644:	dc 01       	movw	r26, r24
    1646:	cb 01       	movw	r24, r22
    1648:	89 ab       	std	Y+49, r24	; 0x31
    164a:	9a ab       	std	Y+50, r25	; 0x32
    164c:	ab ab       	std	Y+51, r26	; 0x33
    164e:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    1650:	69 a9       	ldd	r22, Y+49	; 0x31
    1652:	7a a9       	ldd	r23, Y+50	; 0x32
    1654:	8b a9       	ldd	r24, Y+51	; 0x33
    1656:	9c a9       	ldd	r25, Y+52	; 0x34
    1658:	20 e0       	ldi	r18, 0x00	; 0
    165a:	30 e0       	ldi	r19, 0x00	; 0
    165c:	40 e8       	ldi	r20, 0x80	; 128
    165e:	5f e3       	ldi	r21, 0x3F	; 63
    1660:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1664:	88 23       	and	r24, r24
    1666:	2c f4       	brge	.+10     	; 0x1672 <LCD_VidInit+0x68>
		__ticks = 1;
    1668:	81 e0       	ldi	r24, 0x01	; 1
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	98 ab       	std	Y+48, r25	; 0x30
    166e:	8f a7       	std	Y+47, r24	; 0x2f
    1670:	3f c0       	rjmp	.+126    	; 0x16f0 <LCD_VidInit+0xe6>
	else if (__tmp > 65535)
    1672:	69 a9       	ldd	r22, Y+49	; 0x31
    1674:	7a a9       	ldd	r23, Y+50	; 0x32
    1676:	8b a9       	ldd	r24, Y+51	; 0x33
    1678:	9c a9       	ldd	r25, Y+52	; 0x34
    167a:	20 e0       	ldi	r18, 0x00	; 0
    167c:	3f ef       	ldi	r19, 0xFF	; 255
    167e:	4f e7       	ldi	r20, 0x7F	; 127
    1680:	57 e4       	ldi	r21, 0x47	; 71
    1682:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1686:	18 16       	cp	r1, r24
    1688:	4c f5       	brge	.+82     	; 0x16dc <LCD_VidInit+0xd2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    168a:	6d a9       	ldd	r22, Y+53	; 0x35
    168c:	7e a9       	ldd	r23, Y+54	; 0x36
    168e:	8f a9       	ldd	r24, Y+55	; 0x37
    1690:	98 ad       	ldd	r25, Y+56	; 0x38
    1692:	20 e0       	ldi	r18, 0x00	; 0
    1694:	30 e0       	ldi	r19, 0x00	; 0
    1696:	40 e2       	ldi	r20, 0x20	; 32
    1698:	51 e4       	ldi	r21, 0x41	; 65
    169a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    169e:	dc 01       	movw	r26, r24
    16a0:	cb 01       	movw	r24, r22
    16a2:	bc 01       	movw	r22, r24
    16a4:	cd 01       	movw	r24, r26
    16a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16aa:	dc 01       	movw	r26, r24
    16ac:	cb 01       	movw	r24, r22
    16ae:	98 ab       	std	Y+48, r25	; 0x30
    16b0:	8f a7       	std	Y+47, r24	; 0x2f
    16b2:	0f c0       	rjmp	.+30     	; 0x16d2 <LCD_VidInit+0xc8>
    16b4:	88 ec       	ldi	r24, 0xC8	; 200
    16b6:	90 e0       	ldi	r25, 0x00	; 0
    16b8:	9e a7       	std	Y+46, r25	; 0x2e
    16ba:	8d a7       	std	Y+45, r24	; 0x2d
    16bc:	8d a5       	ldd	r24, Y+45	; 0x2d
    16be:	9e a5       	ldd	r25, Y+46	; 0x2e
    16c0:	01 97       	sbiw	r24, 0x01	; 1
    16c2:	f1 f7       	brne	.-4      	; 0x16c0 <LCD_VidInit+0xb6>
    16c4:	9e a7       	std	Y+46, r25	; 0x2e
    16c6:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16c8:	8f a5       	ldd	r24, Y+47	; 0x2f
    16ca:	98 a9       	ldd	r25, Y+48	; 0x30
    16cc:	01 97       	sbiw	r24, 0x01	; 1
    16ce:	98 ab       	std	Y+48, r25	; 0x30
    16d0:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16d2:	8f a5       	ldd	r24, Y+47	; 0x2f
    16d4:	98 a9       	ldd	r25, Y+48	; 0x30
    16d6:	00 97       	sbiw	r24, 0x00	; 0
    16d8:	69 f7       	brne	.-38     	; 0x16b4 <LCD_VidInit+0xaa>
    16da:	14 c0       	rjmp	.+40     	; 0x1704 <LCD_VidInit+0xfa>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16dc:	69 a9       	ldd	r22, Y+49	; 0x31
    16de:	7a a9       	ldd	r23, Y+50	; 0x32
    16e0:	8b a9       	ldd	r24, Y+51	; 0x33
    16e2:	9c a9       	ldd	r25, Y+52	; 0x34
    16e4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16e8:	dc 01       	movw	r26, r24
    16ea:	cb 01       	movw	r24, r22
    16ec:	98 ab       	std	Y+48, r25	; 0x30
    16ee:	8f a7       	std	Y+47, r24	; 0x2f
    16f0:	8f a5       	ldd	r24, Y+47	; 0x2f
    16f2:	98 a9       	ldd	r25, Y+48	; 0x30
    16f4:	9c a7       	std	Y+44, r25	; 0x2c
    16f6:	8b a7       	std	Y+43, r24	; 0x2b
    16f8:	8b a5       	ldd	r24, Y+43	; 0x2b
    16fa:	9c a5       	ldd	r25, Y+44	; 0x2c
    16fc:	01 97       	sbiw	r24, 0x01	; 1
    16fe:	f1 f7       	brne	.-4      	; 0x16fc <LCD_VidInit+0xf2>
    1700:	9c a7       	std	Y+44, r25	; 0x2c
    1702:	8b a7       	std	Y+43, r24	; 0x2b
		_delay_ms(50);
	u8 i=0;	
    1704:	19 ae       	std	Y+57, r1	; 0x39
	u8 array[]={RS_PIN,RW_PIN,ES_PIN};	
    1706:	ce 01       	movw	r24, r28
    1708:	ca 96       	adiw	r24, 0x3a	; 58
    170a:	9e af       	std	Y+62, r25	; 0x3e
    170c:	8d af       	std	Y+61, r24	; 0x3d
    170e:	e9 e7       	ldi	r30, 0x79	; 121
    1710:	f0 e0       	ldi	r31, 0x00	; 0
    1712:	21 96       	adiw	r28, 0x01	; 1
    1714:	ff af       	std	Y+63, r31	; 0x3f
    1716:	ee af       	std	Y+62, r30	; 0x3e
    1718:	21 97       	sbiw	r28, 0x01	; 1
    171a:	f3 e0       	ldi	r31, 0x03	; 3
    171c:	22 96       	adiw	r28, 0x02	; 2
    171e:	ff af       	std	Y+63, r31	; 0x3f
    1720:	22 97       	sbiw	r28, 0x02	; 2
    1722:	21 96       	adiw	r28, 0x01	; 1
    1724:	ee ad       	ldd	r30, Y+62	; 0x3e
    1726:	ff ad       	ldd	r31, Y+63	; 0x3f
    1728:	21 97       	sbiw	r28, 0x01	; 1
    172a:	00 80       	ld	r0, Z
    172c:	21 96       	adiw	r28, 0x01	; 1
    172e:	8e ad       	ldd	r24, Y+62	; 0x3e
    1730:	9f ad       	ldd	r25, Y+63	; 0x3f
    1732:	21 97       	sbiw	r28, 0x01	; 1
    1734:	01 96       	adiw	r24, 0x01	; 1
    1736:	21 96       	adiw	r28, 0x01	; 1
    1738:	9f af       	std	Y+63, r25	; 0x3f
    173a:	8e af       	std	Y+62, r24	; 0x3e
    173c:	21 97       	sbiw	r28, 0x01	; 1
    173e:	ed ad       	ldd	r30, Y+61	; 0x3d
    1740:	fe ad       	ldd	r31, Y+62	; 0x3e
    1742:	00 82       	st	Z, r0
    1744:	8d ad       	ldd	r24, Y+61	; 0x3d
    1746:	9e ad       	ldd	r25, Y+62	; 0x3e
    1748:	01 96       	adiw	r24, 0x01	; 1
    174a:	9e af       	std	Y+62, r25	; 0x3e
    174c:	8d af       	std	Y+61, r24	; 0x3d
    174e:	22 96       	adiw	r28, 0x02	; 2
    1750:	9f ad       	ldd	r25, Y+63	; 0x3f
    1752:	22 97       	sbiw	r28, 0x02	; 2
    1754:	91 50       	subi	r25, 0x01	; 1
    1756:	22 96       	adiw	r28, 0x02	; 2
    1758:	9f af       	std	Y+63, r25	; 0x3f
    175a:	22 97       	sbiw	r28, 0x02	; 2
    175c:	22 96       	adiw	r28, 0x02	; 2
    175e:	ef ad       	ldd	r30, Y+63	; 0x3f
    1760:	22 97       	sbiw	r28, 0x02	; 2
    1762:	ee 23       	and	r30, r30
    1764:	f1 f6       	brne	.-68     	; 0x1722 <LCD_VidInit+0x118>
    1766:	11 c0       	rjmp	.+34     	; 0x178a <LCD_VidInit+0x180>
	while(i<3){
		DIO_VidSetPinDirection(CTRL_PORT,array[i],HIGH);
    1768:	89 ad       	ldd	r24, Y+57	; 0x39
    176a:	28 2f       	mov	r18, r24
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	ce 01       	movw	r24, r28
    1770:	ca 96       	adiw	r24, 0x3a	; 58
    1772:	fc 01       	movw	r30, r24
    1774:	e2 0f       	add	r30, r18
    1776:	f3 1f       	adc	r31, r19
    1778:	90 81       	ld	r25, Z
    177a:	83 e0       	ldi	r24, 0x03	; 3
    177c:	69 2f       	mov	r22, r25
    177e:	41 e0       	ldi	r20, 0x01	; 1
    1780:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_VidSetPinDirection>
	i++;	
    1784:	89 ad       	ldd	r24, Y+57	; 0x39
    1786:	8f 5f       	subi	r24, 0xFF	; 255
    1788:	89 af       	std	Y+57, r24	; 0x39
	*/
	void LCD_VidInit(void){
		_delay_ms(50);
	u8 i=0;	
	u8 array[]={RS_PIN,RW_PIN,ES_PIN};	
	while(i<3){
    178a:	89 ad       	ldd	r24, Y+57	; 0x39
    178c:	83 30       	cpi	r24, 0x03	; 3
    178e:	60 f3       	brcs	.-40     	; 0x1768 <LCD_VidInit+0x15e>
		DIO_VidSetPinDirection(CTRL_PORT,array[i],HIGH);
	i++;	
	}
	#if LCD_MODE==FULL	
		 DIO_VidSetPortDirection(DATA_PORT,255);
    1790:	82 e0       	ldi	r24, 0x02	; 2
    1792:	6f ef       	ldi	r22, 0xFF	; 255
    1794:	0e 94 8c 08 	call	0x1118	; 0x1118 <DIO_VidSetPortDirection>
		 LCD_VidWriteCommand(FUNCTION_SET);    //function set  //
    1798:	88 e3       	ldi	r24, 0x38	; 56
    179a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
    179e:	80 e0       	ldi	r24, 0x00	; 0
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	a0 e8       	ldi	r26, 0x80	; 128
    17a4:	bf e3       	ldi	r27, 0x3F	; 63
    17a6:	8f a3       	std	Y+39, r24	; 0x27
    17a8:	98 a7       	std	Y+40, r25	; 0x28
    17aa:	a9 a7       	std	Y+41, r26	; 0x29
    17ac:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17ae:	6f a1       	ldd	r22, Y+39	; 0x27
    17b0:	78 a5       	ldd	r23, Y+40	; 0x28
    17b2:	89 a5       	ldd	r24, Y+41	; 0x29
    17b4:	9a a5       	ldd	r25, Y+42	; 0x2a
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	4a ef       	ldi	r20, 0xFA	; 250
    17bc:	54 e4       	ldi	r21, 0x44	; 68
    17be:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17c2:	dc 01       	movw	r26, r24
    17c4:	cb 01       	movw	r24, r22
    17c6:	8b a3       	std	Y+35, r24	; 0x23
    17c8:	9c a3       	std	Y+36, r25	; 0x24
    17ca:	ad a3       	std	Y+37, r26	; 0x25
    17cc:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    17ce:	6b a1       	ldd	r22, Y+35	; 0x23
    17d0:	7c a1       	ldd	r23, Y+36	; 0x24
    17d2:	8d a1       	ldd	r24, Y+37	; 0x25
    17d4:	9e a1       	ldd	r25, Y+38	; 0x26
    17d6:	20 e0       	ldi	r18, 0x00	; 0
    17d8:	30 e0       	ldi	r19, 0x00	; 0
    17da:	40 e8       	ldi	r20, 0x80	; 128
    17dc:	5f e3       	ldi	r21, 0x3F	; 63
    17de:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17e2:	88 23       	and	r24, r24
    17e4:	2c f4       	brge	.+10     	; 0x17f0 <LCD_VidInit+0x1e6>
		__ticks = 1;
    17e6:	81 e0       	ldi	r24, 0x01	; 1
    17e8:	90 e0       	ldi	r25, 0x00	; 0
    17ea:	9a a3       	std	Y+34, r25	; 0x22
    17ec:	89 a3       	std	Y+33, r24	; 0x21
    17ee:	3f c0       	rjmp	.+126    	; 0x186e <LCD_VidInit+0x264>
	else if (__tmp > 65535)
    17f0:	6b a1       	ldd	r22, Y+35	; 0x23
    17f2:	7c a1       	ldd	r23, Y+36	; 0x24
    17f4:	8d a1       	ldd	r24, Y+37	; 0x25
    17f6:	9e a1       	ldd	r25, Y+38	; 0x26
    17f8:	20 e0       	ldi	r18, 0x00	; 0
    17fa:	3f ef       	ldi	r19, 0xFF	; 255
    17fc:	4f e7       	ldi	r20, 0x7F	; 127
    17fe:	57 e4       	ldi	r21, 0x47	; 71
    1800:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1804:	18 16       	cp	r1, r24
    1806:	4c f5       	brge	.+82     	; 0x185a <LCD_VidInit+0x250>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1808:	6f a1       	ldd	r22, Y+39	; 0x27
    180a:	78 a5       	ldd	r23, Y+40	; 0x28
    180c:	89 a5       	ldd	r24, Y+41	; 0x29
    180e:	9a a5       	ldd	r25, Y+42	; 0x2a
    1810:	20 e0       	ldi	r18, 0x00	; 0
    1812:	30 e0       	ldi	r19, 0x00	; 0
    1814:	40 e2       	ldi	r20, 0x20	; 32
    1816:	51 e4       	ldi	r21, 0x41	; 65
    1818:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    181c:	dc 01       	movw	r26, r24
    181e:	cb 01       	movw	r24, r22
    1820:	bc 01       	movw	r22, r24
    1822:	cd 01       	movw	r24, r26
    1824:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1828:	dc 01       	movw	r26, r24
    182a:	cb 01       	movw	r24, r22
    182c:	9a a3       	std	Y+34, r25	; 0x22
    182e:	89 a3       	std	Y+33, r24	; 0x21
    1830:	0f c0       	rjmp	.+30     	; 0x1850 <LCD_VidInit+0x246>
    1832:	88 ec       	ldi	r24, 0xC8	; 200
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	98 a3       	std	Y+32, r25	; 0x20
    1838:	8f 8f       	std	Y+31, r24	; 0x1f
    183a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    183c:	98 a1       	ldd	r25, Y+32	; 0x20
    183e:	01 97       	sbiw	r24, 0x01	; 1
    1840:	f1 f7       	brne	.-4      	; 0x183e <LCD_VidInit+0x234>
    1842:	98 a3       	std	Y+32, r25	; 0x20
    1844:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1846:	89 a1       	ldd	r24, Y+33	; 0x21
    1848:	9a a1       	ldd	r25, Y+34	; 0x22
    184a:	01 97       	sbiw	r24, 0x01	; 1
    184c:	9a a3       	std	Y+34, r25	; 0x22
    184e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1850:	89 a1       	ldd	r24, Y+33	; 0x21
    1852:	9a a1       	ldd	r25, Y+34	; 0x22
    1854:	00 97       	sbiw	r24, 0x00	; 0
    1856:	69 f7       	brne	.-38     	; 0x1832 <LCD_VidInit+0x228>
    1858:	14 c0       	rjmp	.+40     	; 0x1882 <LCD_VidInit+0x278>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    185a:	6b a1       	ldd	r22, Y+35	; 0x23
    185c:	7c a1       	ldd	r23, Y+36	; 0x24
    185e:	8d a1       	ldd	r24, Y+37	; 0x25
    1860:	9e a1       	ldd	r25, Y+38	; 0x26
    1862:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1866:	dc 01       	movw	r26, r24
    1868:	cb 01       	movw	r24, r22
    186a:	9a a3       	std	Y+34, r25	; 0x22
    186c:	89 a3       	std	Y+33, r24	; 0x21
    186e:	89 a1       	ldd	r24, Y+33	; 0x21
    1870:	9a a1       	ldd	r25, Y+34	; 0x22
    1872:	9e 8f       	std	Y+30, r25	; 0x1e
    1874:	8d 8f       	std	Y+29, r24	; 0x1d
    1876:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1878:	9e 8d       	ldd	r25, Y+30	; 0x1e
    187a:	01 97       	sbiw	r24, 0x01	; 1
    187c:	f1 f7       	brne	.-4      	; 0x187a <LCD_VidInit+0x270>
    187e:	9e 8f       	std	Y+30, r25	; 0x1e
    1880:	8d 8f       	std	Y+29, r24	; 0x1d
		 _delay_ms(1);
		 LCD_VidWriteCommand(DISPLAY_ON);    //display on    //
    1882:	8c e0       	ldi	r24, 0x0C	; 12
    1884:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
    1888:	80 e0       	ldi	r24, 0x00	; 0
    188a:	90 e0       	ldi	r25, 0x00	; 0
    188c:	a0 e8       	ldi	r26, 0x80	; 128
    188e:	bf e3       	ldi	r27, 0x3F	; 63
    1890:	89 8f       	std	Y+25, r24	; 0x19
    1892:	9a 8f       	std	Y+26, r25	; 0x1a
    1894:	ab 8f       	std	Y+27, r26	; 0x1b
    1896:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1898:	69 8d       	ldd	r22, Y+25	; 0x19
    189a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    189c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    189e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18a0:	20 e0       	ldi	r18, 0x00	; 0
    18a2:	30 e0       	ldi	r19, 0x00	; 0
    18a4:	4a ef       	ldi	r20, 0xFA	; 250
    18a6:	54 e4       	ldi	r21, 0x44	; 68
    18a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18ac:	dc 01       	movw	r26, r24
    18ae:	cb 01       	movw	r24, r22
    18b0:	8d 8b       	std	Y+21, r24	; 0x15
    18b2:	9e 8b       	std	Y+22, r25	; 0x16
    18b4:	af 8b       	std	Y+23, r26	; 0x17
    18b6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    18b8:	6d 89       	ldd	r22, Y+21	; 0x15
    18ba:	7e 89       	ldd	r23, Y+22	; 0x16
    18bc:	8f 89       	ldd	r24, Y+23	; 0x17
    18be:	98 8d       	ldd	r25, Y+24	; 0x18
    18c0:	20 e0       	ldi	r18, 0x00	; 0
    18c2:	30 e0       	ldi	r19, 0x00	; 0
    18c4:	40 e8       	ldi	r20, 0x80	; 128
    18c6:	5f e3       	ldi	r21, 0x3F	; 63
    18c8:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    18cc:	88 23       	and	r24, r24
    18ce:	2c f4       	brge	.+10     	; 0x18da <LCD_VidInit+0x2d0>
		__ticks = 1;
    18d0:	81 e0       	ldi	r24, 0x01	; 1
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	9c 8b       	std	Y+20, r25	; 0x14
    18d6:	8b 8b       	std	Y+19, r24	; 0x13
    18d8:	3f c0       	rjmp	.+126    	; 0x1958 <LCD_VidInit+0x34e>
	else if (__tmp > 65535)
    18da:	6d 89       	ldd	r22, Y+21	; 0x15
    18dc:	7e 89       	ldd	r23, Y+22	; 0x16
    18de:	8f 89       	ldd	r24, Y+23	; 0x17
    18e0:	98 8d       	ldd	r25, Y+24	; 0x18
    18e2:	20 e0       	ldi	r18, 0x00	; 0
    18e4:	3f ef       	ldi	r19, 0xFF	; 255
    18e6:	4f e7       	ldi	r20, 0x7F	; 127
    18e8:	57 e4       	ldi	r21, 0x47	; 71
    18ea:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    18ee:	18 16       	cp	r1, r24
    18f0:	4c f5       	brge	.+82     	; 0x1944 <LCD_VidInit+0x33a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    18f2:	69 8d       	ldd	r22, Y+25	; 0x19
    18f4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    18f6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18f8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    18fa:	20 e0       	ldi	r18, 0x00	; 0
    18fc:	30 e0       	ldi	r19, 0x00	; 0
    18fe:	40 e2       	ldi	r20, 0x20	; 32
    1900:	51 e4       	ldi	r21, 0x41	; 65
    1902:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1906:	dc 01       	movw	r26, r24
    1908:	cb 01       	movw	r24, r22
    190a:	bc 01       	movw	r22, r24
    190c:	cd 01       	movw	r24, r26
    190e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1912:	dc 01       	movw	r26, r24
    1914:	cb 01       	movw	r24, r22
    1916:	9c 8b       	std	Y+20, r25	; 0x14
    1918:	8b 8b       	std	Y+19, r24	; 0x13
    191a:	0f c0       	rjmp	.+30     	; 0x193a <LCD_VidInit+0x330>
    191c:	88 ec       	ldi	r24, 0xC8	; 200
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	9a 8b       	std	Y+18, r25	; 0x12
    1922:	89 8b       	std	Y+17, r24	; 0x11
    1924:	89 89       	ldd	r24, Y+17	; 0x11
    1926:	9a 89       	ldd	r25, Y+18	; 0x12
    1928:	01 97       	sbiw	r24, 0x01	; 1
    192a:	f1 f7       	brne	.-4      	; 0x1928 <LCD_VidInit+0x31e>
    192c:	9a 8b       	std	Y+18, r25	; 0x12
    192e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1930:	8b 89       	ldd	r24, Y+19	; 0x13
    1932:	9c 89       	ldd	r25, Y+20	; 0x14
    1934:	01 97       	sbiw	r24, 0x01	; 1
    1936:	9c 8b       	std	Y+20, r25	; 0x14
    1938:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    193a:	8b 89       	ldd	r24, Y+19	; 0x13
    193c:	9c 89       	ldd	r25, Y+20	; 0x14
    193e:	00 97       	sbiw	r24, 0x00	; 0
    1940:	69 f7       	brne	.-38     	; 0x191c <LCD_VidInit+0x312>
    1942:	14 c0       	rjmp	.+40     	; 0x196c <LCD_VidInit+0x362>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1944:	6d 89       	ldd	r22, Y+21	; 0x15
    1946:	7e 89       	ldd	r23, Y+22	; 0x16
    1948:	8f 89       	ldd	r24, Y+23	; 0x17
    194a:	98 8d       	ldd	r25, Y+24	; 0x18
    194c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1950:	dc 01       	movw	r26, r24
    1952:	cb 01       	movw	r24, r22
    1954:	9c 8b       	std	Y+20, r25	; 0x14
    1956:	8b 8b       	std	Y+19, r24	; 0x13
    1958:	8b 89       	ldd	r24, Y+19	; 0x13
    195a:	9c 89       	ldd	r25, Y+20	; 0x14
    195c:	98 8b       	std	Y+16, r25	; 0x10
    195e:	8f 87       	std	Y+15, r24	; 0x0f
    1960:	8f 85       	ldd	r24, Y+15	; 0x0f
    1962:	98 89       	ldd	r25, Y+16	; 0x10
    1964:	01 97       	sbiw	r24, 0x01	; 1
    1966:	f1 f7       	brne	.-4      	; 0x1964 <LCD_VidInit+0x35a>
    1968:	98 8b       	std	Y+16, r25	; 0x10
    196a:	8f 87       	std	Y+15, r24	; 0x0f
		 _delay_ms(1);
		 LCD_VidWriteCommand(CLR );        //clear display //
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
    1972:	80 e0       	ldi	r24, 0x00	; 0
    1974:	90 e0       	ldi	r25, 0x00	; 0
    1976:	a0 e0       	ldi	r26, 0x00	; 0
    1978:	b0 e4       	ldi	r27, 0x40	; 64
    197a:	8b 87       	std	Y+11, r24	; 0x0b
    197c:	9c 87       	std	Y+12, r25	; 0x0c
    197e:	ad 87       	std	Y+13, r26	; 0x0d
    1980:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1982:	6b 85       	ldd	r22, Y+11	; 0x0b
    1984:	7c 85       	ldd	r23, Y+12	; 0x0c
    1986:	8d 85       	ldd	r24, Y+13	; 0x0d
    1988:	9e 85       	ldd	r25, Y+14	; 0x0e
    198a:	20 e0       	ldi	r18, 0x00	; 0
    198c:	30 e0       	ldi	r19, 0x00	; 0
    198e:	4a ef       	ldi	r20, 0xFA	; 250
    1990:	54 e4       	ldi	r21, 0x44	; 68
    1992:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1996:	dc 01       	movw	r26, r24
    1998:	cb 01       	movw	r24, r22
    199a:	8f 83       	std	Y+7, r24	; 0x07
    199c:	98 87       	std	Y+8, r25	; 0x08
    199e:	a9 87       	std	Y+9, r26	; 0x09
    19a0:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    19a2:	6f 81       	ldd	r22, Y+7	; 0x07
    19a4:	78 85       	ldd	r23, Y+8	; 0x08
    19a6:	89 85       	ldd	r24, Y+9	; 0x09
    19a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    19aa:	20 e0       	ldi	r18, 0x00	; 0
    19ac:	30 e0       	ldi	r19, 0x00	; 0
    19ae:	40 e8       	ldi	r20, 0x80	; 128
    19b0:	5f e3       	ldi	r21, 0x3F	; 63
    19b2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    19b6:	88 23       	and	r24, r24
    19b8:	2c f4       	brge	.+10     	; 0x19c4 <LCD_VidInit+0x3ba>
		__ticks = 1;
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	9e 83       	std	Y+6, r25	; 0x06
    19c0:	8d 83       	std	Y+5, r24	; 0x05
    19c2:	3f c0       	rjmp	.+126    	; 0x1a42 <LCD_VidInit+0x438>
	else if (__tmp > 65535)
    19c4:	6f 81       	ldd	r22, Y+7	; 0x07
    19c6:	78 85       	ldd	r23, Y+8	; 0x08
    19c8:	89 85       	ldd	r24, Y+9	; 0x09
    19ca:	9a 85       	ldd	r25, Y+10	; 0x0a
    19cc:	20 e0       	ldi	r18, 0x00	; 0
    19ce:	3f ef       	ldi	r19, 0xFF	; 255
    19d0:	4f e7       	ldi	r20, 0x7F	; 127
    19d2:	57 e4       	ldi	r21, 0x47	; 71
    19d4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    19d8:	18 16       	cp	r1, r24
    19da:	4c f5       	brge	.+82     	; 0x1a2e <LCD_VidInit+0x424>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19dc:	6b 85       	ldd	r22, Y+11	; 0x0b
    19de:	7c 85       	ldd	r23, Y+12	; 0x0c
    19e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    19e2:	9e 85       	ldd	r25, Y+14	; 0x0e
    19e4:	20 e0       	ldi	r18, 0x00	; 0
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	40 e2       	ldi	r20, 0x20	; 32
    19ea:	51 e4       	ldi	r21, 0x41	; 65
    19ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19f0:	dc 01       	movw	r26, r24
    19f2:	cb 01       	movw	r24, r22
    19f4:	bc 01       	movw	r22, r24
    19f6:	cd 01       	movw	r24, r26
    19f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19fc:	dc 01       	movw	r26, r24
    19fe:	cb 01       	movw	r24, r22
    1a00:	9e 83       	std	Y+6, r25	; 0x06
    1a02:	8d 83       	std	Y+5, r24	; 0x05
    1a04:	0f c0       	rjmp	.+30     	; 0x1a24 <LCD_VidInit+0x41a>
    1a06:	88 ec       	ldi	r24, 0xC8	; 200
    1a08:	90 e0       	ldi	r25, 0x00	; 0
    1a0a:	9c 83       	std	Y+4, r25	; 0x04
    1a0c:	8b 83       	std	Y+3, r24	; 0x03
    1a0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a10:	9c 81       	ldd	r25, Y+4	; 0x04
    1a12:	01 97       	sbiw	r24, 0x01	; 1
    1a14:	f1 f7       	brne	.-4      	; 0x1a12 <LCD_VidInit+0x408>
    1a16:	9c 83       	std	Y+4, r25	; 0x04
    1a18:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1a1a:	8d 81       	ldd	r24, Y+5	; 0x05
    1a1c:	9e 81       	ldd	r25, Y+6	; 0x06
    1a1e:	01 97       	sbiw	r24, 0x01	; 1
    1a20:	9e 83       	std	Y+6, r25	; 0x06
    1a22:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a24:	8d 81       	ldd	r24, Y+5	; 0x05
    1a26:	9e 81       	ldd	r25, Y+6	; 0x06
    1a28:	00 97       	sbiw	r24, 0x00	; 0
    1a2a:	69 f7       	brne	.-38     	; 0x1a06 <LCD_VidInit+0x3fc>
    1a2c:	14 c0       	rjmp	.+40     	; 0x1a56 <LCD_VidInit+0x44c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a2e:	6f 81       	ldd	r22, Y+7	; 0x07
    1a30:	78 85       	ldd	r23, Y+8	; 0x08
    1a32:	89 85       	ldd	r24, Y+9	; 0x09
    1a34:	9a 85       	ldd	r25, Y+10	; 0x0a
    1a36:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a3a:	dc 01       	movw	r26, r24
    1a3c:	cb 01       	movw	r24, r22
    1a3e:	9e 83       	std	Y+6, r25	; 0x06
    1a40:	8d 83       	std	Y+5, r24	; 0x05
    1a42:	8d 81       	ldd	r24, Y+5	; 0x05
    1a44:	9e 81       	ldd	r25, Y+6	; 0x06
    1a46:	9a 83       	std	Y+2, r25	; 0x02
    1a48:	89 83       	std	Y+1, r24	; 0x01
    1a4a:	89 81       	ldd	r24, Y+1	; 0x01
    1a4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a4e:	01 97       	sbiw	r24, 0x01	; 1
    1a50:	f1 f7       	brne	.-4      	; 0x1a4e <LCD_VidInit+0x444>
    1a52:	9a 83       	std	Y+2, r25	; 0x02
    1a54:	89 83       	std	Y+1, r24	; 0x01
		 
		 
		 
	#endif	 
		 
	}
    1a56:	cf 5b       	subi	r28, 0xBF	; 191
    1a58:	df 4f       	sbci	r29, 0xFF	; 255
    1a5a:	0f b6       	in	r0, 0x3f	; 63
    1a5c:	f8 94       	cli
    1a5e:	de bf       	out	0x3e, r29	; 62
    1a60:	0f be       	out	0x3f, r0	; 63
    1a62:	cd bf       	out	0x3d, r28	; 61
    1a64:	cf 91       	pop	r28
    1a66:	df 91       	pop	r29
    1a68:	08 95       	ret

00001a6a <LCD_VidWriteCommand>:
	/*

	loc_u8DataPort=the port that connected from D0 to D7
	loc_u8ControlPort=the port that connected to RS&RW&EN
	*/
	void LCD_VidWriteCommand(u8 loc_u8command){
    1a6a:	df 93       	push	r29
    1a6c:	cf 93       	push	r28
    1a6e:	0f 92       	push	r0
    1a70:	cd b7       	in	r28, 0x3d	; 61
    1a72:	de b7       	in	r29, 0x3e	; 62
    1a74:	89 83       	std	Y+1, r24	; 0x01

	#if LCD_MODE==FULL	
	DIO_VidSetPinValue(CTRL_PORT,RS_PIN,LOW); //make the RS in command mode//
    1a76:	83 e0       	ldi	r24, 0x03	; 3
    1a78:	60 e0       	ldi	r22, 0x00	; 0
    1a7a:	40 e0       	ldi	r20, 0x00	; 0
    1a7c:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
	DIO_VidSetPinValue(CTRL_PORT,RW_PIN,LOW);//make the RW in write mode//
    1a80:	83 e0       	ldi	r24, 0x03	; 3
    1a82:	61 e0       	ldi	r22, 0x01	; 1
    1a84:	40 e0       	ldi	r20, 0x00	; 0
    1a86:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
	DIO_VidSetPortValue(DATA_PORT,loc_u8command);//take the data from D0 to D7//
    1a8a:	82 e0       	ldi	r24, 0x02	; 2
    1a8c:	69 81       	ldd	r22, Y+1	; 0x01
    1a8e:	0e 94 cd 08 	call	0x119a	; 0x119a <DIO_VidSetPortValue>
	LCD_VidEnable();
    1a92:	0e 94 04 0a 	call	0x1408	; 0x1408 <LCD_VidEnable>

	DIO_VidSetPortValue(DATA_PORT,loc_u8command<<4);//take the data from D4 to D7//
	LCD_VidEnable();
	#endif		
			
	}
    1a96:	0f 90       	pop	r0
    1a98:	cf 91       	pop	r28
    1a9a:	df 91       	pop	r29
    1a9c:	08 95       	ret

00001a9e <LCD_VidWriteData>:
	void LCD_VidWriteData(u8 loc_u8data){
    1a9e:	df 93       	push	r29
    1aa0:	cf 93       	push	r28
    1aa2:	0f 92       	push	r0
    1aa4:	cd b7       	in	r28, 0x3d	; 61
    1aa6:	de b7       	in	r29, 0x3e	; 62
    1aa8:	89 83       	std	Y+1, r24	; 0x01
		
	#if LCD_MODE==FULL		
		DIO_VidSetPinValue(CTRL_PORT,RS_PIN,HIGH); //make the RS in data mode//
    1aaa:	83 e0       	ldi	r24, 0x03	; 3
    1aac:	60 e0       	ldi	r22, 0x00	; 0
    1aae:	41 e0       	ldi	r20, 0x01	; 1
    1ab0:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
		DIO_VidSetPinValue(CTRL_PORT,RW_PIN,LOW);//make the RW in write mode//
    1ab4:	83 e0       	ldi	r24, 0x03	; 3
    1ab6:	61 e0       	ldi	r22, 0x01	; 1
    1ab8:	40 e0       	ldi	r20, 0x00	; 0
    1aba:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
		DIO_VidSetPortValue(DATA_PORT,loc_u8data);//take the data from D0 to D7//
    1abe:	82 e0       	ldi	r24, 0x02	; 2
    1ac0:	69 81       	ldd	r22, Y+1	; 0x01
    1ac2:	0e 94 cd 08 	call	0x119a	; 0x119a <DIO_VidSetPortValue>
		LCD_VidEnable();
    1ac6:	0e 94 04 0a 	call	0x1408	; 0x1408 <LCD_VidEnable>
		LCD_VidEnable();	
		DIO_VidSetPortValue(DATA_PORT,loc_u8data<<4);//take the data from D4 to D7//
		LCD_VidEnable();		
	#endif	
		
	}
    1aca:	0f 90       	pop	r0
    1acc:	cf 91       	pop	r28
    1ace:	df 91       	pop	r29
    1ad0:	08 95       	ret

00001ad2 <LCD_VidWriteString>:
	void LCD_VidWriteString(char* loc_u8string){
    1ad2:	df 93       	push	r29
    1ad4:	cf 93       	push	r28
    1ad6:	00 d0       	rcall	.+0      	; 0x1ad8 <LCD_VidWriteString+0x6>
    1ad8:	0f 92       	push	r0
    1ada:	cd b7       	in	r28, 0x3d	; 61
    1adc:	de b7       	in	r29, 0x3e	; 62
    1ade:	9b 83       	std	Y+3, r25	; 0x03
    1ae0:	8a 83       	std	Y+2, r24	; 0x02
		u8 i=0;
    1ae2:	19 82       	std	Y+1, r1	; 0x01
		for(i=0; loc_u8string[i]!=NULL;i++){
    1ae4:	19 82       	std	Y+1, r1	; 0x01
    1ae6:	0e c0       	rjmp	.+28     	; 0x1b04 <LCD_VidWriteString+0x32>
		LCD_VidWriteData(loc_u8string[i]);
    1ae8:	89 81       	ldd	r24, Y+1	; 0x01
    1aea:	28 2f       	mov	r18, r24
    1aec:	30 e0       	ldi	r19, 0x00	; 0
    1aee:	8a 81       	ldd	r24, Y+2	; 0x02
    1af0:	9b 81       	ldd	r25, Y+3	; 0x03
    1af2:	fc 01       	movw	r30, r24
    1af4:	e2 0f       	add	r30, r18
    1af6:	f3 1f       	adc	r31, r19
    1af8:	80 81       	ld	r24, Z
    1afa:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_VidWriteData>
	#endif	
		
	}
	void LCD_VidWriteString(char* loc_u8string){
		u8 i=0;
		for(i=0; loc_u8string[i]!=NULL;i++){
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	8f 5f       	subi	r24, 0xFF	; 255
    1b02:	89 83       	std	Y+1, r24	; 0x01
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	28 2f       	mov	r18, r24
    1b08:	30 e0       	ldi	r19, 0x00	; 0
    1b0a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b0c:	9b 81       	ldd	r25, Y+3	; 0x03
    1b0e:	fc 01       	movw	r30, r24
    1b10:	e2 0f       	add	r30, r18
    1b12:	f3 1f       	adc	r31, r19
    1b14:	80 81       	ld	r24, Z
    1b16:	88 23       	and	r24, r24
    1b18:	39 f7       	brne	.-50     	; 0x1ae8 <LCD_VidWriteString+0x16>
		LCD_VidWriteData(loc_u8string[i]);
		}
		
	}
    1b1a:	0f 90       	pop	r0
    1b1c:	0f 90       	pop	r0
    1b1e:	0f 90       	pop	r0
    1b20:	cf 91       	pop	r28
    1b22:	df 91       	pop	r29
    1b24:	08 95       	ret

00001b26 <LCD_VidWriteNumber>:
	void LCD_VidWriteNumber(s32 loc_s32number){
    1b26:	ef 92       	push	r14
    1b28:	ff 92       	push	r15
    1b2a:	0f 93       	push	r16
    1b2c:	1f 93       	push	r17
    1b2e:	df 93       	push	r29
    1b30:	cf 93       	push	r28
    1b32:	cd b7       	in	r28, 0x3d	; 61
    1b34:	de b7       	in	r29, 0x3e	; 62
    1b36:	61 97       	sbiw	r28, 0x11	; 17
    1b38:	0f b6       	in	r0, 0x3f	; 63
    1b3a:	f8 94       	cli
    1b3c:	de bf       	out	0x3e, r29	; 62
    1b3e:	0f be       	out	0x3f, r0	; 63
    1b40:	cd bf       	out	0x3d, r28	; 61
    1b42:	6e 87       	std	Y+14, r22	; 0x0e
    1b44:	7f 87       	std	Y+15, r23	; 0x0f
    1b46:	88 8b       	std	Y+16, r24	; 0x10
    1b48:	99 8b       	std	Y+17, r25	; 0x11
// NEGATIVE AND POSTIVE VALUES//

	 s32 x=loc_s32number;
    1b4a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b4c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b4e:	a8 89       	ldd	r26, Y+16	; 0x10
    1b50:	b9 89       	ldd	r27, Y+17	; 0x11
    1b52:	8a 87       	std	Y+10, r24	; 0x0a
    1b54:	9b 87       	std	Y+11, r25	; 0x0b
    1b56:	ac 87       	std	Y+12, r26	; 0x0c
    1b58:	bd 87       	std	Y+13, r27	; 0x0d
	 s32 y=0;
    1b5a:	1e 82       	std	Y+6, r1	; 0x06
    1b5c:	1f 82       	std	Y+7, r1	; 0x07
    1b5e:	18 86       	std	Y+8, r1	; 0x08
    1b60:	19 86       	std	Y+9, r1	; 0x09
	 s32 reversed=1;
    1b62:	81 e0       	ldi	r24, 0x01	; 1
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	a0 e0       	ldi	r26, 0x00	; 0
    1b68:	b0 e0       	ldi	r27, 0x00	; 0
    1b6a:	8a 83       	std	Y+2, r24	; 0x02
    1b6c:	9b 83       	std	Y+3, r25	; 0x03
    1b6e:	ac 83       	std	Y+4, r26	; 0x04
    1b70:	bd 83       	std	Y+5, r27	; 0x05
	 u8 negtive_flag=0;
    1b72:	19 82       	std	Y+1, r1	; 0x01
		 if(loc_s32number<0){
    1b74:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b76:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b78:	a8 89       	ldd	r26, Y+16	; 0x10
    1b7a:	b9 89       	ldd	r27, Y+17	; 0x11
    1b7c:	bb 23       	and	r27, r27
    1b7e:	94 f4       	brge	.+36     	; 0x1ba4 <LCD_VidWriteNumber+0x7e>
					 x=(loc_s32number*-1);
    1b80:	8e 85       	ldd	r24, Y+14	; 0x0e
    1b82:	9f 85       	ldd	r25, Y+15	; 0x0f
    1b84:	a8 89       	ldd	r26, Y+16	; 0x10
    1b86:	b9 89       	ldd	r27, Y+17	; 0x11
    1b88:	b0 95       	com	r27
    1b8a:	a0 95       	com	r26
    1b8c:	90 95       	com	r25
    1b8e:	81 95       	neg	r24
    1b90:	9f 4f       	sbci	r25, 0xFF	; 255
    1b92:	af 4f       	sbci	r26, 0xFF	; 255
    1b94:	bf 4f       	sbci	r27, 0xFF	; 255
    1b96:	8a 87       	std	Y+10, r24	; 0x0a
    1b98:	9b 87       	std	Y+11, r25	; 0x0b
    1b9a:	ac 87       	std	Y+12, r26	; 0x0c
    1b9c:	bd 87       	std	Y+13, r27	; 0x0d
					 negtive_flag=1;
    1b9e:	81 e0       	ldi	r24, 0x01	; 1
    1ba0:	89 83       	std	Y+1, r24	; 0x01
    1ba2:	42 c0       	rjmp	.+132    	; 0x1c28 <LCD_VidWriteNumber+0x102>
			 }

		 else if(x==0){
    1ba4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ba6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ba8:	ac 85       	ldd	r26, Y+12	; 0x0c
    1baa:	bd 85       	ldd	r27, Y+13	; 0x0d
    1bac:	00 97       	sbiw	r24, 0x00	; 0
    1bae:	a1 05       	cpc	r26, r1
    1bb0:	b1 05       	cpc	r27, r1
    1bb2:	d1 f5       	brne	.+116    	; 0x1c28 <LCD_VidWriteNumber+0x102>
					 LCD_VidWriteData(48);
    1bb4:	80 e3       	ldi	r24, 0x30	; 48
    1bb6:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_VidWriteData>
    1bba:	36 c0       	rjmp	.+108    	; 0x1c28 <LCD_VidWriteNumber+0x102>
				}
		 while(x>0){
					 reversed=(reversed*10)+(x%10);
    1bbc:	8a 81       	ldd	r24, Y+2	; 0x02
    1bbe:	9b 81       	ldd	r25, Y+3	; 0x03
    1bc0:	ac 81       	ldd	r26, Y+4	; 0x04
    1bc2:	bd 81       	ldd	r27, Y+5	; 0x05
    1bc4:	2a e0       	ldi	r18, 0x0A	; 10
    1bc6:	30 e0       	ldi	r19, 0x00	; 0
    1bc8:	40 e0       	ldi	r20, 0x00	; 0
    1bca:	50 e0       	ldi	r21, 0x00	; 0
    1bcc:	bc 01       	movw	r22, r24
    1bce:	cd 01       	movw	r24, r26
    1bd0:	0e 94 54 22 	call	0x44a8	; 0x44a8 <__mulsi3>
    1bd4:	7b 01       	movw	r14, r22
    1bd6:	8c 01       	movw	r16, r24
    1bd8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bda:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bdc:	ac 85       	ldd	r26, Y+12	; 0x0c
    1bde:	bd 85       	ldd	r27, Y+13	; 0x0d
    1be0:	2a e0       	ldi	r18, 0x0A	; 10
    1be2:	30 e0       	ldi	r19, 0x00	; 0
    1be4:	40 e0       	ldi	r20, 0x00	; 0
    1be6:	50 e0       	ldi	r21, 0x00	; 0
    1be8:	bc 01       	movw	r22, r24
    1bea:	cd 01       	movw	r24, r26
    1bec:	0e 94 a9 22 	call	0x4552	; 0x4552 <__divmodsi4>
    1bf0:	dc 01       	movw	r26, r24
    1bf2:	cb 01       	movw	r24, r22
    1bf4:	8e 0d       	add	r24, r14
    1bf6:	9f 1d       	adc	r25, r15
    1bf8:	a0 1f       	adc	r26, r16
    1bfa:	b1 1f       	adc	r27, r17
    1bfc:	8a 83       	std	Y+2, r24	; 0x02
    1bfe:	9b 83       	std	Y+3, r25	; 0x03
    1c00:	ac 83       	std	Y+4, r26	; 0x04
    1c02:	bd 83       	std	Y+5, r27	; 0x05
					   x=x/10;
    1c04:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c06:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c08:	ac 85       	ldd	r26, Y+12	; 0x0c
    1c0a:	bd 85       	ldd	r27, Y+13	; 0x0d
    1c0c:	2a e0       	ldi	r18, 0x0A	; 10
    1c0e:	30 e0       	ldi	r19, 0x00	; 0
    1c10:	40 e0       	ldi	r20, 0x00	; 0
    1c12:	50 e0       	ldi	r21, 0x00	; 0
    1c14:	bc 01       	movw	r22, r24
    1c16:	cd 01       	movw	r24, r26
    1c18:	0e 94 a9 22 	call	0x4552	; 0x4552 <__divmodsi4>
    1c1c:	da 01       	movw	r26, r20
    1c1e:	c9 01       	movw	r24, r18
    1c20:	8a 87       	std	Y+10, r24	; 0x0a
    1c22:	9b 87       	std	Y+11, r25	; 0x0b
    1c24:	ac 87       	std	Y+12, r26	; 0x0c
    1c26:	bd 87       	std	Y+13, r27	; 0x0d
			 }

		 else if(x==0){
					 LCD_VidWriteData(48);
				}
		 while(x>0){
    1c28:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c2a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c2c:	ac 85       	ldd	r26, Y+12	; 0x0c
    1c2e:	bd 85       	ldd	r27, Y+13	; 0x0d
    1c30:	18 16       	cp	r1, r24
    1c32:	19 06       	cpc	r1, r25
    1c34:	1a 06       	cpc	r1, r26
    1c36:	1b 06       	cpc	r1, r27
    1c38:	0c f2       	brlt	.-126    	; 0x1bbc <LCD_VidWriteNumber+0x96>
					 reversed=(reversed*10)+(x%10);
					   x=x/10;
				   }
		 if(loc_s32number<0){
    1c3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c3c:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c3e:	a8 89       	ldd	r26, Y+16	; 0x10
    1c40:	b9 89       	ldd	r27, Y+17	; 0x11
    1c42:	bb 23       	and	r27, r27
    1c44:	84 f4       	brge	.+32     	; 0x1c66 <LCD_VidWriteNumber+0x140>
					 x=(loc_s32number*-1);
    1c46:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c48:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c4a:	a8 89       	ldd	r26, Y+16	; 0x10
    1c4c:	b9 89       	ldd	r27, Y+17	; 0x11
    1c4e:	b0 95       	com	r27
    1c50:	a0 95       	com	r26
    1c52:	90 95       	com	r25
    1c54:	81 95       	neg	r24
    1c56:	9f 4f       	sbci	r25, 0xFF	; 255
    1c58:	af 4f       	sbci	r26, 0xFF	; 255
    1c5a:	bf 4f       	sbci	r27, 0xFF	; 255
    1c5c:	8a 87       	std	Y+10, r24	; 0x0a
    1c5e:	9b 87       	std	Y+11, r25	; 0x0b
    1c60:	ac 87       	std	Y+12, r26	; 0x0c
    1c62:	bd 87       	std	Y+13, r27	; 0x0d
    1c64:	4a c0       	rjmp	.+148    	; 0x1cfa <LCD_VidWriteNumber+0x1d4>
		 }
		 else{
					x=loc_s32number;
    1c66:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c68:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c6a:	a8 89       	ldd	r26, Y+16	; 0x10
    1c6c:	b9 89       	ldd	r27, Y+17	; 0x11
    1c6e:	8a 87       	std	Y+10, r24	; 0x0a
    1c70:	9b 87       	std	Y+11, r25	; 0x0b
    1c72:	ac 87       	std	Y+12, r26	; 0x0c
    1c74:	bd 87       	std	Y+13, r27	; 0x0d
    1c76:	41 c0       	rjmp	.+130    	; 0x1cfa <LCD_VidWriteNumber+0x1d4>
			 }
		 while(x>0){
					y=reversed%10;
    1c78:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c7c:	ac 81       	ldd	r26, Y+4	; 0x04
    1c7e:	bd 81       	ldd	r27, Y+5	; 0x05
    1c80:	2a e0       	ldi	r18, 0x0A	; 10
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	40 e0       	ldi	r20, 0x00	; 0
    1c86:	50 e0       	ldi	r21, 0x00	; 0
    1c88:	bc 01       	movw	r22, r24
    1c8a:	cd 01       	movw	r24, r26
    1c8c:	0e 94 a9 22 	call	0x4552	; 0x4552 <__divmodsi4>
    1c90:	dc 01       	movw	r26, r24
    1c92:	cb 01       	movw	r24, r22
    1c94:	8e 83       	std	Y+6, r24	; 0x06
    1c96:	9f 83       	std	Y+7, r25	; 0x07
    1c98:	a8 87       	std	Y+8, r26	; 0x08
    1c9a:	b9 87       	std	Y+9, r27	; 0x09
					if(negtive_flag==1){
    1c9c:	89 81       	ldd	r24, Y+1	; 0x01
    1c9e:	81 30       	cpi	r24, 0x01	; 1
    1ca0:	21 f4       	brne	.+8      	; 0x1caa <LCD_VidWriteNumber+0x184>
					 LCD_VidWriteData('-');
    1ca2:	8d e2       	ldi	r24, 0x2D	; 45
    1ca4:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_VidWriteData>
					  negtive_flag=0;
    1ca8:	19 82       	std	Y+1, r1	; 0x01
									}
					LCD_VidWriteData(y+48);
    1caa:	8e 81       	ldd	r24, Y+6	; 0x06
    1cac:	80 5d       	subi	r24, 0xD0	; 208
    1cae:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <LCD_VidWriteData>
					reversed=reversed/10;
    1cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cb4:	9b 81       	ldd	r25, Y+3	; 0x03
    1cb6:	ac 81       	ldd	r26, Y+4	; 0x04
    1cb8:	bd 81       	ldd	r27, Y+5	; 0x05
    1cba:	2a e0       	ldi	r18, 0x0A	; 10
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	40 e0       	ldi	r20, 0x00	; 0
    1cc0:	50 e0       	ldi	r21, 0x00	; 0
    1cc2:	bc 01       	movw	r22, r24
    1cc4:	cd 01       	movw	r24, r26
    1cc6:	0e 94 a9 22 	call	0x4552	; 0x4552 <__divmodsi4>
    1cca:	da 01       	movw	r26, r20
    1ccc:	c9 01       	movw	r24, r18
    1cce:	8a 83       	std	Y+2, r24	; 0x02
    1cd0:	9b 83       	std	Y+3, r25	; 0x03
    1cd2:	ac 83       	std	Y+4, r26	; 0x04
    1cd4:	bd 83       	std	Y+5, r27	; 0x05
					x=x/10;
    1cd6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cd8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cda:	ac 85       	ldd	r26, Y+12	; 0x0c
    1cdc:	bd 85       	ldd	r27, Y+13	; 0x0d
    1cde:	2a e0       	ldi	r18, 0x0A	; 10
    1ce0:	30 e0       	ldi	r19, 0x00	; 0
    1ce2:	40 e0       	ldi	r20, 0x00	; 0
    1ce4:	50 e0       	ldi	r21, 0x00	; 0
    1ce6:	bc 01       	movw	r22, r24
    1ce8:	cd 01       	movw	r24, r26
    1cea:	0e 94 a9 22 	call	0x4552	; 0x4552 <__divmodsi4>
    1cee:	da 01       	movw	r26, r20
    1cf0:	c9 01       	movw	r24, r18
    1cf2:	8a 87       	std	Y+10, r24	; 0x0a
    1cf4:	9b 87       	std	Y+11, r25	; 0x0b
    1cf6:	ac 87       	std	Y+12, r26	; 0x0c
    1cf8:	bd 87       	std	Y+13, r27	; 0x0d
					 x=(loc_s32number*-1);
		 }
		 else{
					x=loc_s32number;
			 }
		 while(x>0){
    1cfa:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cfc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cfe:	ac 85       	ldd	r26, Y+12	; 0x0c
    1d00:	bd 85       	ldd	r27, Y+13	; 0x0d
    1d02:	18 16       	cp	r1, r24
    1d04:	19 06       	cpc	r1, r25
    1d06:	1a 06       	cpc	r1, r26
    1d08:	1b 06       	cpc	r1, r27
    1d0a:	0c f4       	brge	.+2      	; 0x1d0e <LCD_VidWriteNumber+0x1e8>
    1d0c:	b5 cf       	rjmp	.-150    	; 0x1c78 <LCD_VidWriteNumber+0x152>
									}
					LCD_VidWriteData(y+48);
					reversed=reversed/10;
					x=x/10;
		 }
	}
    1d0e:	61 96       	adiw	r28, 0x11	; 17
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	de bf       	out	0x3e, r29	; 62
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	cd bf       	out	0x3d, r28	; 61
    1d1a:	cf 91       	pop	r28
    1d1c:	df 91       	pop	r29
    1d1e:	1f 91       	pop	r17
    1d20:	0f 91       	pop	r16
    1d22:	ff 90       	pop	r15
    1d24:	ef 90       	pop	r14
    1d26:	08 95       	ret

00001d28 <LCD_VidSetDdram>:


	void LCD_VidSetDdram(u8 loc_u8row,u8 loc_u8col){
    1d28:	df 93       	push	r29
    1d2a:	cf 93       	push	r28
    1d2c:	00 d0       	rcall	.+0      	; 0x1d2e <LCD_VidSetDdram+0x6>
    1d2e:	cd b7       	in	r28, 0x3d	; 61
    1d30:	de b7       	in	r29, 0x3e	; 62
    1d32:	89 83       	std	Y+1, r24	; 0x01
    1d34:	6a 83       	std	Y+2, r22	; 0x02
		if(1==loc_u8row){
    1d36:	89 81       	ldd	r24, Y+1	; 0x01
    1d38:	81 30       	cpi	r24, 0x01	; 1
    1d3a:	29 f4       	brne	.+10     	; 0x1d46 <LCD_VidSetDdram+0x1e>
			LCD_VidWriteCommand((127+loc_u8col));
    1d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3e:	81 58       	subi	r24, 0x81	; 129
    1d40:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
    1d44:	07 c0       	rjmp	.+14     	; 0x1d54 <LCD_VidSetDdram+0x2c>
		}
		else if(2==loc_u8row){
    1d46:	89 81       	ldd	r24, Y+1	; 0x01
    1d48:	82 30       	cpi	r24, 0x02	; 2
    1d4a:	21 f4       	brne	.+8      	; 0x1d54 <LCD_VidSetDdram+0x2c>

			LCD_VidWriteCommand((127+64+loc_u8col));
    1d4c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d4e:	81 54       	subi	r24, 0x41	; 65
    1d50:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
		}
	}
    1d54:	0f 90       	pop	r0
    1d56:	0f 90       	pop	r0
    1d58:	cf 91       	pop	r28
    1d5a:	df 91       	pop	r29
    1d5c:	08 95       	ret

00001d5e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1d5e:	df 93       	push	r29
    1d60:	cf 93       	push	r28
    1d62:	cd b7       	in	r28, 0x3d	; 61
    1d64:	de b7       	in	r29, 0x3e	; 62
    1d66:	27 97       	sbiw	r28, 0x07	; 7
    1d68:	0f b6       	in	r0, 0x3f	; 63
    1d6a:	f8 94       	cli
    1d6c:	de bf       	out	0x3e, r29	; 62
    1d6e:	0f be       	out	0x3f, r0	; 63
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	9d 83       	std	Y+5, r25	; 0x05
    1d74:	8c 83       	std	Y+4, r24	; 0x04
    1d76:	6e 83       	std	Y+6, r22	; 0x06
    1d78:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1d7a:	8a e1       	ldi	r24, 0x1A	; 26
    1d7c:	90 e0       	ldi	r25, 0x00	; 0
    1d7e:	0e 94 87 11 	call	0x230e	; 0x230e <pvPortMalloc>
    1d82:	9a 83       	std	Y+2, r25	; 0x02
    1d84:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    1d86:	89 81       	ldd	r24, Y+1	; 0x01
    1d88:	9a 81       	ldd	r25, Y+2	; 0x02
    1d8a:	00 97       	sbiw	r24, 0x00	; 0
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <xCoRoutineCreate+0x32>
    1d8e:	6f c0       	rjmp	.+222    	; 0x1e6e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1d90:	80 91 7e 00 	lds	r24, 0x007E
    1d94:	90 91 7f 00 	lds	r25, 0x007F
    1d98:	00 97       	sbiw	r24, 0x00	; 0
    1d9a:	41 f4       	brne	.+16     	; 0x1dac <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1d9c:	89 81       	ldd	r24, Y+1	; 0x01
    1d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    1da0:	90 93 7f 00 	sts	0x007F, r25
    1da4:	80 93 7e 00 	sts	0x007E, r24
			prvInitialiseCoRoutineLists();
    1da8:	0e 94 16 11 	call	0x222c	; 0x222c <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    1dac:	8e 81       	ldd	r24, Y+6	; 0x06
    1dae:	82 30       	cpi	r24, 0x02	; 2
    1db0:	10 f0       	brcs	.+4      	; 0x1db6 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1db6:	e9 81       	ldd	r30, Y+1	; 0x01
    1db8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dba:	11 8e       	std	Z+25, r1	; 0x19
    1dbc:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1dbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc2:	8e 81       	ldd	r24, Y+6	; 0x06
    1dc4:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1dc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dca:	8f 81       	ldd	r24, Y+7	; 0x07
    1dcc:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1dce:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd0:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd2:	8c 81       	ldd	r24, Y+4	; 0x04
    1dd4:	9d 81       	ldd	r25, Y+5	; 0x05
    1dd6:	91 83       	std	Z+1, r25	; 0x01
    1dd8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1dda:	89 81       	ldd	r24, Y+1	; 0x01
    1ddc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dde:	02 96       	adiw	r24, 0x02	; 2
    1de0:	0e 94 1d 12 	call	0x243a	; 0x243a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	9a 81       	ldd	r25, Y+2	; 0x02
    1de8:	0c 96       	adiw	r24, 0x0c	; 12
    1dea:	0e 94 1d 12 	call	0x243a	; 0x243a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1dee:	e9 81       	ldd	r30, Y+1	; 0x01
    1df0:	fa 81       	ldd	r31, Y+2	; 0x02
    1df2:	89 81       	ldd	r24, Y+1	; 0x01
    1df4:	9a 81       	ldd	r25, Y+2	; 0x02
    1df6:	91 87       	std	Z+9, r25	; 0x09
    1df8:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	9a 81       	ldd	r25, Y+2	; 0x02
    1e02:	93 8b       	std	Z+19, r25	; 0x13
    1e04:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1e06:	8e 81       	ldd	r24, Y+6	; 0x06
    1e08:	28 2f       	mov	r18, r24
    1e0a:	30 e0       	ldi	r19, 0x00	; 0
    1e0c:	86 e0       	ldi	r24, 0x06	; 6
    1e0e:	90 e0       	ldi	r25, 0x00	; 0
    1e10:	82 1b       	sub	r24, r18
    1e12:	93 0b       	sbc	r25, r19
    1e14:	e9 81       	ldd	r30, Y+1	; 0x01
    1e16:	fa 81       	ldd	r31, Y+2	; 0x02
    1e18:	95 87       	std	Z+13, r25	; 0x0d
    1e1a:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e20:	96 89       	ldd	r25, Z+22	; 0x16
    1e22:	80 91 80 00 	lds	r24, 0x0080
    1e26:	89 17       	cp	r24, r25
    1e28:	28 f4       	brcc	.+10     	; 0x1e34 <xCoRoutineCreate+0xd6>
    1e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2e:	86 89       	ldd	r24, Z+22	; 0x16
    1e30:	80 93 80 00 	sts	0x0080, r24
    1e34:	e9 81       	ldd	r30, Y+1	; 0x01
    1e36:	fa 81       	ldd	r31, Y+2	; 0x02
    1e38:	86 89       	ldd	r24, Z+22	; 0x16
    1e3a:	28 2f       	mov	r18, r24
    1e3c:	30 e0       	ldi	r19, 0x00	; 0
    1e3e:	c9 01       	movw	r24, r18
    1e40:	88 0f       	add	r24, r24
    1e42:	99 1f       	adc	r25, r25
    1e44:	88 0f       	add	r24, r24
    1e46:	99 1f       	adc	r25, r25
    1e48:	88 0f       	add	r24, r24
    1e4a:	99 1f       	adc	r25, r25
    1e4c:	82 0f       	add	r24, r18
    1e4e:	93 1f       	adc	r25, r19
    1e50:	ac 01       	movw	r20, r24
    1e52:	49 57       	subi	r20, 0x79	; 121
    1e54:	5f 4f       	sbci	r21, 0xFF	; 255
    1e56:	89 81       	ldd	r24, Y+1	; 0x01
    1e58:	9a 81       	ldd	r25, Y+2	; 0x02
    1e5a:	9c 01       	movw	r18, r24
    1e5c:	2e 5f       	subi	r18, 0xFE	; 254
    1e5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e60:	ca 01       	movw	r24, r20
    1e62:	b9 01       	movw	r22, r18
    1e64:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>

		xReturn = pdPASS;
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	8b 83       	std	Y+3, r24	; 0x03
    1e6c:	02 c0       	rjmp	.+4      	; 0x1e72 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1e6e:	8f ef       	ldi	r24, 0xFF	; 255
    1e70:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    1e72:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1e74:	27 96       	adiw	r28, 0x07	; 7
    1e76:	0f b6       	in	r0, 0x3f	; 63
    1e78:	f8 94       	cli
    1e7a:	de bf       	out	0x3e, r29	; 62
    1e7c:	0f be       	out	0x3f, r0	; 63
    1e7e:	cd bf       	out	0x3d, r28	; 61
    1e80:	cf 91       	pop	r28
    1e82:	df 91       	pop	r29
    1e84:	08 95       	ret

00001e86 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1e86:	df 93       	push	r29
    1e88:	cf 93       	push	r28
    1e8a:	00 d0       	rcall	.+0      	; 0x1e8c <vCoRoutineAddToDelayedList+0x6>
    1e8c:	00 d0       	rcall	.+0      	; 0x1e8e <vCoRoutineAddToDelayedList+0x8>
    1e8e:	00 d0       	rcall	.+0      	; 0x1e90 <vCoRoutineAddToDelayedList+0xa>
    1e90:	cd b7       	in	r28, 0x3d	; 61
    1e92:	de b7       	in	r29, 0x3e	; 62
    1e94:	9c 83       	std	Y+4, r25	; 0x04
    1e96:	8b 83       	std	Y+3, r24	; 0x03
    1e98:	7e 83       	std	Y+6, r23	; 0x06
    1e9a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1e9c:	20 91 81 00 	lds	r18, 0x0081
    1ea0:	30 91 82 00 	lds	r19, 0x0082
    1ea4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ea6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ea8:	82 0f       	add	r24, r18
    1eaa:	93 1f       	adc	r25, r19
    1eac:	9a 83       	std	Y+2, r25	; 0x02
    1eae:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1eb0:	80 91 7e 00 	lds	r24, 0x007E
    1eb4:	90 91 7f 00 	lds	r25, 0x007F
    1eb8:	02 96       	adiw	r24, 0x02	; 2
    1eba:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1ebe:	e0 91 7e 00 	lds	r30, 0x007E
    1ec2:	f0 91 7f 00 	lds	r31, 0x007F
    1ec6:	89 81       	ldd	r24, Y+1	; 0x01
    1ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    1eca:	93 83       	std	Z+3, r25	; 0x03
    1ecc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1ece:	20 91 81 00 	lds	r18, 0x0081
    1ed2:	30 91 82 00 	lds	r19, 0x0082
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    1eda:	82 17       	cp	r24, r18
    1edc:	93 07       	cpc	r25, r19
    1ede:	70 f4       	brcc	.+28     	; 0x1efc <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1ee0:	80 91 ad 00 	lds	r24, 0x00AD
    1ee4:	90 91 ae 00 	lds	r25, 0x00AE
    1ee8:	20 91 7e 00 	lds	r18, 0x007E
    1eec:	30 91 7f 00 	lds	r19, 0x007F
    1ef0:	2e 5f       	subi	r18, 0xFE	; 254
    1ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef4:	b9 01       	movw	r22, r18
    1ef6:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>
    1efa:	0d c0       	rjmp	.+26     	; 0x1f16 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1efc:	80 91 ab 00 	lds	r24, 0x00AB
    1f00:	90 91 ac 00 	lds	r25, 0x00AC
    1f04:	20 91 7e 00 	lds	r18, 0x007E
    1f08:	30 91 7f 00 	lds	r19, 0x007F
    1f0c:	2e 5f       	subi	r18, 0xFE	; 254
    1f0e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f10:	b9 01       	movw	r22, r18
    1f12:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>
	}

	if( pxEventList )
    1f16:	8d 81       	ldd	r24, Y+5	; 0x05
    1f18:	9e 81       	ldd	r25, Y+6	; 0x06
    1f1a:	00 97       	sbiw	r24, 0x00	; 0
    1f1c:	61 f0       	breq	.+24     	; 0x1f36 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1f1e:	80 91 7e 00 	lds	r24, 0x007E
    1f22:	90 91 7f 00 	lds	r25, 0x007F
    1f26:	9c 01       	movw	r18, r24
    1f28:	24 5f       	subi	r18, 0xF4	; 244
    1f2a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f2e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f30:	b9 01       	movw	r22, r18
    1f32:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>
	}
}
    1f36:	26 96       	adiw	r28, 0x06	; 6
    1f38:	0f b6       	in	r0, 0x3f	; 63
    1f3a:	f8 94       	cli
    1f3c:	de bf       	out	0x3e, r29	; 62
    1f3e:	0f be       	out	0x3f, r0	; 63
    1f40:	cd bf       	out	0x3d, r28	; 61
    1f42:	cf 91       	pop	r28
    1f44:	df 91       	pop	r29
    1f46:	08 95       	ret

00001f48 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1f48:	df 93       	push	r29
    1f4a:	cf 93       	push	r28
    1f4c:	00 d0       	rcall	.+0      	; 0x1f4e <prvCheckPendingReadyList+0x6>
    1f4e:	cd b7       	in	r28, 0x3d	; 61
    1f50:	de b7       	in	r29, 0x3e	; 62
    1f52:	3a c0       	rjmp	.+116    	; 0x1fc8 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1f54:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1f56:	e0 91 b4 00 	lds	r30, 0x00B4
    1f5a:	f0 91 b5 00 	lds	r31, 0x00B5
    1f5e:	86 81       	ldd	r24, Z+6	; 0x06
    1f60:	97 81       	ldd	r25, Z+7	; 0x07
    1f62:	9a 83       	std	Y+2, r25	; 0x02
    1f64:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f66:	89 81       	ldd	r24, Y+1	; 0x01
    1f68:	9a 81       	ldd	r25, Y+2	; 0x02
    1f6a:	0c 96       	adiw	r24, 0x0c	; 12
    1f6c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1f70:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1f72:	89 81       	ldd	r24, Y+1	; 0x01
    1f74:	9a 81       	ldd	r25, Y+2	; 0x02
    1f76:	02 96       	adiw	r24, 0x02	; 2
    1f78:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1f80:	96 89       	ldd	r25, Z+22	; 0x16
    1f82:	80 91 80 00 	lds	r24, 0x0080
    1f86:	89 17       	cp	r24, r25
    1f88:	28 f4       	brcc	.+10     	; 0x1f94 <prvCheckPendingReadyList+0x4c>
    1f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f8e:	86 89       	ldd	r24, Z+22	; 0x16
    1f90:	80 93 80 00 	sts	0x0080, r24
    1f94:	e9 81       	ldd	r30, Y+1	; 0x01
    1f96:	fa 81       	ldd	r31, Y+2	; 0x02
    1f98:	86 89       	ldd	r24, Z+22	; 0x16
    1f9a:	28 2f       	mov	r18, r24
    1f9c:	30 e0       	ldi	r19, 0x00	; 0
    1f9e:	c9 01       	movw	r24, r18
    1fa0:	88 0f       	add	r24, r24
    1fa2:	99 1f       	adc	r25, r25
    1fa4:	88 0f       	add	r24, r24
    1fa6:	99 1f       	adc	r25, r25
    1fa8:	88 0f       	add	r24, r24
    1faa:	99 1f       	adc	r25, r25
    1fac:	82 0f       	add	r24, r18
    1fae:	93 1f       	adc	r25, r19
    1fb0:	ac 01       	movw	r20, r24
    1fb2:	49 57       	subi	r20, 0x79	; 121
    1fb4:	5f 4f       	sbci	r21, 0xFF	; 255
    1fb6:	89 81       	ldd	r24, Y+1	; 0x01
    1fb8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fba:	9c 01       	movw	r18, r24
    1fbc:	2e 5f       	subi	r18, 0xFE	; 254
    1fbe:	3f 4f       	sbci	r19, 0xFF	; 255
    1fc0:	ca 01       	movw	r24, r20
    1fc2:	b9 01       	movw	r22, r18
    1fc4:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1fc8:	80 91 af 00 	lds	r24, 0x00AF
    1fcc:	88 23       	and	r24, r24
    1fce:	09 f0       	breq	.+2      	; 0x1fd2 <prvCheckPendingReadyList+0x8a>
    1fd0:	c1 cf       	rjmp	.-126    	; 0x1f54 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    1fd2:	0f 90       	pop	r0
    1fd4:	0f 90       	pop	r0
    1fd6:	cf 91       	pop	r28
    1fd8:	df 91       	pop	r29
    1fda:	08 95       	ret

00001fdc <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    1fdc:	df 93       	push	r29
    1fde:	cf 93       	push	r28
    1fe0:	00 d0       	rcall	.+0      	; 0x1fe2 <prvCheckDelayedList+0x6>
    1fe2:	00 d0       	rcall	.+0      	; 0x1fe4 <prvCheckDelayedList+0x8>
    1fe4:	cd b7       	in	r28, 0x3d	; 61
    1fe6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1fe8:	0e 94 3b 1e 	call	0x3c76	; 0x3c76 <xTaskGetTickCount>
    1fec:	20 91 83 00 	lds	r18, 0x0083
    1ff0:	30 91 84 00 	lds	r19, 0x0084
    1ff4:	82 1b       	sub	r24, r18
    1ff6:	93 0b       	sbc	r25, r19
    1ff8:	90 93 86 00 	sts	0x0086, r25
    1ffc:	80 93 85 00 	sts	0x0085, r24
    2000:	85 c0       	rjmp	.+266    	; 0x210c <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    2002:	80 91 81 00 	lds	r24, 0x0081
    2006:	90 91 82 00 	lds	r25, 0x0082
    200a:	01 96       	adiw	r24, 0x01	; 1
    200c:	90 93 82 00 	sts	0x0082, r25
    2010:	80 93 81 00 	sts	0x0081, r24
		xPassedTicks--;
    2014:	80 91 85 00 	lds	r24, 0x0085
    2018:	90 91 86 00 	lds	r25, 0x0086
    201c:	01 97       	sbiw	r24, 0x01	; 1
    201e:	90 93 86 00 	sts	0x0086, r25
    2022:	80 93 85 00 	sts	0x0085, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2026:	80 91 81 00 	lds	r24, 0x0081
    202a:	90 91 82 00 	lds	r25, 0x0082
    202e:	00 97       	sbiw	r24, 0x00	; 0
    2030:	09 f0       	breq	.+2      	; 0x2034 <prvCheckDelayedList+0x58>
    2032:	64 c0       	rjmp	.+200    	; 0x20fc <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2034:	80 91 ab 00 	lds	r24, 0x00AB
    2038:	90 91 ac 00 	lds	r25, 0x00AC
    203c:	9a 83       	std	Y+2, r25	; 0x02
    203e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2040:	80 91 ad 00 	lds	r24, 0x00AD
    2044:	90 91 ae 00 	lds	r25, 0x00AE
    2048:	90 93 ac 00 	sts	0x00AC, r25
    204c:	80 93 ab 00 	sts	0x00AB, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	9a 81       	ldd	r25, Y+2	; 0x02
    2054:	90 93 ae 00 	sts	0x00AE, r25
    2058:	80 93 ad 00 	sts	0x00AD, r24
    205c:	4f c0       	rjmp	.+158    	; 0x20fc <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    205e:	e0 91 ab 00 	lds	r30, 0x00AB
    2062:	f0 91 ac 00 	lds	r31, 0x00AC
    2066:	05 80       	ldd	r0, Z+5	; 0x05
    2068:	f6 81       	ldd	r31, Z+6	; 0x06
    206a:	e0 2d       	mov	r30, r0
    206c:	86 81       	ldd	r24, Z+6	; 0x06
    206e:	97 81       	ldd	r25, Z+7	; 0x07
    2070:	9c 83       	std	Y+4, r25	; 0x04
    2072:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    2074:	eb 81       	ldd	r30, Y+3	; 0x03
    2076:	fc 81       	ldd	r31, Y+4	; 0x04
    2078:	22 81       	ldd	r18, Z+2	; 0x02
    207a:	33 81       	ldd	r19, Z+3	; 0x03
    207c:	80 91 81 00 	lds	r24, 0x0081
    2080:	90 91 82 00 	lds	r25, 0x0082
    2084:	82 17       	cp	r24, r18
    2086:	93 07       	cpc	r25, r19
    2088:	08 f4       	brcc	.+2      	; 0x208c <prvCheckDelayedList+0xb0>
    208a:	40 c0       	rjmp	.+128    	; 0x210c <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    208c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    208e:	8b 81       	ldd	r24, Y+3	; 0x03
    2090:	9c 81       	ldd	r25, Y+4	; 0x04
    2092:	02 96       	adiw	r24, 0x02	; 2
    2094:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2098:	eb 81       	ldd	r30, Y+3	; 0x03
    209a:	fc 81       	ldd	r31, Y+4	; 0x04
    209c:	84 89       	ldd	r24, Z+20	; 0x14
    209e:	95 89       	ldd	r25, Z+21	; 0x15
    20a0:	00 97       	sbiw	r24, 0x00	; 0
    20a2:	29 f0       	breq	.+10     	; 0x20ae <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    20a4:	8b 81       	ldd	r24, Y+3	; 0x03
    20a6:	9c 81       	ldd	r25, Y+4	; 0x04
    20a8:	0c 96       	adiw	r24, 0x0c	; 12
    20aa:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    20ae:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    20b0:	eb 81       	ldd	r30, Y+3	; 0x03
    20b2:	fc 81       	ldd	r31, Y+4	; 0x04
    20b4:	96 89       	ldd	r25, Z+22	; 0x16
    20b6:	80 91 80 00 	lds	r24, 0x0080
    20ba:	89 17       	cp	r24, r25
    20bc:	28 f4       	brcc	.+10     	; 0x20c8 <prvCheckDelayedList+0xec>
    20be:	eb 81       	ldd	r30, Y+3	; 0x03
    20c0:	fc 81       	ldd	r31, Y+4	; 0x04
    20c2:	86 89       	ldd	r24, Z+22	; 0x16
    20c4:	80 93 80 00 	sts	0x0080, r24
    20c8:	eb 81       	ldd	r30, Y+3	; 0x03
    20ca:	fc 81       	ldd	r31, Y+4	; 0x04
    20cc:	86 89       	ldd	r24, Z+22	; 0x16
    20ce:	28 2f       	mov	r18, r24
    20d0:	30 e0       	ldi	r19, 0x00	; 0
    20d2:	c9 01       	movw	r24, r18
    20d4:	88 0f       	add	r24, r24
    20d6:	99 1f       	adc	r25, r25
    20d8:	88 0f       	add	r24, r24
    20da:	99 1f       	adc	r25, r25
    20dc:	88 0f       	add	r24, r24
    20de:	99 1f       	adc	r25, r25
    20e0:	82 0f       	add	r24, r18
    20e2:	93 1f       	adc	r25, r19
    20e4:	ac 01       	movw	r20, r24
    20e6:	49 57       	subi	r20, 0x79	; 121
    20e8:	5f 4f       	sbci	r21, 0xFF	; 255
    20ea:	8b 81       	ldd	r24, Y+3	; 0x03
    20ec:	9c 81       	ldd	r25, Y+4	; 0x04
    20ee:	9c 01       	movw	r18, r24
    20f0:	2e 5f       	subi	r18, 0xFE	; 254
    20f2:	3f 4f       	sbci	r19, 0xFF	; 255
    20f4:	ca 01       	movw	r24, r20
    20f6:	b9 01       	movw	r22, r18
    20f8:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    20fc:	e0 91 ab 00 	lds	r30, 0x00AB
    2100:	f0 91 ac 00 	lds	r31, 0x00AC
    2104:	80 81       	ld	r24, Z
    2106:	88 23       	and	r24, r24
    2108:	09 f0       	breq	.+2      	; 0x210c <prvCheckDelayedList+0x130>
    210a:	a9 cf       	rjmp	.-174    	; 0x205e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    210c:	80 91 85 00 	lds	r24, 0x0085
    2110:	90 91 86 00 	lds	r25, 0x0086
    2114:	00 97       	sbiw	r24, 0x00	; 0
    2116:	09 f0       	breq	.+2      	; 0x211a <prvCheckDelayedList+0x13e>
    2118:	74 cf       	rjmp	.-280    	; 0x2002 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    211a:	80 91 81 00 	lds	r24, 0x0081
    211e:	90 91 82 00 	lds	r25, 0x0082
    2122:	90 93 84 00 	sts	0x0084, r25
    2126:	80 93 83 00 	sts	0x0083, r24
}
    212a:	0f 90       	pop	r0
    212c:	0f 90       	pop	r0
    212e:	0f 90       	pop	r0
    2130:	0f 90       	pop	r0
    2132:	cf 91       	pop	r28
    2134:	df 91       	pop	r29
    2136:	08 95       	ret

00002138 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2138:	df 93       	push	r29
    213a:	cf 93       	push	r28
    213c:	00 d0       	rcall	.+0      	; 0x213e <vCoRoutineSchedule+0x6>
    213e:	cd b7       	in	r28, 0x3d	; 61
    2140:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2142:	0e 94 a4 0f 	call	0x1f48	; 0x1f48 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2146:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <prvCheckDelayedList>
    214a:	0a c0       	rjmp	.+20     	; 0x2160 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    214c:	80 91 80 00 	lds	r24, 0x0080
    2150:	88 23       	and	r24, r24
    2152:	09 f4       	brne	.+2      	; 0x2156 <vCoRoutineSchedule+0x1e>
    2154:	66 c0       	rjmp	.+204    	; 0x2222 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2156:	80 91 80 00 	lds	r24, 0x0080
    215a:	81 50       	subi	r24, 0x01	; 1
    215c:	80 93 80 00 	sts	0x0080, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2160:	80 91 80 00 	lds	r24, 0x0080
    2164:	28 2f       	mov	r18, r24
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	c9 01       	movw	r24, r18
    216a:	88 0f       	add	r24, r24
    216c:	99 1f       	adc	r25, r25
    216e:	88 0f       	add	r24, r24
    2170:	99 1f       	adc	r25, r25
    2172:	88 0f       	add	r24, r24
    2174:	99 1f       	adc	r25, r25
    2176:	82 0f       	add	r24, r18
    2178:	93 1f       	adc	r25, r19
    217a:	fc 01       	movw	r30, r24
    217c:	e9 57       	subi	r30, 0x79	; 121
    217e:	ff 4f       	sbci	r31, 0xFF	; 255
    2180:	80 81       	ld	r24, Z
    2182:	88 23       	and	r24, r24
    2184:	19 f3       	breq	.-58     	; 0x214c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2186:	80 91 80 00 	lds	r24, 0x0080
    218a:	28 2f       	mov	r18, r24
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	c9 01       	movw	r24, r18
    2190:	88 0f       	add	r24, r24
    2192:	99 1f       	adc	r25, r25
    2194:	88 0f       	add	r24, r24
    2196:	99 1f       	adc	r25, r25
    2198:	88 0f       	add	r24, r24
    219a:	99 1f       	adc	r25, r25
    219c:	82 0f       	add	r24, r18
    219e:	93 1f       	adc	r25, r19
    21a0:	89 57       	subi	r24, 0x79	; 121
    21a2:	9f 4f       	sbci	r25, 0xFF	; 255
    21a4:	9a 83       	std	Y+2, r25	; 0x02
    21a6:	89 83       	std	Y+1, r24	; 0x01
    21a8:	e9 81       	ldd	r30, Y+1	; 0x01
    21aa:	fa 81       	ldd	r31, Y+2	; 0x02
    21ac:	01 80       	ldd	r0, Z+1	; 0x01
    21ae:	f2 81       	ldd	r31, Z+2	; 0x02
    21b0:	e0 2d       	mov	r30, r0
    21b2:	82 81       	ldd	r24, Z+2	; 0x02
    21b4:	93 81       	ldd	r25, Z+3	; 0x03
    21b6:	e9 81       	ldd	r30, Y+1	; 0x01
    21b8:	fa 81       	ldd	r31, Y+2	; 0x02
    21ba:	92 83       	std	Z+2, r25	; 0x02
    21bc:	81 83       	std	Z+1, r24	; 0x01
    21be:	e9 81       	ldd	r30, Y+1	; 0x01
    21c0:	fa 81       	ldd	r31, Y+2	; 0x02
    21c2:	21 81       	ldd	r18, Z+1	; 0x01
    21c4:	32 81       	ldd	r19, Z+2	; 0x02
    21c6:	89 81       	ldd	r24, Y+1	; 0x01
    21c8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ca:	03 96       	adiw	r24, 0x03	; 3
    21cc:	28 17       	cp	r18, r24
    21ce:	39 07       	cpc	r19, r25
    21d0:	59 f4       	brne	.+22     	; 0x21e8 <vCoRoutineSchedule+0xb0>
    21d2:	e9 81       	ldd	r30, Y+1	; 0x01
    21d4:	fa 81       	ldd	r31, Y+2	; 0x02
    21d6:	01 80       	ldd	r0, Z+1	; 0x01
    21d8:	f2 81       	ldd	r31, Z+2	; 0x02
    21da:	e0 2d       	mov	r30, r0
    21dc:	82 81       	ldd	r24, Z+2	; 0x02
    21de:	93 81       	ldd	r25, Z+3	; 0x03
    21e0:	e9 81       	ldd	r30, Y+1	; 0x01
    21e2:	fa 81       	ldd	r31, Y+2	; 0x02
    21e4:	92 83       	std	Z+2, r25	; 0x02
    21e6:	81 83       	std	Z+1, r24	; 0x01
    21e8:	e9 81       	ldd	r30, Y+1	; 0x01
    21ea:	fa 81       	ldd	r31, Y+2	; 0x02
    21ec:	01 80       	ldd	r0, Z+1	; 0x01
    21ee:	f2 81       	ldd	r31, Z+2	; 0x02
    21f0:	e0 2d       	mov	r30, r0
    21f2:	86 81       	ldd	r24, Z+6	; 0x06
    21f4:	97 81       	ldd	r25, Z+7	; 0x07
    21f6:	90 93 7f 00 	sts	0x007F, r25
    21fa:	80 93 7e 00 	sts	0x007E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    21fe:	e0 91 7e 00 	lds	r30, 0x007E
    2202:	f0 91 7f 00 	lds	r31, 0x007F
    2206:	40 81       	ld	r20, Z
    2208:	51 81       	ldd	r21, Z+1	; 0x01
    220a:	80 91 7e 00 	lds	r24, 0x007E
    220e:	90 91 7f 00 	lds	r25, 0x007F
    2212:	e0 91 7e 00 	lds	r30, 0x007E
    2216:	f0 91 7f 00 	lds	r31, 0x007F
    221a:	27 89       	ldd	r18, Z+23	; 0x17
    221c:	62 2f       	mov	r22, r18
    221e:	fa 01       	movw	r30, r20
    2220:	09 95       	icall

	return;
}
    2222:	0f 90       	pop	r0
    2224:	0f 90       	pop	r0
    2226:	cf 91       	pop	r28
    2228:	df 91       	pop	r29
    222a:	08 95       	ret

0000222c <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    222c:	df 93       	push	r29
    222e:	cf 93       	push	r28
    2230:	0f 92       	push	r0
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2236:	19 82       	std	Y+1, r1	; 0x01
    2238:	13 c0       	rjmp	.+38     	; 0x2260 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    223a:	89 81       	ldd	r24, Y+1	; 0x01
    223c:	28 2f       	mov	r18, r24
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	c9 01       	movw	r24, r18
    2242:	88 0f       	add	r24, r24
    2244:	99 1f       	adc	r25, r25
    2246:	88 0f       	add	r24, r24
    2248:	99 1f       	adc	r25, r25
    224a:	88 0f       	add	r24, r24
    224c:	99 1f       	adc	r25, r25
    224e:	82 0f       	add	r24, r18
    2250:	93 1f       	adc	r25, r19
    2252:	89 57       	subi	r24, 0x79	; 121
    2254:	9f 4f       	sbci	r25, 0xFF	; 255
    2256:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    225a:	89 81       	ldd	r24, Y+1	; 0x01
    225c:	8f 5f       	subi	r24, 0xFF	; 255
    225e:	89 83       	std	Y+1, r24	; 0x01
    2260:	89 81       	ldd	r24, Y+1	; 0x01
    2262:	82 30       	cpi	r24, 0x02	; 2
    2264:	50 f3       	brcs	.-44     	; 0x223a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2266:	89 e9       	ldi	r24, 0x99	; 153
    2268:	90 e0       	ldi	r25, 0x00	; 0
    226a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    226e:	82 ea       	ldi	r24, 0xA2	; 162
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2276:	8f ea       	ldi	r24, 0xAF	; 175
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    227e:	89 e9       	ldi	r24, 0x99	; 153
    2280:	90 e0       	ldi	r25, 0x00	; 0
    2282:	90 93 ac 00 	sts	0x00AC, r25
    2286:	80 93 ab 00 	sts	0x00AB, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    228a:	82 ea       	ldi	r24, 0xA2	; 162
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	90 93 ae 00 	sts	0x00AE, r25
    2292:	80 93 ad 00 	sts	0x00AD, r24
}
    2296:	0f 90       	pop	r0
    2298:	cf 91       	pop	r28
    229a:	df 91       	pop	r29
    229c:	08 95       	ret

0000229e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    229e:	df 93       	push	r29
    22a0:	cf 93       	push	r28
    22a2:	00 d0       	rcall	.+0      	; 0x22a4 <xCoRoutineRemoveFromEventList+0x6>
    22a4:	00 d0       	rcall	.+0      	; 0x22a6 <xCoRoutineRemoveFromEventList+0x8>
    22a6:	0f 92       	push	r0
    22a8:	cd b7       	in	r28, 0x3d	; 61
    22aa:	de b7       	in	r29, 0x3e	; 62
    22ac:	9d 83       	std	Y+5, r25	; 0x05
    22ae:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    22b0:	ec 81       	ldd	r30, Y+4	; 0x04
    22b2:	fd 81       	ldd	r31, Y+5	; 0x05
    22b4:	05 80       	ldd	r0, Z+5	; 0x05
    22b6:	f6 81       	ldd	r31, Z+6	; 0x06
    22b8:	e0 2d       	mov	r30, r0
    22ba:	86 81       	ldd	r24, Z+6	; 0x06
    22bc:	97 81       	ldd	r25, Z+7	; 0x07
    22be:	9b 83       	std	Y+3, r25	; 0x03
    22c0:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    22c2:	8a 81       	ldd	r24, Y+2	; 0x02
    22c4:	9b 81       	ldd	r25, Y+3	; 0x03
    22c6:	0c 96       	adiw	r24, 0x0c	; 12
    22c8:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    22cc:	8a 81       	ldd	r24, Y+2	; 0x02
    22ce:	9b 81       	ldd	r25, Y+3	; 0x03
    22d0:	9c 01       	movw	r18, r24
    22d2:	24 5f       	subi	r18, 0xF4	; 244
    22d4:	3f 4f       	sbci	r19, 0xFF	; 255
    22d6:	8f ea       	ldi	r24, 0xAF	; 175
    22d8:	90 e0       	ldi	r25, 0x00	; 0
    22da:	b9 01       	movw	r22, r18
    22dc:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    22e0:	ea 81       	ldd	r30, Y+2	; 0x02
    22e2:	fb 81       	ldd	r31, Y+3	; 0x03
    22e4:	96 89       	ldd	r25, Z+22	; 0x16
    22e6:	e0 91 7e 00 	lds	r30, 0x007E
    22ea:	f0 91 7f 00 	lds	r31, 0x007F
    22ee:	86 89       	ldd	r24, Z+22	; 0x16
    22f0:	98 17       	cp	r25, r24
    22f2:	18 f0       	brcs	.+6      	; 0x22fa <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	89 83       	std	Y+1, r24	; 0x01
    22f8:	01 c0       	rjmp	.+2      	; 0x22fc <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    22fa:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
}
    22fe:	0f 90       	pop	r0
    2300:	0f 90       	pop	r0
    2302:	0f 90       	pop	r0
    2304:	0f 90       	pop	r0
    2306:	0f 90       	pop	r0
    2308:	cf 91       	pop	r28
    230a:	df 91       	pop	r29
    230c:	08 95       	ret

0000230e <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    230e:	df 93       	push	r29
    2310:	cf 93       	push	r28
    2312:	00 d0       	rcall	.+0      	; 0x2314 <pvPortMalloc+0x6>
    2314:	00 d0       	rcall	.+0      	; 0x2316 <pvPortMalloc+0x8>
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	9c 83       	std	Y+4, r25	; 0x04
    231c:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    231e:	1a 82       	std	Y+2, r1	; 0x02
    2320:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2322:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2326:	80 91 b8 00 	lds	r24, 0x00B8
    232a:	90 91 b9 00 	lds	r25, 0x00B9
    232e:	2b 81       	ldd	r18, Y+3	; 0x03
    2330:	3c 81       	ldd	r19, Y+4	; 0x04
    2332:	82 0f       	add	r24, r18
    2334:	93 1f       	adc	r25, r19
    2336:	23 e0       	ldi	r18, 0x03	; 3
    2338:	88 3e       	cpi	r24, 0xE8	; 232
    233a:	92 07       	cpc	r25, r18
    233c:	18 f5       	brcc	.+70     	; 0x2384 <pvPortMalloc+0x76>
    233e:	20 91 b8 00 	lds	r18, 0x00B8
    2342:	30 91 b9 00 	lds	r19, 0x00B9
    2346:	8b 81       	ldd	r24, Y+3	; 0x03
    2348:	9c 81       	ldd	r25, Y+4	; 0x04
    234a:	28 0f       	add	r18, r24
    234c:	39 1f       	adc	r19, r25
    234e:	80 91 b8 00 	lds	r24, 0x00B8
    2352:	90 91 b9 00 	lds	r25, 0x00B9
    2356:	82 17       	cp	r24, r18
    2358:	93 07       	cpc	r25, r19
    235a:	a0 f4       	brcc	.+40     	; 0x2384 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    235c:	80 91 b8 00 	lds	r24, 0x00B8
    2360:	90 91 b9 00 	lds	r25, 0x00B9
    2364:	86 54       	subi	r24, 0x46	; 70
    2366:	9f 4f       	sbci	r25, 0xFF	; 255
    2368:	9a 83       	std	Y+2, r25	; 0x02
    236a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    236c:	20 91 b8 00 	lds	r18, 0x00B8
    2370:	30 91 b9 00 	lds	r19, 0x00B9
    2374:	8b 81       	ldd	r24, Y+3	; 0x03
    2376:	9c 81       	ldd	r25, Y+4	; 0x04
    2378:	82 0f       	add	r24, r18
    237a:	93 1f       	adc	r25, r19
    237c:	90 93 b9 00 	sts	0x00B9, r25
    2380:	80 93 b8 00 	sts	0x00B8, r24
		}	
	}
	xTaskResumeAll();
    2384:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2388:	89 81       	ldd	r24, Y+1	; 0x01
    238a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    238c:	0f 90       	pop	r0
    238e:	0f 90       	pop	r0
    2390:	0f 90       	pop	r0
    2392:	0f 90       	pop	r0
    2394:	cf 91       	pop	r28
    2396:	df 91       	pop	r29
    2398:	08 95       	ret

0000239a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    239a:	df 93       	push	r29
    239c:	cf 93       	push	r28
    239e:	00 d0       	rcall	.+0      	; 0x23a0 <vPortFree+0x6>
    23a0:	cd b7       	in	r28, 0x3d	; 61
    23a2:	de b7       	in	r29, 0x3e	; 62
    23a4:	9a 83       	std	Y+2, r25	; 0x02
    23a6:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    23a8:	0f 90       	pop	r0
    23aa:	0f 90       	pop	r0
    23ac:	cf 91       	pop	r28
    23ae:	df 91       	pop	r29
    23b0:	08 95       	ret

000023b2 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    23b2:	df 93       	push	r29
    23b4:	cf 93       	push	r28
    23b6:	cd b7       	in	r28, 0x3d	; 61
    23b8:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    23ba:	10 92 b9 00 	sts	0x00B9, r1
    23be:	10 92 b8 00 	sts	0x00B8, r1
}
    23c2:	cf 91       	pop	r28
    23c4:	df 91       	pop	r29
    23c6:	08 95       	ret

000023c8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    23c8:	df 93       	push	r29
    23ca:	cf 93       	push	r28
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    23d0:	20 91 b8 00 	lds	r18, 0x00B8
    23d4:	30 91 b9 00 	lds	r19, 0x00B9
    23d8:	88 ee       	ldi	r24, 0xE8	; 232
    23da:	93 e0       	ldi	r25, 0x03	; 3
    23dc:	82 1b       	sub	r24, r18
    23de:	93 0b       	sbc	r25, r19
}
    23e0:	cf 91       	pop	r28
    23e2:	df 91       	pop	r29
    23e4:	08 95       	ret

000023e6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    23e6:	df 93       	push	r29
    23e8:	cf 93       	push	r28
    23ea:	00 d0       	rcall	.+0      	; 0x23ec <vListInitialise+0x6>
    23ec:	cd b7       	in	r28, 0x3d	; 61
    23ee:	de b7       	in	r29, 0x3e	; 62
    23f0:	9a 83       	std	Y+2, r25	; 0x02
    23f2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    23f4:	89 81       	ldd	r24, Y+1	; 0x01
    23f6:	9a 81       	ldd	r25, Y+2	; 0x02
    23f8:	03 96       	adiw	r24, 0x03	; 3
    23fa:	e9 81       	ldd	r30, Y+1	; 0x01
    23fc:	fa 81       	ldd	r31, Y+2	; 0x02
    23fe:	92 83       	std	Z+2, r25	; 0x02
    2400:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2402:	e9 81       	ldd	r30, Y+1	; 0x01
    2404:	fa 81       	ldd	r31, Y+2	; 0x02
    2406:	8f ef       	ldi	r24, 0xFF	; 255
    2408:	9f ef       	ldi	r25, 0xFF	; 255
    240a:	94 83       	std	Z+4, r25	; 0x04
    240c:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    240e:	89 81       	ldd	r24, Y+1	; 0x01
    2410:	9a 81       	ldd	r25, Y+2	; 0x02
    2412:	03 96       	adiw	r24, 0x03	; 3
    2414:	e9 81       	ldd	r30, Y+1	; 0x01
    2416:	fa 81       	ldd	r31, Y+2	; 0x02
    2418:	96 83       	std	Z+6, r25	; 0x06
    241a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    241c:	89 81       	ldd	r24, Y+1	; 0x01
    241e:	9a 81       	ldd	r25, Y+2	; 0x02
    2420:	03 96       	adiw	r24, 0x03	; 3
    2422:	e9 81       	ldd	r30, Y+1	; 0x01
    2424:	fa 81       	ldd	r31, Y+2	; 0x02
    2426:	90 87       	std	Z+8, r25	; 0x08
    2428:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    242a:	e9 81       	ldd	r30, Y+1	; 0x01
    242c:	fa 81       	ldd	r31, Y+2	; 0x02
    242e:	10 82       	st	Z, r1
}
    2430:	0f 90       	pop	r0
    2432:	0f 90       	pop	r0
    2434:	cf 91       	pop	r28
    2436:	df 91       	pop	r29
    2438:	08 95       	ret

0000243a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    243a:	df 93       	push	r29
    243c:	cf 93       	push	r28
    243e:	00 d0       	rcall	.+0      	; 0x2440 <vListInitialiseItem+0x6>
    2440:	cd b7       	in	r28, 0x3d	; 61
    2442:	de b7       	in	r29, 0x3e	; 62
    2444:	9a 83       	std	Y+2, r25	; 0x02
    2446:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2448:	e9 81       	ldd	r30, Y+1	; 0x01
    244a:	fa 81       	ldd	r31, Y+2	; 0x02
    244c:	11 86       	std	Z+9, r1	; 0x09
    244e:	10 86       	std	Z+8, r1	; 0x08
}
    2450:	0f 90       	pop	r0
    2452:	0f 90       	pop	r0
    2454:	cf 91       	pop	r28
    2456:	df 91       	pop	r29
    2458:	08 95       	ret

0000245a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    245a:	df 93       	push	r29
    245c:	cf 93       	push	r28
    245e:	00 d0       	rcall	.+0      	; 0x2460 <vListInsertEnd+0x6>
    2460:	00 d0       	rcall	.+0      	; 0x2462 <vListInsertEnd+0x8>
    2462:	00 d0       	rcall	.+0      	; 0x2464 <vListInsertEnd+0xa>
    2464:	cd b7       	in	r28, 0x3d	; 61
    2466:	de b7       	in	r29, 0x3e	; 62
    2468:	9c 83       	std	Y+4, r25	; 0x04
    246a:	8b 83       	std	Y+3, r24	; 0x03
    246c:	7e 83       	std	Y+6, r23	; 0x06
    246e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2470:	eb 81       	ldd	r30, Y+3	; 0x03
    2472:	fc 81       	ldd	r31, Y+4	; 0x04
    2474:	81 81       	ldd	r24, Z+1	; 0x01
    2476:	92 81       	ldd	r25, Z+2	; 0x02
    2478:	9a 83       	std	Y+2, r25	; 0x02
    247a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    247c:	e9 81       	ldd	r30, Y+1	; 0x01
    247e:	fa 81       	ldd	r31, Y+2	; 0x02
    2480:	82 81       	ldd	r24, Z+2	; 0x02
    2482:	93 81       	ldd	r25, Z+3	; 0x03
    2484:	ed 81       	ldd	r30, Y+5	; 0x05
    2486:	fe 81       	ldd	r31, Y+6	; 0x06
    2488:	93 83       	std	Z+3, r25	; 0x03
    248a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    248c:	eb 81       	ldd	r30, Y+3	; 0x03
    248e:	fc 81       	ldd	r31, Y+4	; 0x04
    2490:	81 81       	ldd	r24, Z+1	; 0x01
    2492:	92 81       	ldd	r25, Z+2	; 0x02
    2494:	ed 81       	ldd	r30, Y+5	; 0x05
    2496:	fe 81       	ldd	r31, Y+6	; 0x06
    2498:	95 83       	std	Z+5, r25	; 0x05
    249a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    249c:	e9 81       	ldd	r30, Y+1	; 0x01
    249e:	fa 81       	ldd	r31, Y+2	; 0x02
    24a0:	02 80       	ldd	r0, Z+2	; 0x02
    24a2:	f3 81       	ldd	r31, Z+3	; 0x03
    24a4:	e0 2d       	mov	r30, r0
    24a6:	8d 81       	ldd	r24, Y+5	; 0x05
    24a8:	9e 81       	ldd	r25, Y+6	; 0x06
    24aa:	95 83       	std	Z+5, r25	; 0x05
    24ac:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    24ae:	8d 81       	ldd	r24, Y+5	; 0x05
    24b0:	9e 81       	ldd	r25, Y+6	; 0x06
    24b2:	e9 81       	ldd	r30, Y+1	; 0x01
    24b4:	fa 81       	ldd	r31, Y+2	; 0x02
    24b6:	93 83       	std	Z+3, r25	; 0x03
    24b8:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    24ba:	8d 81       	ldd	r24, Y+5	; 0x05
    24bc:	9e 81       	ldd	r25, Y+6	; 0x06
    24be:	eb 81       	ldd	r30, Y+3	; 0x03
    24c0:	fc 81       	ldd	r31, Y+4	; 0x04
    24c2:	92 83       	std	Z+2, r25	; 0x02
    24c4:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    24c6:	ed 81       	ldd	r30, Y+5	; 0x05
    24c8:	fe 81       	ldd	r31, Y+6	; 0x06
    24ca:	8b 81       	ldd	r24, Y+3	; 0x03
    24cc:	9c 81       	ldd	r25, Y+4	; 0x04
    24ce:	91 87       	std	Z+9, r25	; 0x09
    24d0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    24d2:	eb 81       	ldd	r30, Y+3	; 0x03
    24d4:	fc 81       	ldd	r31, Y+4	; 0x04
    24d6:	80 81       	ld	r24, Z
    24d8:	8f 5f       	subi	r24, 0xFF	; 255
    24da:	eb 81       	ldd	r30, Y+3	; 0x03
    24dc:	fc 81       	ldd	r31, Y+4	; 0x04
    24de:	80 83       	st	Z, r24
}
    24e0:	26 96       	adiw	r28, 0x06	; 6
    24e2:	0f b6       	in	r0, 0x3f	; 63
    24e4:	f8 94       	cli
    24e6:	de bf       	out	0x3e, r29	; 62
    24e8:	0f be       	out	0x3f, r0	; 63
    24ea:	cd bf       	out	0x3d, r28	; 61
    24ec:	cf 91       	pop	r28
    24ee:	df 91       	pop	r29
    24f0:	08 95       	ret

000024f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    24f2:	df 93       	push	r29
    24f4:	cf 93       	push	r28
    24f6:	cd b7       	in	r28, 0x3d	; 61
    24f8:	de b7       	in	r29, 0x3e	; 62
    24fa:	28 97       	sbiw	r28, 0x08	; 8
    24fc:	0f b6       	in	r0, 0x3f	; 63
    24fe:	f8 94       	cli
    2500:	de bf       	out	0x3e, r29	; 62
    2502:	0f be       	out	0x3f, r0	; 63
    2504:	cd bf       	out	0x3d, r28	; 61
    2506:	9e 83       	std	Y+6, r25	; 0x06
    2508:	8d 83       	std	Y+5, r24	; 0x05
    250a:	78 87       	std	Y+8, r23	; 0x08
    250c:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    250e:	ef 81       	ldd	r30, Y+7	; 0x07
    2510:	f8 85       	ldd	r31, Y+8	; 0x08
    2512:	80 81       	ld	r24, Z
    2514:	91 81       	ldd	r25, Z+1	; 0x01
    2516:	9a 83       	std	Y+2, r25	; 0x02
    2518:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    251a:	89 81       	ldd	r24, Y+1	; 0x01
    251c:	9a 81       	ldd	r25, Y+2	; 0x02
    251e:	2f ef       	ldi	r18, 0xFF	; 255
    2520:	8f 3f       	cpi	r24, 0xFF	; 255
    2522:	92 07       	cpc	r25, r18
    2524:	39 f4       	brne	.+14     	; 0x2534 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2526:	ed 81       	ldd	r30, Y+5	; 0x05
    2528:	fe 81       	ldd	r31, Y+6	; 0x06
    252a:	87 81       	ldd	r24, Z+7	; 0x07
    252c:	90 85       	ldd	r25, Z+8	; 0x08
    252e:	9c 83       	std	Y+4, r25	; 0x04
    2530:	8b 83       	std	Y+3, r24	; 0x03
    2532:	18 c0       	rjmp	.+48     	; 0x2564 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2534:	8d 81       	ldd	r24, Y+5	; 0x05
    2536:	9e 81       	ldd	r25, Y+6	; 0x06
    2538:	03 96       	adiw	r24, 0x03	; 3
    253a:	9c 83       	std	Y+4, r25	; 0x04
    253c:	8b 83       	std	Y+3, r24	; 0x03
    253e:	06 c0       	rjmp	.+12     	; 0x254c <vListInsert+0x5a>
    2540:	eb 81       	ldd	r30, Y+3	; 0x03
    2542:	fc 81       	ldd	r31, Y+4	; 0x04
    2544:	82 81       	ldd	r24, Z+2	; 0x02
    2546:	93 81       	ldd	r25, Z+3	; 0x03
    2548:	9c 83       	std	Y+4, r25	; 0x04
    254a:	8b 83       	std	Y+3, r24	; 0x03
    254c:	eb 81       	ldd	r30, Y+3	; 0x03
    254e:	fc 81       	ldd	r31, Y+4	; 0x04
    2550:	02 80       	ldd	r0, Z+2	; 0x02
    2552:	f3 81       	ldd	r31, Z+3	; 0x03
    2554:	e0 2d       	mov	r30, r0
    2556:	20 81       	ld	r18, Z
    2558:	31 81       	ldd	r19, Z+1	; 0x01
    255a:	89 81       	ldd	r24, Y+1	; 0x01
    255c:	9a 81       	ldd	r25, Y+2	; 0x02
    255e:	82 17       	cp	r24, r18
    2560:	93 07       	cpc	r25, r19
    2562:	70 f7       	brcc	.-36     	; 0x2540 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2564:	eb 81       	ldd	r30, Y+3	; 0x03
    2566:	fc 81       	ldd	r31, Y+4	; 0x04
    2568:	82 81       	ldd	r24, Z+2	; 0x02
    256a:	93 81       	ldd	r25, Z+3	; 0x03
    256c:	ef 81       	ldd	r30, Y+7	; 0x07
    256e:	f8 85       	ldd	r31, Y+8	; 0x08
    2570:	93 83       	std	Z+3, r25	; 0x03
    2572:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2574:	ef 81       	ldd	r30, Y+7	; 0x07
    2576:	f8 85       	ldd	r31, Y+8	; 0x08
    2578:	02 80       	ldd	r0, Z+2	; 0x02
    257a:	f3 81       	ldd	r31, Z+3	; 0x03
    257c:	e0 2d       	mov	r30, r0
    257e:	8f 81       	ldd	r24, Y+7	; 0x07
    2580:	98 85       	ldd	r25, Y+8	; 0x08
    2582:	95 83       	std	Z+5, r25	; 0x05
    2584:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2586:	ef 81       	ldd	r30, Y+7	; 0x07
    2588:	f8 85       	ldd	r31, Y+8	; 0x08
    258a:	8b 81       	ldd	r24, Y+3	; 0x03
    258c:	9c 81       	ldd	r25, Y+4	; 0x04
    258e:	95 83       	std	Z+5, r25	; 0x05
    2590:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2592:	8f 81       	ldd	r24, Y+7	; 0x07
    2594:	98 85       	ldd	r25, Y+8	; 0x08
    2596:	eb 81       	ldd	r30, Y+3	; 0x03
    2598:	fc 81       	ldd	r31, Y+4	; 0x04
    259a:	93 83       	std	Z+3, r25	; 0x03
    259c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    259e:	ef 81       	ldd	r30, Y+7	; 0x07
    25a0:	f8 85       	ldd	r31, Y+8	; 0x08
    25a2:	8d 81       	ldd	r24, Y+5	; 0x05
    25a4:	9e 81       	ldd	r25, Y+6	; 0x06
    25a6:	91 87       	std	Z+9, r25	; 0x09
    25a8:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    25aa:	ed 81       	ldd	r30, Y+5	; 0x05
    25ac:	fe 81       	ldd	r31, Y+6	; 0x06
    25ae:	80 81       	ld	r24, Z
    25b0:	8f 5f       	subi	r24, 0xFF	; 255
    25b2:	ed 81       	ldd	r30, Y+5	; 0x05
    25b4:	fe 81       	ldd	r31, Y+6	; 0x06
    25b6:	80 83       	st	Z, r24
}
    25b8:	28 96       	adiw	r28, 0x08	; 8
    25ba:	0f b6       	in	r0, 0x3f	; 63
    25bc:	f8 94       	cli
    25be:	de bf       	out	0x3e, r29	; 62
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	cd bf       	out	0x3d, r28	; 61
    25c4:	cf 91       	pop	r28
    25c6:	df 91       	pop	r29
    25c8:	08 95       	ret

000025ca <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    25ca:	df 93       	push	r29
    25cc:	cf 93       	push	r28
    25ce:	00 d0       	rcall	.+0      	; 0x25d0 <vListRemove+0x6>
    25d0:	00 d0       	rcall	.+0      	; 0x25d2 <vListRemove+0x8>
    25d2:	cd b7       	in	r28, 0x3d	; 61
    25d4:	de b7       	in	r29, 0x3e	; 62
    25d6:	9c 83       	std	Y+4, r25	; 0x04
    25d8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    25da:	eb 81       	ldd	r30, Y+3	; 0x03
    25dc:	fc 81       	ldd	r31, Y+4	; 0x04
    25de:	a2 81       	ldd	r26, Z+2	; 0x02
    25e0:	b3 81       	ldd	r27, Z+3	; 0x03
    25e2:	eb 81       	ldd	r30, Y+3	; 0x03
    25e4:	fc 81       	ldd	r31, Y+4	; 0x04
    25e6:	84 81       	ldd	r24, Z+4	; 0x04
    25e8:	95 81       	ldd	r25, Z+5	; 0x05
    25ea:	15 96       	adiw	r26, 0x05	; 5
    25ec:	9c 93       	st	X, r25
    25ee:	8e 93       	st	-X, r24
    25f0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    25f2:	eb 81       	ldd	r30, Y+3	; 0x03
    25f4:	fc 81       	ldd	r31, Y+4	; 0x04
    25f6:	a4 81       	ldd	r26, Z+4	; 0x04
    25f8:	b5 81       	ldd	r27, Z+5	; 0x05
    25fa:	eb 81       	ldd	r30, Y+3	; 0x03
    25fc:	fc 81       	ldd	r31, Y+4	; 0x04
    25fe:	82 81       	ldd	r24, Z+2	; 0x02
    2600:	93 81       	ldd	r25, Z+3	; 0x03
    2602:	13 96       	adiw	r26, 0x03	; 3
    2604:	9c 93       	st	X, r25
    2606:	8e 93       	st	-X, r24
    2608:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    260a:	eb 81       	ldd	r30, Y+3	; 0x03
    260c:	fc 81       	ldd	r31, Y+4	; 0x04
    260e:	80 85       	ldd	r24, Z+8	; 0x08
    2610:	91 85       	ldd	r25, Z+9	; 0x09
    2612:	9a 83       	std	Y+2, r25	; 0x02
    2614:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2616:	e9 81       	ldd	r30, Y+1	; 0x01
    2618:	fa 81       	ldd	r31, Y+2	; 0x02
    261a:	21 81       	ldd	r18, Z+1	; 0x01
    261c:	32 81       	ldd	r19, Z+2	; 0x02
    261e:	8b 81       	ldd	r24, Y+3	; 0x03
    2620:	9c 81       	ldd	r25, Y+4	; 0x04
    2622:	28 17       	cp	r18, r24
    2624:	39 07       	cpc	r19, r25
    2626:	41 f4       	brne	.+16     	; 0x2638 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2628:	eb 81       	ldd	r30, Y+3	; 0x03
    262a:	fc 81       	ldd	r31, Y+4	; 0x04
    262c:	84 81       	ldd	r24, Z+4	; 0x04
    262e:	95 81       	ldd	r25, Z+5	; 0x05
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	92 83       	std	Z+2, r25	; 0x02
    2636:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    2638:	eb 81       	ldd	r30, Y+3	; 0x03
    263a:	fc 81       	ldd	r31, Y+4	; 0x04
    263c:	11 86       	std	Z+9, r1	; 0x09
    263e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2640:	e9 81       	ldd	r30, Y+1	; 0x01
    2642:	fa 81       	ldd	r31, Y+2	; 0x02
    2644:	80 81       	ld	r24, Z
    2646:	81 50       	subi	r24, 0x01	; 1
    2648:	e9 81       	ldd	r30, Y+1	; 0x01
    264a:	fa 81       	ldd	r31, Y+2	; 0x02
    264c:	80 83       	st	Z, r24
}
    264e:	0f 90       	pop	r0
    2650:	0f 90       	pop	r0
    2652:	0f 90       	pop	r0
    2654:	0f 90       	pop	r0
    2656:	cf 91       	pop	r28
    2658:	df 91       	pop	r29
    265a:	08 95       	ret

0000265c <main>:
void Task1_Temp(void*PTR);
void Task2_LDR(void*Prt);



int main(void){
    265c:	af 92       	push	r10
    265e:	bf 92       	push	r11
    2660:	cf 92       	push	r12
    2662:	df 92       	push	r13
    2664:	ef 92       	push	r14
    2666:	ff 92       	push	r15
    2668:	0f 93       	push	r16
    266a:	df 93       	push	r29
    266c:	cf 93       	push	r28
    266e:	cd b7       	in	r28, 0x3d	; 61
    2670:	de b7       	in	r29, 0x3e	; 62

	Init();
    2672:	0e 94 6b 13 	call	0x26d6	; 0x26d6 <Init>


  xTaskCreate(&Task1_Temp,NULL,300,NULL,2,NULL);
    2676:	8a e8       	ldi	r24, 0x8A	; 138
    2678:	93 e1       	ldi	r25, 0x13	; 19
    267a:	60 e0       	ldi	r22, 0x00	; 0
    267c:	70 e0       	ldi	r23, 0x00	; 0
    267e:	4c e2       	ldi	r20, 0x2C	; 44
    2680:	51 e0       	ldi	r21, 0x01	; 1
    2682:	20 e0       	ldi	r18, 0x00	; 0
    2684:	30 e0       	ldi	r19, 0x00	; 0
    2686:	02 e0       	ldi	r16, 0x02	; 2
    2688:	ee 24       	eor	r14, r14
    268a:	ff 24       	eor	r15, r15
    268c:	cc 24       	eor	r12, r12
    268e:	dd 24       	eor	r13, r13
    2690:	aa 24       	eor	r10, r10
    2692:	bb 24       	eor	r11, r11
    2694:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <xTaskGenericCreate>
 xTaskCreate(&Task2_LDR,NULL,300,NULL,1,NULL);
    2698:	8f ec       	ldi	r24, 0xCF	; 207
    269a:	93 e1       	ldi	r25, 0x13	; 19
    269c:	60 e0       	ldi	r22, 0x00	; 0
    269e:	70 e0       	ldi	r23, 0x00	; 0
    26a0:	4c e2       	ldi	r20, 0x2C	; 44
    26a2:	51 e0       	ldi	r21, 0x01	; 1
    26a4:	20 e0       	ldi	r18, 0x00	; 0
    26a6:	30 e0       	ldi	r19, 0x00	; 0
    26a8:	01 e0       	ldi	r16, 0x01	; 1
    26aa:	ee 24       	eor	r14, r14
    26ac:	ff 24       	eor	r15, r15
    26ae:	cc 24       	eor	r12, r12
    26b0:	dd 24       	eor	r13, r13
    26b2:	aa 24       	eor	r10, r10
    26b4:	bb 24       	eor	r11, r11
    26b6:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <xTaskGenericCreate>



	vTaskStartScheduler();
    26ba:	0e 94 62 1d 	call	0x3ac4	; 0x3ac4 <vTaskStartScheduler>

	return 0;
    26be:	80 e0       	ldi	r24, 0x00	; 0
    26c0:	90 e0       	ldi	r25, 0x00	; 0
}
    26c2:	cf 91       	pop	r28
    26c4:	df 91       	pop	r29
    26c6:	0f 91       	pop	r16
    26c8:	ff 90       	pop	r15
    26ca:	ef 90       	pop	r14
    26cc:	df 90       	pop	r13
    26ce:	cf 90       	pop	r12
    26d0:	bf 90       	pop	r11
    26d2:	af 90       	pop	r10
    26d4:	08 95       	ret

000026d6 <Init>:





void Init(void){
    26d6:	df 93       	push	r29
    26d8:	cf 93       	push	r28
    26da:	cd b7       	in	r28, 0x3d	; 61
    26dc:	de b7       	in	r29, 0x3e	; 62

	ADC_VidInit();
    26de:	0e 94 b9 05 	call	0xb72	; 0xb72 <ADC_VidInit>
	LCD_VidInit();
    26e2:	0e 94 05 0b 	call	0x160a	; 0x160a <LCD_VidInit>

	LCD_VidWriteCommand(CLR);
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <LCD_VidWriteCommand>
	LCD_VidWriteString("TEMP = ");
    26ec:	80 e6       	ldi	r24, 0x60	; 96
    26ee:	90 e0       	ldi	r25, 0x00	; 0
    26f0:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <LCD_VidWriteString>
	LCD_VidSetDdram(1,11);
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	6b e0       	ldi	r22, 0x0B	; 11
    26f8:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <LCD_VidSetDdram>
	LCD_VidWriteString("C");
    26fc:	88 e6       	ldi	r24, 0x68	; 104
    26fe:	90 e0       	ldi	r25, 0x00	; 0
    2700:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <LCD_VidWriteString>
	DIO_VidSetPinDirection(0,PIN3,OUTPUT);
    2704:	80 e0       	ldi	r24, 0x00	; 0
    2706:	63 e0       	ldi	r22, 0x03	; 3
    2708:	41 e0       	ldi	r20, 0x01	; 1
    270a:	0e 94 8c 06 	call	0xd18	; 0xd18 <DIO_VidSetPinDirection>


}
    270e:	cf 91       	pop	r28
    2710:	df 91       	pop	r29
    2712:	08 95       	ret

00002714 <Task1_Temp>:

void Task1_Temp(void*PTR){
    2714:	df 93       	push	r29
    2716:	cf 93       	push	r28
    2718:	00 d0       	rcall	.+0      	; 0x271a <Task1_Temp+0x6>
    271a:	00 d0       	rcall	.+0      	; 0x271c <Task1_Temp+0x8>
    271c:	cd b7       	in	r28, 0x3d	; 61
    271e:	de b7       	in	r29, 0x3e	; 62
    2720:	9c 83       	std	Y+4, r25	; 0x04
    2722:	8b 83       	std	Y+3, r24	; 0x03

u16 Analog=0;
    2724:	1a 82       	std	Y+2, r1	; 0x02
    2726:	19 82       	std	Y+1, r1	; 0x01
	while(1){

		Analog=ADC_VidGetReadingPooling(ADC0);
    2728:	80 e0       	ldi	r24, 0x00	; 0
    272a:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <ADC_VidGetReadingPooling>
    272e:	9a 83       	std	Y+2, r25	; 0x02
    2730:	89 83       	std	Y+1, r24	; 0x01

		Analog=(Analog*5000UL)/(1024);
    2732:	89 81       	ldd	r24, Y+1	; 0x01
    2734:	9a 81       	ldd	r25, Y+2	; 0x02
    2736:	cc 01       	movw	r24, r24
    2738:	a0 e0       	ldi	r26, 0x00	; 0
    273a:	b0 e0       	ldi	r27, 0x00	; 0
    273c:	28 e8       	ldi	r18, 0x88	; 136
    273e:	33 e1       	ldi	r19, 0x13	; 19
    2740:	40 e0       	ldi	r20, 0x00	; 0
    2742:	50 e0       	ldi	r21, 0x00	; 0
    2744:	bc 01       	movw	r22, r24
    2746:	cd 01       	movw	r24, r26
    2748:	0e 94 54 22 	call	0x44a8	; 0x44a8 <__mulsi3>
    274c:	dc 01       	movw	r26, r24
    274e:	cb 01       	movw	r24, r22
    2750:	07 2e       	mov	r0, r23
    2752:	7a e0       	ldi	r23, 0x0A	; 10
    2754:	b6 95       	lsr	r27
    2756:	a7 95       	ror	r26
    2758:	97 95       	ror	r25
    275a:	87 95       	ror	r24
    275c:	7a 95       	dec	r23
    275e:	d1 f7       	brne	.-12     	; 0x2754 <Task1_Temp+0x40>
    2760:	70 2d       	mov	r23, r0
    2762:	9a 83       	std	Y+2, r25	; 0x02
    2764:	89 83       	std	Y+1, r24	; 0x01
		Analog/=10;
    2766:	89 81       	ldd	r24, Y+1	; 0x01
    2768:	9a 81       	ldd	r25, Y+2	; 0x02
    276a:	2a e0       	ldi	r18, 0x0A	; 10
    276c:	30 e0       	ldi	r19, 0x00	; 0
    276e:	b9 01       	movw	r22, r18
    2770:	0e 94 73 22 	call	0x44e6	; 0x44e6 <__udivmodhi4>
    2774:	cb 01       	movw	r24, r22
    2776:	9a 83       	std	Y+2, r25	; 0x02
    2778:	89 83       	std	Y+1, r24	; 0x01
		LCD_VidSetDdram(1,7);
    277a:	81 e0       	ldi	r24, 0x01	; 1
    277c:	67 e0       	ldi	r22, 0x07	; 7
    277e:	0e 94 94 0e 	call	0x1d28	; 0x1d28 <LCD_VidSetDdram>
		LCD_VidWriteNumber(Analog);
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	9a 81       	ldd	r25, Y+2	; 0x02
    2786:	cc 01       	movw	r24, r24
    2788:	a0 e0       	ldi	r26, 0x00	; 0
    278a:	b0 e0       	ldi	r27, 0x00	; 0
    278c:	bc 01       	movw	r22, r24
    278e:	cd 01       	movw	r24, r26
    2790:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <LCD_VidWriteNumber>


		vTaskDelay(200);
    2794:	88 ec       	ldi	r24, 0xC8	; 200
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <vTaskDelay>
    279c:	c5 cf       	rjmp	.-118    	; 0x2728 <Task1_Temp+0x14>

0000279e <Task2_LDR>:

	}


}
void Task2_LDR(void*Prt){
    279e:	ef 92       	push	r14
    27a0:	ff 92       	push	r15
    27a2:	0f 93       	push	r16
    27a4:	1f 93       	push	r17
    27a6:	df 93       	push	r29
    27a8:	cf 93       	push	r28
    27aa:	00 d0       	rcall	.+0      	; 0x27ac <Task2_LDR+0xe>
    27ac:	00 d0       	rcall	.+0      	; 0x27ae <Task2_LDR+0x10>
    27ae:	cd b7       	in	r28, 0x3d	; 61
    27b0:	de b7       	in	r29, 0x3e	; 62
    27b2:	9c 83       	std	Y+4, r25	; 0x04
    27b4:	8b 83       	std	Y+3, r24	; 0x03

	u16 Analog=0;
    27b6:	1a 82       	std	Y+2, r1	; 0x02
    27b8:	19 82       	std	Y+1, r1	; 0x01
	while(1){

		//LCD_VidWriteCommand(CLR);
		//LCD_VidWriteString("LDR = ");
		Analog=ADC_VidGetReadingPooling(ADC1);
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <ADC_VidGetReadingPooling>
    27c0:	9a 83       	std	Y+2, r25	; 0x02
    27c2:	89 83       	std	Y+1, r24	; 0x01
		Analog=(Analog*5000UL)/(Analog+1000);
    27c4:	89 81       	ldd	r24, Y+1	; 0x01
    27c6:	9a 81       	ldd	r25, Y+2	; 0x02
    27c8:	cc 01       	movw	r24, r24
    27ca:	a0 e0       	ldi	r26, 0x00	; 0
    27cc:	b0 e0       	ldi	r27, 0x00	; 0
    27ce:	28 e8       	ldi	r18, 0x88	; 136
    27d0:	33 e1       	ldi	r19, 0x13	; 19
    27d2:	40 e0       	ldi	r20, 0x00	; 0
    27d4:	50 e0       	ldi	r21, 0x00	; 0
    27d6:	bc 01       	movw	r22, r24
    27d8:	cd 01       	movw	r24, r26
    27da:	0e 94 54 22 	call	0x44a8	; 0x44a8 <__mulsi3>
    27de:	7b 01       	movw	r14, r22
    27e0:	8c 01       	movw	r16, r24
    27e2:	89 81       	ldd	r24, Y+1	; 0x01
    27e4:	9a 81       	ldd	r25, Y+2	; 0x02
    27e6:	88 51       	subi	r24, 0x18	; 24
    27e8:	9c 4f       	sbci	r25, 0xFC	; 252
    27ea:	9c 01       	movw	r18, r24
    27ec:	40 e0       	ldi	r20, 0x00	; 0
    27ee:	50 e0       	ldi	r21, 0x00	; 0
    27f0:	c8 01       	movw	r24, r16
    27f2:	b7 01       	movw	r22, r14
    27f4:	0e 94 87 22 	call	0x450e	; 0x450e <__udivmodsi4>
    27f8:	da 01       	movw	r26, r20
    27fa:	c9 01       	movw	r24, r18
    27fc:	9a 83       	std	Y+2, r25	; 0x02
    27fe:	89 83       	std	Y+1, r24	; 0x01

		if(Analog>=2000){
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	27 e0       	ldi	r18, 0x07	; 7
    2806:	80 3d       	cpi	r24, 0xD0	; 208
    2808:	92 07       	cpc	r25, r18
    280a:	30 f0       	brcs	.+12     	; 0x2818 <Task2_LDR+0x7a>
			DIO_VidSetPinValue(0,3,LOW);
    280c:	80 e0       	ldi	r24, 0x00	; 0
    280e:	63 e0       	ldi	r22, 0x03	; 3
    2810:	40 e0       	ldi	r20, 0x00	; 0
    2812:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
    2816:	05 c0       	rjmp	.+10     	; 0x2822 <Task2_LDR+0x84>
		}
		else{
			//DIO_VidTogBit(0,3);
			DIO_VidSetPinValue(0,3,HIGH);
    2818:	80 e0       	ldi	r24, 0x00	; 0
    281a:	63 e0       	ldi	r22, 0x03	; 3
    281c:	41 e0       	ldi	r20, 0x01	; 1
    281e:	0e 94 8c 07 	call	0xf18	; 0xf18 <DIO_VidSetPinValue>
		}

		vTaskDelay(300);
    2822:	8c e2       	ldi	r24, 0x2C	; 44
    2824:	91 e0       	ldi	r25, 0x01	; 1
    2826:	0e 94 2d 1d 	call	0x3a5a	; 0x3a5a <vTaskDelay>
    282a:	c7 cf       	rjmp	.-114    	; 0x27ba <Task2_LDR+0x1c>

0000282c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    282c:	df 93       	push	r29
    282e:	cf 93       	push	r28
    2830:	cd b7       	in	r28, 0x3d	; 61
    2832:	de b7       	in	r29, 0x3e	; 62
    2834:	28 97       	sbiw	r28, 0x08	; 8
    2836:	0f b6       	in	r0, 0x3f	; 63
    2838:	f8 94       	cli
    283a:	de bf       	out	0x3e, r29	; 62
    283c:	0f be       	out	0x3f, r0	; 63
    283e:	cd bf       	out	0x3d, r28	; 61
    2840:	9c 83       	std	Y+4, r25	; 0x04
    2842:	8b 83       	std	Y+3, r24	; 0x03
    2844:	7e 83       	std	Y+6, r23	; 0x06
    2846:	6d 83       	std	Y+5, r22	; 0x05
    2848:	58 87       	std	Y+8, r21	; 0x08
    284a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    284c:	eb 81       	ldd	r30, Y+3	; 0x03
    284e:	fc 81       	ldd	r31, Y+4	; 0x04
    2850:	81 e1       	ldi	r24, 0x11	; 17
    2852:	80 83       	st	Z, r24
	pxTopOfStack--;
    2854:	8b 81       	ldd	r24, Y+3	; 0x03
    2856:	9c 81       	ldd	r25, Y+4	; 0x04
    2858:	01 97       	sbiw	r24, 0x01	; 1
    285a:	9c 83       	std	Y+4, r25	; 0x04
    285c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    285e:	eb 81       	ldd	r30, Y+3	; 0x03
    2860:	fc 81       	ldd	r31, Y+4	; 0x04
    2862:	82 e2       	ldi	r24, 0x22	; 34
    2864:	80 83       	st	Z, r24
	pxTopOfStack--;
    2866:	8b 81       	ldd	r24, Y+3	; 0x03
    2868:	9c 81       	ldd	r25, Y+4	; 0x04
    286a:	01 97       	sbiw	r24, 0x01	; 1
    286c:	9c 83       	std	Y+4, r25	; 0x04
    286e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    2870:	eb 81       	ldd	r30, Y+3	; 0x03
    2872:	fc 81       	ldd	r31, Y+4	; 0x04
    2874:	83 e3       	ldi	r24, 0x33	; 51
    2876:	80 83       	st	Z, r24
	pxTopOfStack--;
    2878:	8b 81       	ldd	r24, Y+3	; 0x03
    287a:	9c 81       	ldd	r25, Y+4	; 0x04
    287c:	01 97       	sbiw	r24, 0x01	; 1
    287e:	9c 83       	std	Y+4, r25	; 0x04
    2880:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    2882:	8d 81       	ldd	r24, Y+5	; 0x05
    2884:	9e 81       	ldd	r25, Y+6	; 0x06
    2886:	9a 83       	std	Y+2, r25	; 0x02
    2888:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    288a:	89 81       	ldd	r24, Y+1	; 0x01
    288c:	eb 81       	ldd	r30, Y+3	; 0x03
    288e:	fc 81       	ldd	r31, Y+4	; 0x04
    2890:	80 83       	st	Z, r24
	pxTopOfStack--;
    2892:	8b 81       	ldd	r24, Y+3	; 0x03
    2894:	9c 81       	ldd	r25, Y+4	; 0x04
    2896:	01 97       	sbiw	r24, 0x01	; 1
    2898:	9c 83       	std	Y+4, r25	; 0x04
    289a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    289c:	89 81       	ldd	r24, Y+1	; 0x01
    289e:	9a 81       	ldd	r25, Y+2	; 0x02
    28a0:	89 2f       	mov	r24, r25
    28a2:	99 27       	eor	r25, r25
    28a4:	9a 83       	std	Y+2, r25	; 0x02
    28a6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	eb 81       	ldd	r30, Y+3	; 0x03
    28ac:	fc 81       	ldd	r31, Y+4	; 0x04
    28ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    28b0:	8b 81       	ldd	r24, Y+3	; 0x03
    28b2:	9c 81       	ldd	r25, Y+4	; 0x04
    28b4:	01 97       	sbiw	r24, 0x01	; 1
    28b6:	9c 83       	std	Y+4, r25	; 0x04
    28b8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    28ba:	eb 81       	ldd	r30, Y+3	; 0x03
    28bc:	fc 81       	ldd	r31, Y+4	; 0x04
    28be:	10 82       	st	Z, r1
	pxTopOfStack--;
    28c0:	8b 81       	ldd	r24, Y+3	; 0x03
    28c2:	9c 81       	ldd	r25, Y+4	; 0x04
    28c4:	01 97       	sbiw	r24, 0x01	; 1
    28c6:	9c 83       	std	Y+4, r25	; 0x04
    28c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    28ca:	eb 81       	ldd	r30, Y+3	; 0x03
    28cc:	fc 81       	ldd	r31, Y+4	; 0x04
    28ce:	80 e8       	ldi	r24, 0x80	; 128
    28d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    28d2:	8b 81       	ldd	r24, Y+3	; 0x03
    28d4:	9c 81       	ldd	r25, Y+4	; 0x04
    28d6:	01 97       	sbiw	r24, 0x01	; 1
    28d8:	9c 83       	std	Y+4, r25	; 0x04
    28da:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    28dc:	eb 81       	ldd	r30, Y+3	; 0x03
    28de:	fc 81       	ldd	r31, Y+4	; 0x04
    28e0:	10 82       	st	Z, r1
	pxTopOfStack--;
    28e2:	8b 81       	ldd	r24, Y+3	; 0x03
    28e4:	9c 81       	ldd	r25, Y+4	; 0x04
    28e6:	01 97       	sbiw	r24, 0x01	; 1
    28e8:	9c 83       	std	Y+4, r25	; 0x04
    28ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    28ec:	eb 81       	ldd	r30, Y+3	; 0x03
    28ee:	fc 81       	ldd	r31, Y+4	; 0x04
    28f0:	82 e0       	ldi	r24, 0x02	; 2
    28f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    28f4:	8b 81       	ldd	r24, Y+3	; 0x03
    28f6:	9c 81       	ldd	r25, Y+4	; 0x04
    28f8:	01 97       	sbiw	r24, 0x01	; 1
    28fa:	9c 83       	std	Y+4, r25	; 0x04
    28fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    28fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2900:	fc 81       	ldd	r31, Y+4	; 0x04
    2902:	83 e0       	ldi	r24, 0x03	; 3
    2904:	80 83       	st	Z, r24
	pxTopOfStack--;
    2906:	8b 81       	ldd	r24, Y+3	; 0x03
    2908:	9c 81       	ldd	r25, Y+4	; 0x04
    290a:	01 97       	sbiw	r24, 0x01	; 1
    290c:	9c 83       	std	Y+4, r25	; 0x04
    290e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    2910:	eb 81       	ldd	r30, Y+3	; 0x03
    2912:	fc 81       	ldd	r31, Y+4	; 0x04
    2914:	84 e0       	ldi	r24, 0x04	; 4
    2916:	80 83       	st	Z, r24
	pxTopOfStack--;
    2918:	8b 81       	ldd	r24, Y+3	; 0x03
    291a:	9c 81       	ldd	r25, Y+4	; 0x04
    291c:	01 97       	sbiw	r24, 0x01	; 1
    291e:	9c 83       	std	Y+4, r25	; 0x04
    2920:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    2922:	eb 81       	ldd	r30, Y+3	; 0x03
    2924:	fc 81       	ldd	r31, Y+4	; 0x04
    2926:	85 e0       	ldi	r24, 0x05	; 5
    2928:	80 83       	st	Z, r24
	pxTopOfStack--;
    292a:	8b 81       	ldd	r24, Y+3	; 0x03
    292c:	9c 81       	ldd	r25, Y+4	; 0x04
    292e:	01 97       	sbiw	r24, 0x01	; 1
    2930:	9c 83       	std	Y+4, r25	; 0x04
    2932:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    2934:	eb 81       	ldd	r30, Y+3	; 0x03
    2936:	fc 81       	ldd	r31, Y+4	; 0x04
    2938:	86 e0       	ldi	r24, 0x06	; 6
    293a:	80 83       	st	Z, r24
	pxTopOfStack--;
    293c:	8b 81       	ldd	r24, Y+3	; 0x03
    293e:	9c 81       	ldd	r25, Y+4	; 0x04
    2940:	01 97       	sbiw	r24, 0x01	; 1
    2942:	9c 83       	std	Y+4, r25	; 0x04
    2944:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2946:	eb 81       	ldd	r30, Y+3	; 0x03
    2948:	fc 81       	ldd	r31, Y+4	; 0x04
    294a:	87 e0       	ldi	r24, 0x07	; 7
    294c:	80 83       	st	Z, r24
	pxTopOfStack--;
    294e:	8b 81       	ldd	r24, Y+3	; 0x03
    2950:	9c 81       	ldd	r25, Y+4	; 0x04
    2952:	01 97       	sbiw	r24, 0x01	; 1
    2954:	9c 83       	std	Y+4, r25	; 0x04
    2956:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    2958:	eb 81       	ldd	r30, Y+3	; 0x03
    295a:	fc 81       	ldd	r31, Y+4	; 0x04
    295c:	88 e0       	ldi	r24, 0x08	; 8
    295e:	80 83       	st	Z, r24
	pxTopOfStack--;
    2960:	8b 81       	ldd	r24, Y+3	; 0x03
    2962:	9c 81       	ldd	r25, Y+4	; 0x04
    2964:	01 97       	sbiw	r24, 0x01	; 1
    2966:	9c 83       	std	Y+4, r25	; 0x04
    2968:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    296a:	eb 81       	ldd	r30, Y+3	; 0x03
    296c:	fc 81       	ldd	r31, Y+4	; 0x04
    296e:	89 e0       	ldi	r24, 0x09	; 9
    2970:	80 83       	st	Z, r24
	pxTopOfStack--;
    2972:	8b 81       	ldd	r24, Y+3	; 0x03
    2974:	9c 81       	ldd	r25, Y+4	; 0x04
    2976:	01 97       	sbiw	r24, 0x01	; 1
    2978:	9c 83       	std	Y+4, r25	; 0x04
    297a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    297c:	eb 81       	ldd	r30, Y+3	; 0x03
    297e:	fc 81       	ldd	r31, Y+4	; 0x04
    2980:	80 e1       	ldi	r24, 0x10	; 16
    2982:	80 83       	st	Z, r24
	pxTopOfStack--;
    2984:	8b 81       	ldd	r24, Y+3	; 0x03
    2986:	9c 81       	ldd	r25, Y+4	; 0x04
    2988:	01 97       	sbiw	r24, 0x01	; 1
    298a:	9c 83       	std	Y+4, r25	; 0x04
    298c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    298e:	eb 81       	ldd	r30, Y+3	; 0x03
    2990:	fc 81       	ldd	r31, Y+4	; 0x04
    2992:	81 e1       	ldi	r24, 0x11	; 17
    2994:	80 83       	st	Z, r24
	pxTopOfStack--;
    2996:	8b 81       	ldd	r24, Y+3	; 0x03
    2998:	9c 81       	ldd	r25, Y+4	; 0x04
    299a:	01 97       	sbiw	r24, 0x01	; 1
    299c:	9c 83       	std	Y+4, r25	; 0x04
    299e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    29a0:	eb 81       	ldd	r30, Y+3	; 0x03
    29a2:	fc 81       	ldd	r31, Y+4	; 0x04
    29a4:	82 e1       	ldi	r24, 0x12	; 18
    29a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    29a8:	8b 81       	ldd	r24, Y+3	; 0x03
    29aa:	9c 81       	ldd	r25, Y+4	; 0x04
    29ac:	01 97       	sbiw	r24, 0x01	; 1
    29ae:	9c 83       	std	Y+4, r25	; 0x04
    29b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    29b2:	eb 81       	ldd	r30, Y+3	; 0x03
    29b4:	fc 81       	ldd	r31, Y+4	; 0x04
    29b6:	83 e1       	ldi	r24, 0x13	; 19
    29b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    29ba:	8b 81       	ldd	r24, Y+3	; 0x03
    29bc:	9c 81       	ldd	r25, Y+4	; 0x04
    29be:	01 97       	sbiw	r24, 0x01	; 1
    29c0:	9c 83       	std	Y+4, r25	; 0x04
    29c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    29c4:	eb 81       	ldd	r30, Y+3	; 0x03
    29c6:	fc 81       	ldd	r31, Y+4	; 0x04
    29c8:	84 e1       	ldi	r24, 0x14	; 20
    29ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    29cc:	8b 81       	ldd	r24, Y+3	; 0x03
    29ce:	9c 81       	ldd	r25, Y+4	; 0x04
    29d0:	01 97       	sbiw	r24, 0x01	; 1
    29d2:	9c 83       	std	Y+4, r25	; 0x04
    29d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    29d6:	eb 81       	ldd	r30, Y+3	; 0x03
    29d8:	fc 81       	ldd	r31, Y+4	; 0x04
    29da:	85 e1       	ldi	r24, 0x15	; 21
    29dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    29de:	8b 81       	ldd	r24, Y+3	; 0x03
    29e0:	9c 81       	ldd	r25, Y+4	; 0x04
    29e2:	01 97       	sbiw	r24, 0x01	; 1
    29e4:	9c 83       	std	Y+4, r25	; 0x04
    29e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    29e8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ea:	fc 81       	ldd	r31, Y+4	; 0x04
    29ec:	86 e1       	ldi	r24, 0x16	; 22
    29ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    29f0:	8b 81       	ldd	r24, Y+3	; 0x03
    29f2:	9c 81       	ldd	r25, Y+4	; 0x04
    29f4:	01 97       	sbiw	r24, 0x01	; 1
    29f6:	9c 83       	std	Y+4, r25	; 0x04
    29f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    29fa:	eb 81       	ldd	r30, Y+3	; 0x03
    29fc:	fc 81       	ldd	r31, Y+4	; 0x04
    29fe:	87 e1       	ldi	r24, 0x17	; 23
    2a00:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a02:	8b 81       	ldd	r24, Y+3	; 0x03
    2a04:	9c 81       	ldd	r25, Y+4	; 0x04
    2a06:	01 97       	sbiw	r24, 0x01	; 1
    2a08:	9c 83       	std	Y+4, r25	; 0x04
    2a0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    2a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a10:	88 e1       	ldi	r24, 0x18	; 24
    2a12:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a14:	8b 81       	ldd	r24, Y+3	; 0x03
    2a16:	9c 81       	ldd	r25, Y+4	; 0x04
    2a18:	01 97       	sbiw	r24, 0x01	; 1
    2a1a:	9c 83       	std	Y+4, r25	; 0x04
    2a1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a20:	fc 81       	ldd	r31, Y+4	; 0x04
    2a22:	89 e1       	ldi	r24, 0x19	; 25
    2a24:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a26:	8b 81       	ldd	r24, Y+3	; 0x03
    2a28:	9c 81       	ldd	r25, Y+4	; 0x04
    2a2a:	01 97       	sbiw	r24, 0x01	; 1
    2a2c:	9c 83       	std	Y+4, r25	; 0x04
    2a2e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    2a30:	eb 81       	ldd	r30, Y+3	; 0x03
    2a32:	fc 81       	ldd	r31, Y+4	; 0x04
    2a34:	80 e2       	ldi	r24, 0x20	; 32
    2a36:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a38:	8b 81       	ldd	r24, Y+3	; 0x03
    2a3a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a3c:	01 97       	sbiw	r24, 0x01	; 1
    2a3e:	9c 83       	std	Y+4, r25	; 0x04
    2a40:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2a42:	eb 81       	ldd	r30, Y+3	; 0x03
    2a44:	fc 81       	ldd	r31, Y+4	; 0x04
    2a46:	81 e2       	ldi	r24, 0x21	; 33
    2a48:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4e:	01 97       	sbiw	r24, 0x01	; 1
    2a50:	9c 83       	std	Y+4, r25	; 0x04
    2a52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    2a54:	eb 81       	ldd	r30, Y+3	; 0x03
    2a56:	fc 81       	ldd	r31, Y+4	; 0x04
    2a58:	82 e2       	ldi	r24, 0x22	; 34
    2a5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a60:	01 97       	sbiw	r24, 0x01	; 1
    2a62:	9c 83       	std	Y+4, r25	; 0x04
    2a64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2a66:	eb 81       	ldd	r30, Y+3	; 0x03
    2a68:	fc 81       	ldd	r31, Y+4	; 0x04
    2a6a:	83 e2       	ldi	r24, 0x23	; 35
    2a6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a70:	9c 81       	ldd	r25, Y+4	; 0x04
    2a72:	01 97       	sbiw	r24, 0x01	; 1
    2a74:	9c 83       	std	Y+4, r25	; 0x04
    2a76:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    2a78:	8f 81       	ldd	r24, Y+7	; 0x07
    2a7a:	98 85       	ldd	r25, Y+8	; 0x08
    2a7c:	9a 83       	std	Y+2, r25	; 0x02
    2a7e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2a80:	89 81       	ldd	r24, Y+1	; 0x01
    2a82:	eb 81       	ldd	r30, Y+3	; 0x03
    2a84:	fc 81       	ldd	r31, Y+4	; 0x04
    2a86:	80 83       	st	Z, r24
	pxTopOfStack--;
    2a88:	8b 81       	ldd	r24, Y+3	; 0x03
    2a8a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a8c:	01 97       	sbiw	r24, 0x01	; 1
    2a8e:	9c 83       	std	Y+4, r25	; 0x04
    2a90:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    2a92:	89 81       	ldd	r24, Y+1	; 0x01
    2a94:	9a 81       	ldd	r25, Y+2	; 0x02
    2a96:	89 2f       	mov	r24, r25
    2a98:	99 27       	eor	r25, r25
    2a9a:	9a 83       	std	Y+2, r25	; 0x02
    2a9c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2a9e:	89 81       	ldd	r24, Y+1	; 0x01
    2aa0:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa2:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa4:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aa6:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa8:	9c 81       	ldd	r25, Y+4	; 0x04
    2aaa:	01 97       	sbiw	r24, 0x01	; 1
    2aac:	9c 83       	std	Y+4, r25	; 0x04
    2aae:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab4:	86 e2       	ldi	r24, 0x26	; 38
    2ab6:	80 83       	st	Z, r24
	pxTopOfStack--;
    2ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aba:	9c 81       	ldd	r25, Y+4	; 0x04
    2abc:	01 97       	sbiw	r24, 0x01	; 1
    2abe:	9c 83       	std	Y+4, r25	; 0x04
    2ac0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    2ac2:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac4:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac6:	87 e2       	ldi	r24, 0x27	; 39
    2ac8:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aca:	8b 81       	ldd	r24, Y+3	; 0x03
    2acc:	9c 81       	ldd	r25, Y+4	; 0x04
    2ace:	01 97       	sbiw	r24, 0x01	; 1
    2ad0:	9c 83       	std	Y+4, r25	; 0x04
    2ad2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    2ad4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad8:	88 e2       	ldi	r24, 0x28	; 40
    2ada:	80 83       	st	Z, r24
	pxTopOfStack--;
    2adc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ade:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae0:	01 97       	sbiw	r24, 0x01	; 1
    2ae2:	9c 83       	std	Y+4, r25	; 0x04
    2ae4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    2ae6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aea:	89 e2       	ldi	r24, 0x29	; 41
    2aec:	80 83       	st	Z, r24
	pxTopOfStack--;
    2aee:	8b 81       	ldd	r24, Y+3	; 0x03
    2af0:	9c 81       	ldd	r25, Y+4	; 0x04
    2af2:	01 97       	sbiw	r24, 0x01	; 1
    2af4:	9c 83       	std	Y+4, r25	; 0x04
    2af6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    2af8:	eb 81       	ldd	r30, Y+3	; 0x03
    2afa:	fc 81       	ldd	r31, Y+4	; 0x04
    2afc:	80 e3       	ldi	r24, 0x30	; 48
    2afe:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b00:	8b 81       	ldd	r24, Y+3	; 0x03
    2b02:	9c 81       	ldd	r25, Y+4	; 0x04
    2b04:	01 97       	sbiw	r24, 0x01	; 1
    2b06:	9c 83       	std	Y+4, r25	; 0x04
    2b08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    2b0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b0e:	81 e3       	ldi	r24, 0x31	; 49
    2b10:	80 83       	st	Z, r24
	pxTopOfStack--;
    2b12:	8b 81       	ldd	r24, Y+3	; 0x03
    2b14:	9c 81       	ldd	r25, Y+4	; 0x04
    2b16:	01 97       	sbiw	r24, 0x01	; 1
    2b18:	9c 83       	std	Y+4, r25	; 0x04
    2b1a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    2b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b1e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    2b20:	28 96       	adiw	r28, 0x08	; 8
    2b22:	0f b6       	in	r0, 0x3f	; 63
    2b24:	f8 94       	cli
    2b26:	de bf       	out	0x3e, r29	; 62
    2b28:	0f be       	out	0x3f, r0	; 63
    2b2a:	cd bf       	out	0x3d, r28	; 61
    2b2c:	cf 91       	pop	r28
    2b2e:	df 91       	pop	r29
    2b30:	08 95       	ret

00002b32 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    2b32:	df 93       	push	r29
    2b34:	cf 93       	push	r28
    2b36:	cd b7       	in	r28, 0x3d	; 61
    2b38:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    2b3a:	0e 94 89 16 	call	0x2d12	; 0x2d12 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    2b3e:	a0 91 a2 04 	lds	r26, 0x04A2
    2b42:	b0 91 a3 04 	lds	r27, 0x04A3
    2b46:	cd 91       	ld	r28, X+
    2b48:	cd bf       	out	0x3d, r28	; 61
    2b4a:	dd 91       	ld	r29, X+
    2b4c:	de bf       	out	0x3e, r29	; 62
    2b4e:	ff 91       	pop	r31
    2b50:	ef 91       	pop	r30
    2b52:	df 91       	pop	r29
    2b54:	cf 91       	pop	r28
    2b56:	bf 91       	pop	r27
    2b58:	af 91       	pop	r26
    2b5a:	9f 91       	pop	r25
    2b5c:	8f 91       	pop	r24
    2b5e:	7f 91       	pop	r23
    2b60:	6f 91       	pop	r22
    2b62:	5f 91       	pop	r21
    2b64:	4f 91       	pop	r20
    2b66:	3f 91       	pop	r19
    2b68:	2f 91       	pop	r18
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	bf 90       	pop	r11
    2b78:	af 90       	pop	r10
    2b7a:	9f 90       	pop	r9
    2b7c:	8f 90       	pop	r8
    2b7e:	7f 90       	pop	r7
    2b80:	6f 90       	pop	r6
    2b82:	5f 90       	pop	r5
    2b84:	4f 90       	pop	r4
    2b86:	3f 90       	pop	r3
    2b88:	2f 90       	pop	r2
    2b8a:	1f 90       	pop	r1
    2b8c:	0f 90       	pop	r0
    2b8e:	0f be       	out	0x3f, r0	; 63
    2b90:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2b92:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    2b94:	81 e0       	ldi	r24, 0x01	; 1
}
    2b96:	cf 91       	pop	r28
    2b98:	df 91       	pop	r29
    2b9a:	08 95       	ret

00002b9c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2b9c:	df 93       	push	r29
    2b9e:	cf 93       	push	r28
    2ba0:	cd b7       	in	r28, 0x3d	; 61
    2ba2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2ba4:	cf 91       	pop	r28
    2ba6:	df 91       	pop	r29
    2ba8:	08 95       	ret

00002baa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2baa:	0f 92       	push	r0
    2bac:	0f b6       	in	r0, 0x3f	; 63
    2bae:	f8 94       	cli
    2bb0:	0f 92       	push	r0
    2bb2:	1f 92       	push	r1
    2bb4:	11 24       	eor	r1, r1
    2bb6:	2f 92       	push	r2
    2bb8:	3f 92       	push	r3
    2bba:	4f 92       	push	r4
    2bbc:	5f 92       	push	r5
    2bbe:	6f 92       	push	r6
    2bc0:	7f 92       	push	r7
    2bc2:	8f 92       	push	r8
    2bc4:	9f 92       	push	r9
    2bc6:	af 92       	push	r10
    2bc8:	bf 92       	push	r11
    2bca:	cf 92       	push	r12
    2bcc:	df 92       	push	r13
    2bce:	ef 92       	push	r14
    2bd0:	ff 92       	push	r15
    2bd2:	0f 93       	push	r16
    2bd4:	1f 93       	push	r17
    2bd6:	2f 93       	push	r18
    2bd8:	3f 93       	push	r19
    2bda:	4f 93       	push	r20
    2bdc:	5f 93       	push	r21
    2bde:	6f 93       	push	r22
    2be0:	7f 93       	push	r23
    2be2:	8f 93       	push	r24
    2be4:	9f 93       	push	r25
    2be6:	af 93       	push	r26
    2be8:	bf 93       	push	r27
    2bea:	cf 93       	push	r28
    2bec:	df 93       	push	r29
    2bee:	ef 93       	push	r30
    2bf0:	ff 93       	push	r31
    2bf2:	a0 91 a2 04 	lds	r26, 0x04A2
    2bf6:	b0 91 a3 04 	lds	r27, 0x04A3
    2bfa:	0d b6       	in	r0, 0x3d	; 61
    2bfc:	0d 92       	st	X+, r0
    2bfe:	0e b6       	in	r0, 0x3e	; 62
    2c00:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2c02:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2c06:	a0 91 a2 04 	lds	r26, 0x04A2
    2c0a:	b0 91 a3 04 	lds	r27, 0x04A3
    2c0e:	cd 91       	ld	r28, X+
    2c10:	cd bf       	out	0x3d, r28	; 61
    2c12:	dd 91       	ld	r29, X+
    2c14:	de bf       	out	0x3e, r29	; 62
    2c16:	ff 91       	pop	r31
    2c18:	ef 91       	pop	r30
    2c1a:	df 91       	pop	r29
    2c1c:	cf 91       	pop	r28
    2c1e:	bf 91       	pop	r27
    2c20:	af 91       	pop	r26
    2c22:	9f 91       	pop	r25
    2c24:	8f 91       	pop	r24
    2c26:	7f 91       	pop	r23
    2c28:	6f 91       	pop	r22
    2c2a:	5f 91       	pop	r21
    2c2c:	4f 91       	pop	r20
    2c2e:	3f 91       	pop	r19
    2c30:	2f 91       	pop	r18
    2c32:	1f 91       	pop	r17
    2c34:	0f 91       	pop	r16
    2c36:	ff 90       	pop	r15
    2c38:	ef 90       	pop	r14
    2c3a:	df 90       	pop	r13
    2c3c:	cf 90       	pop	r12
    2c3e:	bf 90       	pop	r11
    2c40:	af 90       	pop	r10
    2c42:	9f 90       	pop	r9
    2c44:	8f 90       	pop	r8
    2c46:	7f 90       	pop	r7
    2c48:	6f 90       	pop	r6
    2c4a:	5f 90       	pop	r5
    2c4c:	4f 90       	pop	r4
    2c4e:	3f 90       	pop	r3
    2c50:	2f 90       	pop	r2
    2c52:	1f 90       	pop	r1
    2c54:	0f 90       	pop	r0
    2c56:	0f be       	out	0x3f, r0	; 63
    2c58:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c5a:	08 95       	ret

00002c5c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c5c:	0f 92       	push	r0
    2c5e:	0f b6       	in	r0, 0x3f	; 63
    2c60:	f8 94       	cli
    2c62:	0f 92       	push	r0
    2c64:	1f 92       	push	r1
    2c66:	11 24       	eor	r1, r1
    2c68:	2f 92       	push	r2
    2c6a:	3f 92       	push	r3
    2c6c:	4f 92       	push	r4
    2c6e:	5f 92       	push	r5
    2c70:	6f 92       	push	r6
    2c72:	7f 92       	push	r7
    2c74:	8f 92       	push	r8
    2c76:	9f 92       	push	r9
    2c78:	af 92       	push	r10
    2c7a:	bf 92       	push	r11
    2c7c:	cf 92       	push	r12
    2c7e:	df 92       	push	r13
    2c80:	ef 92       	push	r14
    2c82:	ff 92       	push	r15
    2c84:	0f 93       	push	r16
    2c86:	1f 93       	push	r17
    2c88:	2f 93       	push	r18
    2c8a:	3f 93       	push	r19
    2c8c:	4f 93       	push	r20
    2c8e:	5f 93       	push	r21
    2c90:	6f 93       	push	r22
    2c92:	7f 93       	push	r23
    2c94:	8f 93       	push	r24
    2c96:	9f 93       	push	r25
    2c98:	af 93       	push	r26
    2c9a:	bf 93       	push	r27
    2c9c:	cf 93       	push	r28
    2c9e:	df 93       	push	r29
    2ca0:	ef 93       	push	r30
    2ca2:	ff 93       	push	r31
    2ca4:	a0 91 a2 04 	lds	r26, 0x04A2
    2ca8:	b0 91 a3 04 	lds	r27, 0x04A3
    2cac:	0d b6       	in	r0, 0x3d	; 61
    2cae:	0d 92       	st	X+, r0
    2cb0:	0e b6       	in	r0, 0x3e	; 62
    2cb2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    2cb4:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <vTaskIncrementTick>
	vTaskSwitchContext();
    2cb8:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2cbc:	a0 91 a2 04 	lds	r26, 0x04A2
    2cc0:	b0 91 a3 04 	lds	r27, 0x04A3
    2cc4:	cd 91       	ld	r28, X+
    2cc6:	cd bf       	out	0x3d, r28	; 61
    2cc8:	dd 91       	ld	r29, X+
    2cca:	de bf       	out	0x3e, r29	; 62
    2ccc:	ff 91       	pop	r31
    2cce:	ef 91       	pop	r30
    2cd0:	df 91       	pop	r29
    2cd2:	cf 91       	pop	r28
    2cd4:	bf 91       	pop	r27
    2cd6:	af 91       	pop	r26
    2cd8:	9f 91       	pop	r25
    2cda:	8f 91       	pop	r24
    2cdc:	7f 91       	pop	r23
    2cde:	6f 91       	pop	r22
    2ce0:	5f 91       	pop	r21
    2ce2:	4f 91       	pop	r20
    2ce4:	3f 91       	pop	r19
    2ce6:	2f 91       	pop	r18
    2ce8:	1f 91       	pop	r17
    2cea:	0f 91       	pop	r16
    2cec:	ff 90       	pop	r15
    2cee:	ef 90       	pop	r14
    2cf0:	df 90       	pop	r13
    2cf2:	cf 90       	pop	r12
    2cf4:	bf 90       	pop	r11
    2cf6:	af 90       	pop	r10
    2cf8:	9f 90       	pop	r9
    2cfa:	8f 90       	pop	r8
    2cfc:	7f 90       	pop	r7
    2cfe:	6f 90       	pop	r6
    2d00:	5f 90       	pop	r5
    2d02:	4f 90       	pop	r4
    2d04:	3f 90       	pop	r3
    2d06:	2f 90       	pop	r2
    2d08:	1f 90       	pop	r1
    2d0a:	0f 90       	pop	r0
    2d0c:	0f be       	out	0x3f, r0	; 63
    2d0e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2d10:	08 95       	ret

00002d12 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    2d12:	df 93       	push	r29
    2d14:	cf 93       	push	r28
    2d16:	00 d0       	rcall	.+0      	; 0x2d18 <prvSetupTimerInterrupt+0x6>
    2d18:	00 d0       	rcall	.+0      	; 0x2d1a <prvSetupTimerInterrupt+0x8>
    2d1a:	00 d0       	rcall	.+0      	; 0x2d1c <prvSetupTimerInterrupt+0xa>
    2d1c:	cd b7       	in	r28, 0x3d	; 61
    2d1e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2d20:	80 e4       	ldi	r24, 0x40	; 64
    2d22:	9f e1       	ldi	r25, 0x1F	; 31
    2d24:	a0 e0       	ldi	r26, 0x00	; 0
    2d26:	b0 e0       	ldi	r27, 0x00	; 0
    2d28:	8b 83       	std	Y+3, r24	; 0x03
    2d2a:	9c 83       	std	Y+4, r25	; 0x04
    2d2c:	ad 83       	std	Y+5, r26	; 0x05
    2d2e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2d30:	8b 81       	ldd	r24, Y+3	; 0x03
    2d32:	9c 81       	ldd	r25, Y+4	; 0x04
    2d34:	ad 81       	ldd	r26, Y+5	; 0x05
    2d36:	be 81       	ldd	r27, Y+6	; 0x06
    2d38:	68 94       	set
    2d3a:	15 f8       	bld	r1, 5
    2d3c:	b6 95       	lsr	r27
    2d3e:	a7 95       	ror	r26
    2d40:	97 95       	ror	r25
    2d42:	87 95       	ror	r24
    2d44:	16 94       	lsr	r1
    2d46:	d1 f7       	brne	.-12     	; 0x2d3c <prvSetupTimerInterrupt+0x2a>
    2d48:	8b 83       	std	Y+3, r24	; 0x03
    2d4a:	9c 83       	std	Y+4, r25	; 0x04
    2d4c:	ad 83       	std	Y+5, r26	; 0x05
    2d4e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    2d50:	8b 81       	ldd	r24, Y+3	; 0x03
    2d52:	9c 81       	ldd	r25, Y+4	; 0x04
    2d54:	ad 81       	ldd	r26, Y+5	; 0x05
    2d56:	be 81       	ldd	r27, Y+6	; 0x06
    2d58:	01 97       	sbiw	r24, 0x01	; 1
    2d5a:	a1 09       	sbc	r26, r1
    2d5c:	b1 09       	sbc	r27, r1
    2d5e:	8b 83       	std	Y+3, r24	; 0x03
    2d60:	9c 83       	std	Y+4, r25	; 0x04
    2d62:	ad 83       	std	Y+5, r26	; 0x05
    2d64:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2d66:	8b 81       	ldd	r24, Y+3	; 0x03
    2d68:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    2d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6e:	ad 81       	ldd	r26, Y+5	; 0x05
    2d70:	be 81       	ldd	r27, Y+6	; 0x06
    2d72:	89 2f       	mov	r24, r25
    2d74:	9a 2f       	mov	r25, r26
    2d76:	ab 2f       	mov	r26, r27
    2d78:	bb 27       	eor	r27, r27
    2d7a:	8b 83       	std	Y+3, r24	; 0x03
    2d7c:	9c 83       	std	Y+4, r25	; 0x04
    2d7e:	ad 83       	std	Y+5, r26	; 0x05
    2d80:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    2d82:	8b 81       	ldd	r24, Y+3	; 0x03
    2d84:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    2d86:	eb e4       	ldi	r30, 0x4B	; 75
    2d88:	f0 e0       	ldi	r31, 0x00	; 0
    2d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d8c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    2d8e:	ea e4       	ldi	r30, 0x4A	; 74
    2d90:	f0 e0       	ldi	r31, 0x00	; 0
    2d92:	89 81       	ldd	r24, Y+1	; 0x01
    2d94:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    2d96:	8b e0       	ldi	r24, 0x0B	; 11
    2d98:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2d9a:	ee e4       	ldi	r30, 0x4E	; 78
    2d9c:	f0 e0       	ldi	r31, 0x00	; 0
    2d9e:	89 81       	ldd	r24, Y+1	; 0x01
    2da0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    2da2:	e9 e5       	ldi	r30, 0x59	; 89
    2da4:	f0 e0       	ldi	r31, 0x00	; 0
    2da6:	80 81       	ld	r24, Z
    2da8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2daa:	89 81       	ldd	r24, Y+1	; 0x01
    2dac:	80 61       	ori	r24, 0x10	; 16
    2dae:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2db0:	e9 e5       	ldi	r30, 0x59	; 89
    2db2:	f0 e0       	ldi	r31, 0x00	; 0
    2db4:	89 81       	ldd	r24, Y+1	; 0x01
    2db6:	80 83       	st	Z, r24
}
    2db8:	26 96       	adiw	r28, 0x06	; 6
    2dba:	0f b6       	in	r0, 0x3f	; 63
    2dbc:	f8 94       	cli
    2dbe:	de bf       	out	0x3e, r29	; 62
    2dc0:	0f be       	out	0x3f, r0	; 63
    2dc2:	cd bf       	out	0x3d, r28	; 61
    2dc4:	cf 91       	pop	r28
    2dc6:	df 91       	pop	r29
    2dc8:	08 95       	ret

00002dca <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2dca:	0e 94 2e 16 	call	0x2c5c	; 0x2c5c <vPortYieldFromTick>
		asm volatile ( "reti" );
    2dce:	18 95       	reti

00002dd0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2dd0:	df 93       	push	r29
    2dd2:	cf 93       	push	r28
    2dd4:	cd b7       	in	r28, 0x3d	; 61
    2dd6:	de b7       	in	r29, 0x3e	; 62
    2dd8:	28 97       	sbiw	r28, 0x08	; 8
    2dda:	0f b6       	in	r0, 0x3f	; 63
    2ddc:	f8 94       	cli
    2dde:	de bf       	out	0x3e, r29	; 62
    2de0:	0f be       	out	0x3f, r0	; 63
    2de2:	cd bf       	out	0x3d, r28	; 61
    2de4:	8f 83       	std	Y+7, r24	; 0x07
    2de6:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2de8:	1a 82       	std	Y+2, r1	; 0x02
    2dea:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2dec:	8f 81       	ldd	r24, Y+7	; 0x07
    2dee:	88 23       	and	r24, r24
    2df0:	09 f4       	brne	.+2      	; 0x2df4 <xQueueCreate+0x24>
    2df2:	8c c0       	rjmp	.+280    	; 0x2f0c <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2df4:	8f e1       	ldi	r24, 0x1F	; 31
    2df6:	90 e0       	ldi	r25, 0x00	; 0
    2df8:	0e 94 87 11 	call	0x230e	; 0x230e <pvPortMalloc>
    2dfc:	9e 83       	std	Y+6, r25	; 0x06
    2dfe:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2e00:	8d 81       	ldd	r24, Y+5	; 0x05
    2e02:	9e 81       	ldd	r25, Y+6	; 0x06
    2e04:	00 97       	sbiw	r24, 0x00	; 0
    2e06:	09 f4       	brne	.+2      	; 0x2e0a <xQueueCreate+0x3a>
    2e08:	81 c0       	rjmp	.+258    	; 0x2f0c <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2e0a:	8f 81       	ldd	r24, Y+7	; 0x07
    2e0c:	28 2f       	mov	r18, r24
    2e0e:	30 e0       	ldi	r19, 0x00	; 0
    2e10:	88 85       	ldd	r24, Y+8	; 0x08
    2e12:	88 2f       	mov	r24, r24
    2e14:	90 e0       	ldi	r25, 0x00	; 0
    2e16:	ac 01       	movw	r20, r24
    2e18:	24 9f       	mul	r18, r20
    2e1a:	c0 01       	movw	r24, r0
    2e1c:	25 9f       	mul	r18, r21
    2e1e:	90 0d       	add	r25, r0
    2e20:	34 9f       	mul	r19, r20
    2e22:	90 0d       	add	r25, r0
    2e24:	11 24       	eor	r1, r1
    2e26:	01 96       	adiw	r24, 0x01	; 1
    2e28:	9c 83       	std	Y+4, r25	; 0x04
    2e2a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e30:	0e 94 87 11 	call	0x230e	; 0x230e <pvPortMalloc>
    2e34:	ed 81       	ldd	r30, Y+5	; 0x05
    2e36:	fe 81       	ldd	r31, Y+6	; 0x06
    2e38:	91 83       	std	Z+1, r25	; 0x01
    2e3a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    2e3c:	ed 81       	ldd	r30, Y+5	; 0x05
    2e3e:	fe 81       	ldd	r31, Y+6	; 0x06
    2e40:	80 81       	ld	r24, Z
    2e42:	91 81       	ldd	r25, Z+1	; 0x01
    2e44:	00 97       	sbiw	r24, 0x00	; 0
    2e46:	09 f4       	brne	.+2      	; 0x2e4a <xQueueCreate+0x7a>
    2e48:	5d c0       	rjmp	.+186    	; 0x2f04 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    2e4a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e4c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e4e:	40 81       	ld	r20, Z
    2e50:	51 81       	ldd	r21, Z+1	; 0x01
    2e52:	8f 81       	ldd	r24, Y+7	; 0x07
    2e54:	28 2f       	mov	r18, r24
    2e56:	30 e0       	ldi	r19, 0x00	; 0
    2e58:	88 85       	ldd	r24, Y+8	; 0x08
    2e5a:	88 2f       	mov	r24, r24
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	bc 01       	movw	r22, r24
    2e60:	26 9f       	mul	r18, r22
    2e62:	c0 01       	movw	r24, r0
    2e64:	27 9f       	mul	r18, r23
    2e66:	90 0d       	add	r25, r0
    2e68:	36 9f       	mul	r19, r22
    2e6a:	90 0d       	add	r25, r0
    2e6c:	11 24       	eor	r1, r1
    2e6e:	84 0f       	add	r24, r20
    2e70:	95 1f       	adc	r25, r21
    2e72:	ed 81       	ldd	r30, Y+5	; 0x05
    2e74:	fe 81       	ldd	r31, Y+6	; 0x06
    2e76:	93 83       	std	Z+3, r25	; 0x03
    2e78:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2e7a:	ed 81       	ldd	r30, Y+5	; 0x05
    2e7c:	fe 81       	ldd	r31, Y+6	; 0x06
    2e7e:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    2e80:	ed 81       	ldd	r30, Y+5	; 0x05
    2e82:	fe 81       	ldd	r31, Y+6	; 0x06
    2e84:	80 81       	ld	r24, Z
    2e86:	91 81       	ldd	r25, Z+1	; 0x01
    2e88:	ed 81       	ldd	r30, Y+5	; 0x05
    2e8a:	fe 81       	ldd	r31, Y+6	; 0x06
    2e8c:	95 83       	std	Z+5, r25	; 0x05
    2e8e:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    2e90:	ed 81       	ldd	r30, Y+5	; 0x05
    2e92:	fe 81       	ldd	r31, Y+6	; 0x06
    2e94:	40 81       	ld	r20, Z
    2e96:	51 81       	ldd	r21, Z+1	; 0x01
    2e98:	8f 81       	ldd	r24, Y+7	; 0x07
    2e9a:	88 2f       	mov	r24, r24
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	9c 01       	movw	r18, r24
    2ea0:	21 50       	subi	r18, 0x01	; 1
    2ea2:	30 40       	sbci	r19, 0x00	; 0
    2ea4:	88 85       	ldd	r24, Y+8	; 0x08
    2ea6:	88 2f       	mov	r24, r24
    2ea8:	90 e0       	ldi	r25, 0x00	; 0
    2eaa:	bc 01       	movw	r22, r24
    2eac:	26 9f       	mul	r18, r22
    2eae:	c0 01       	movw	r24, r0
    2eb0:	27 9f       	mul	r18, r23
    2eb2:	90 0d       	add	r25, r0
    2eb4:	36 9f       	mul	r19, r22
    2eb6:	90 0d       	add	r25, r0
    2eb8:	11 24       	eor	r1, r1
    2eba:	84 0f       	add	r24, r20
    2ebc:	95 1f       	adc	r25, r21
    2ebe:	ed 81       	ldd	r30, Y+5	; 0x05
    2ec0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ec2:	97 83       	std	Z+7, r25	; 0x07
    2ec4:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    2ec6:	ed 81       	ldd	r30, Y+5	; 0x05
    2ec8:	fe 81       	ldd	r31, Y+6	; 0x06
    2eca:	8f 81       	ldd	r24, Y+7	; 0x07
    2ecc:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2ece:	ed 81       	ldd	r30, Y+5	; 0x05
    2ed0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ed2:	88 85       	ldd	r24, Y+8	; 0x08
    2ed4:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    2ed6:	ed 81       	ldd	r30, Y+5	; 0x05
    2ed8:	fe 81       	ldd	r31, Y+6	; 0x06
    2eda:	8f ef       	ldi	r24, 0xFF	; 255
    2edc:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2ede:	ed 81       	ldd	r30, Y+5	; 0x05
    2ee0:	fe 81       	ldd	r31, Y+6	; 0x06
    2ee2:	8f ef       	ldi	r24, 0xFF	; 255
    2ee4:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    2ee6:	8d 81       	ldd	r24, Y+5	; 0x05
    2ee8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eea:	08 96       	adiw	r24, 0x08	; 8
    2eec:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2ef0:	8d 81       	ldd	r24, Y+5	; 0x05
    2ef2:	9e 81       	ldd	r25, Y+6	; 0x06
    2ef4:	41 96       	adiw	r24, 0x11	; 17
    2ef6:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2efa:	8d 81       	ldd	r24, Y+5	; 0x05
    2efc:	9e 81       	ldd	r25, Y+6	; 0x06
    2efe:	9a 83       	std	Y+2, r25	; 0x02
    2f00:	89 83       	std	Y+1, r24	; 0x01
    2f02:	04 c0       	rjmp	.+8      	; 0x2f0c <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    2f04:	8d 81       	ldd	r24, Y+5	; 0x05
    2f06:	9e 81       	ldd	r25, Y+6	; 0x06
    2f08:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2f0c:	89 81       	ldd	r24, Y+1	; 0x01
    2f0e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f10:	28 96       	adiw	r28, 0x08	; 8
    2f12:	0f b6       	in	r0, 0x3f	; 63
    2f14:	f8 94       	cli
    2f16:	de bf       	out	0x3e, r29	; 62
    2f18:	0f be       	out	0x3f, r0	; 63
    2f1a:	cd bf       	out	0x3d, r28	; 61
    2f1c:	cf 91       	pop	r28
    2f1e:	df 91       	pop	r29
    2f20:	08 95       	ret

00002f22 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2f22:	df 93       	push	r29
    2f24:	cf 93       	push	r28
    2f26:	cd b7       	in	r28, 0x3d	; 61
    2f28:	de b7       	in	r29, 0x3e	; 62
    2f2a:	2c 97       	sbiw	r28, 0x0c	; 12
    2f2c:	0f b6       	in	r0, 0x3f	; 63
    2f2e:	f8 94       	cli
    2f30:	de bf       	out	0x3e, r29	; 62
    2f32:	0f be       	out	0x3f, r0	; 63
    2f34:	cd bf       	out	0x3d, r28	; 61
    2f36:	9e 83       	std	Y+6, r25	; 0x06
    2f38:	8d 83       	std	Y+5, r24	; 0x05
    2f3a:	78 87       	std	Y+8, r23	; 0x08
    2f3c:	6f 83       	std	Y+7, r22	; 0x07
    2f3e:	5a 87       	std	Y+10, r21	; 0x0a
    2f40:	49 87       	std	Y+9, r20	; 0x09
    2f42:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2f44:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2f46:	0f b6       	in	r0, 0x3f	; 63
    2f48:	f8 94       	cli
    2f4a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2f4c:	ed 81       	ldd	r30, Y+5	; 0x05
    2f4e:	fe 81       	ldd	r31, Y+6	; 0x06
    2f50:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f52:	ed 81       	ldd	r30, Y+5	; 0x05
    2f54:	fe 81       	ldd	r31, Y+6	; 0x06
    2f56:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f58:	98 17       	cp	r25, r24
    2f5a:	d8 f4       	brcc	.+54     	; 0x2f92 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2f5c:	8d 81       	ldd	r24, Y+5	; 0x05
    2f5e:	9e 81       	ldd	r25, Y+6	; 0x06
    2f60:	2f 81       	ldd	r18, Y+7	; 0x07
    2f62:	38 85       	ldd	r19, Y+8	; 0x08
    2f64:	b9 01       	movw	r22, r18
    2f66:	4b 85       	ldd	r20, Y+11	; 0x0b
    2f68:	0e 94 cc 19 	call	0x3398	; 0x3398 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f6c:	ed 81       	ldd	r30, Y+5	; 0x05
    2f6e:	fe 81       	ldd	r31, Y+6	; 0x06
    2f70:	81 89       	ldd	r24, Z+17	; 0x11
    2f72:	88 23       	and	r24, r24
    2f74:	49 f0       	breq	.+18     	; 0x2f88 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    2f76:	8d 81       	ldd	r24, Y+5	; 0x05
    2f78:	9e 81       	ldd	r25, Y+6	; 0x06
    2f7a:	41 96       	adiw	r24, 0x11	; 17
    2f7c:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    2f80:	81 30       	cpi	r24, 0x01	; 1
    2f82:	11 f4       	brne	.+4      	; 0x2f88 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    2f84:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    2f88:	0f 90       	pop	r0
    2f8a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    2f8c:	81 e0       	ldi	r24, 0x01	; 1
    2f8e:	8c 87       	std	Y+12, r24	; 0x0c
    2f90:	5c c0       	rjmp	.+184    	; 0x304a <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2f92:	89 85       	ldd	r24, Y+9	; 0x09
    2f94:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f96:	00 97       	sbiw	r24, 0x00	; 0
    2f98:	21 f4       	brne	.+8      	; 0x2fa2 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2f9a:	0f 90       	pop	r0
    2f9c:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2f9e:	1c 86       	std	Y+12, r1	; 0x0c
    2fa0:	54 c0       	rjmp	.+168    	; 0x304a <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    2fa2:	89 81       	ldd	r24, Y+1	; 0x01
    2fa4:	88 23       	and	r24, r24
    2fa6:	31 f4       	brne	.+12     	; 0x2fb4 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2fa8:	ce 01       	movw	r24, r28
    2faa:	02 96       	adiw	r24, 0x02	; 2
    2fac:	0e 94 49 20 	call	0x4092	; 0x4092 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2fb0:	81 e0       	ldi	r24, 0x01	; 1
    2fb2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    2fb4:	0f 90       	pop	r0
    2fb6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2fb8:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2fbc:	0f b6       	in	r0, 0x3f	; 63
    2fbe:	f8 94       	cli
    2fc0:	0f 92       	push	r0
    2fc2:	ed 81       	ldd	r30, Y+5	; 0x05
    2fc4:	fe 81       	ldd	r31, Y+6	; 0x06
    2fc6:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fc8:	8f 3f       	cpi	r24, 0xFF	; 255
    2fca:	19 f4       	brne	.+6      	; 0x2fd2 <xQueueGenericSend+0xb0>
    2fcc:	ed 81       	ldd	r30, Y+5	; 0x05
    2fce:	fe 81       	ldd	r31, Y+6	; 0x06
    2fd0:	15 8e       	std	Z+29, r1	; 0x1d
    2fd2:	ed 81       	ldd	r30, Y+5	; 0x05
    2fd4:	fe 81       	ldd	r31, Y+6	; 0x06
    2fd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fd8:	8f 3f       	cpi	r24, 0xFF	; 255
    2fda:	19 f4       	brne	.+6      	; 0x2fe2 <xQueueGenericSend+0xc0>
    2fdc:	ed 81       	ldd	r30, Y+5	; 0x05
    2fde:	fe 81       	ldd	r31, Y+6	; 0x06
    2fe0:	16 8e       	std	Z+30, r1	; 0x1e
    2fe2:	0f 90       	pop	r0
    2fe4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2fe6:	ce 01       	movw	r24, r28
    2fe8:	02 96       	adiw	r24, 0x02	; 2
    2fea:	9e 01       	movw	r18, r28
    2fec:	27 5f       	subi	r18, 0xF7	; 247
    2fee:	3f 4f       	sbci	r19, 0xFF	; 255
    2ff0:	b9 01       	movw	r22, r18
    2ff2:	0e 94 62 20 	call	0x40c4	; 0x40c4 <xTaskCheckForTimeOut>
    2ff6:	88 23       	and	r24, r24
    2ff8:	09 f5       	brne	.+66     	; 0x303c <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2ffa:	8d 81       	ldd	r24, Y+5	; 0x05
    2ffc:	9e 81       	ldd	r25, Y+6	; 0x06
    2ffe:	0e 94 30 1b 	call	0x3660	; 0x3660 <prvIsQueueFull>
    3002:	88 23       	and	r24, r24
    3004:	a1 f0       	breq	.+40     	; 0x302e <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3006:	8d 81       	ldd	r24, Y+5	; 0x05
    3008:	9e 81       	ldd	r25, Y+6	; 0x06
    300a:	08 96       	adiw	r24, 0x08	; 8
    300c:	29 85       	ldd	r18, Y+9	; 0x09
    300e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3010:	b9 01       	movw	r22, r18
    3012:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3016:	8d 81       	ldd	r24, Y+5	; 0x05
    3018:	9e 81       	ldd	r25, Y+6	; 0x06
    301a:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    301e:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    3022:	88 23       	and	r24, r24
    3024:	09 f0       	breq	.+2      	; 0x3028 <xQueueGenericSend+0x106>
    3026:	8f cf       	rjmp	.-226    	; 0x2f46 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3028:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
    302c:	8c cf       	rjmp	.-232    	; 0x2f46 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    302e:	8d 81       	ldd	r24, Y+5	; 0x05
    3030:	9e 81       	ldd	r25, Y+6	; 0x06
    3032:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3036:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    303a:	85 cf       	rjmp	.-246    	; 0x2f46 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    303c:	8d 81       	ldd	r24, Y+5	; 0x05
    303e:	9e 81       	ldd	r25, Y+6	; 0x06
    3040:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3044:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3048:	1c 86       	std	Y+12, r1	; 0x0c
    304a:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    304c:	2c 96       	adiw	r28, 0x0c	; 12
    304e:	0f b6       	in	r0, 0x3f	; 63
    3050:	f8 94       	cli
    3052:	de bf       	out	0x3e, r29	; 62
    3054:	0f be       	out	0x3f, r0	; 63
    3056:	cd bf       	out	0x3d, r28	; 61
    3058:	cf 91       	pop	r28
    305a:	df 91       	pop	r29
    305c:	08 95       	ret

0000305e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    305e:	df 93       	push	r29
    3060:	cf 93       	push	r28
    3062:	cd b7       	in	r28, 0x3d	; 61
    3064:	de b7       	in	r29, 0x3e	; 62
    3066:	29 97       	sbiw	r28, 0x09	; 9
    3068:	0f b6       	in	r0, 0x3f	; 63
    306a:	f8 94       	cli
    306c:	de bf       	out	0x3e, r29	; 62
    306e:	0f be       	out	0x3f, r0	; 63
    3070:	cd bf       	out	0x3d, r28	; 61
    3072:	9c 83       	std	Y+4, r25	; 0x04
    3074:	8b 83       	std	Y+3, r24	; 0x03
    3076:	7e 83       	std	Y+6, r23	; 0x06
    3078:	6d 83       	std	Y+5, r22	; 0x05
    307a:	58 87       	std	Y+8, r21	; 0x08
    307c:	4f 83       	std	Y+7, r20	; 0x07
    307e:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3080:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3082:	eb 81       	ldd	r30, Y+3	; 0x03
    3084:	fc 81       	ldd	r31, Y+4	; 0x04
    3086:	92 8d       	ldd	r25, Z+26	; 0x1a
    3088:	eb 81       	ldd	r30, Y+3	; 0x03
    308a:	fc 81       	ldd	r31, Y+4	; 0x04
    308c:	83 8d       	ldd	r24, Z+27	; 0x1b
    308e:	98 17       	cp	r25, r24
    3090:	40 f5       	brcc	.+80     	; 0x30e2 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3092:	8b 81       	ldd	r24, Y+3	; 0x03
    3094:	9c 81       	ldd	r25, Y+4	; 0x04
    3096:	2d 81       	ldd	r18, Y+5	; 0x05
    3098:	3e 81       	ldd	r19, Y+6	; 0x06
    309a:	b9 01       	movw	r22, r18
    309c:	49 85       	ldd	r20, Y+9	; 0x09
    309e:	0e 94 cc 19 	call	0x3398	; 0x3398 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    30a2:	eb 81       	ldd	r30, Y+3	; 0x03
    30a4:	fc 81       	ldd	r31, Y+4	; 0x04
    30a6:	86 8d       	ldd	r24, Z+30	; 0x1e
    30a8:	8f 3f       	cpi	r24, 0xFF	; 255
    30aa:	89 f4       	brne	.+34     	; 0x30ce <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    30ac:	eb 81       	ldd	r30, Y+3	; 0x03
    30ae:	fc 81       	ldd	r31, Y+4	; 0x04
    30b0:	81 89       	ldd	r24, Z+17	; 0x11
    30b2:	88 23       	and	r24, r24
    30b4:	99 f0       	breq	.+38     	; 0x30dc <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    30b6:	8b 81       	ldd	r24, Y+3	; 0x03
    30b8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ba:	41 96       	adiw	r24, 0x11	; 17
    30bc:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    30c0:	88 23       	and	r24, r24
    30c2:	61 f0       	breq	.+24     	; 0x30dc <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    30c4:	ef 81       	ldd	r30, Y+7	; 0x07
    30c6:	f8 85       	ldd	r31, Y+8	; 0x08
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	80 83       	st	Z, r24
    30cc:	07 c0       	rjmp	.+14     	; 0x30dc <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    30ce:	eb 81       	ldd	r30, Y+3	; 0x03
    30d0:	fc 81       	ldd	r31, Y+4	; 0x04
    30d2:	86 8d       	ldd	r24, Z+30	; 0x1e
    30d4:	8f 5f       	subi	r24, 0xFF	; 255
    30d6:	eb 81       	ldd	r30, Y+3	; 0x03
    30d8:	fc 81       	ldd	r31, Y+4	; 0x04
    30da:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    30dc:	81 e0       	ldi	r24, 0x01	; 1
    30de:	8a 83       	std	Y+2, r24	; 0x02
    30e0:	01 c0       	rjmp	.+2      	; 0x30e4 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    30e2:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    30e4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    30e6:	29 96       	adiw	r28, 0x09	; 9
    30e8:	0f b6       	in	r0, 0x3f	; 63
    30ea:	f8 94       	cli
    30ec:	de bf       	out	0x3e, r29	; 62
    30ee:	0f be       	out	0x3f, r0	; 63
    30f0:	cd bf       	out	0x3d, r28	; 61
    30f2:	cf 91       	pop	r28
    30f4:	df 91       	pop	r29
    30f6:	08 95       	ret

000030f8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    30f8:	df 93       	push	r29
    30fa:	cf 93       	push	r28
    30fc:	cd b7       	in	r28, 0x3d	; 61
    30fe:	de b7       	in	r29, 0x3e	; 62
    3100:	2e 97       	sbiw	r28, 0x0e	; 14
    3102:	0f b6       	in	r0, 0x3f	; 63
    3104:	f8 94       	cli
    3106:	de bf       	out	0x3e, r29	; 62
    3108:	0f be       	out	0x3f, r0	; 63
    310a:	cd bf       	out	0x3d, r28	; 61
    310c:	98 87       	std	Y+8, r25	; 0x08
    310e:	8f 83       	std	Y+7, r24	; 0x07
    3110:	7a 87       	std	Y+10, r23	; 0x0a
    3112:	69 87       	std	Y+9, r22	; 0x09
    3114:	5c 87       	std	Y+12, r21	; 0x0c
    3116:	4b 87       	std	Y+11, r20	; 0x0b
    3118:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    311a:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    311c:	0f b6       	in	r0, 0x3f	; 63
    311e:	f8 94       	cli
    3120:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3122:	ef 81       	ldd	r30, Y+7	; 0x07
    3124:	f8 85       	ldd	r31, Y+8	; 0x08
    3126:	82 8d       	ldd	r24, Z+26	; 0x1a
    3128:	88 23       	and	r24, r24
    312a:	09 f4       	brne	.+2      	; 0x312e <xQueueGenericReceive+0x36>
    312c:	3f c0       	rjmp	.+126    	; 0x31ac <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    312e:	ef 81       	ldd	r30, Y+7	; 0x07
    3130:	f8 85       	ldd	r31, Y+8	; 0x08
    3132:	86 81       	ldd	r24, Z+6	; 0x06
    3134:	97 81       	ldd	r25, Z+7	; 0x07
    3136:	9a 83       	std	Y+2, r25	; 0x02
    3138:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    313a:	8f 81       	ldd	r24, Y+7	; 0x07
    313c:	98 85       	ldd	r25, Y+8	; 0x08
    313e:	29 85       	ldd	r18, Y+9	; 0x09
    3140:	3a 85       	ldd	r19, Y+10	; 0x0a
    3142:	b9 01       	movw	r22, r18
    3144:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3148:	8d 85       	ldd	r24, Y+13	; 0x0d
    314a:	88 23       	and	r24, r24
    314c:	b1 f4       	brne	.+44     	; 0x317a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    314e:	ef 81       	ldd	r30, Y+7	; 0x07
    3150:	f8 85       	ldd	r31, Y+8	; 0x08
    3152:	82 8d       	ldd	r24, Z+26	; 0x1a
    3154:	81 50       	subi	r24, 0x01	; 1
    3156:	ef 81       	ldd	r30, Y+7	; 0x07
    3158:	f8 85       	ldd	r31, Y+8	; 0x08
    315a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    315c:	ef 81       	ldd	r30, Y+7	; 0x07
    315e:	f8 85       	ldd	r31, Y+8	; 0x08
    3160:	80 85       	ldd	r24, Z+8	; 0x08
    3162:	88 23       	and	r24, r24
    3164:	f1 f0       	breq	.+60     	; 0x31a2 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3166:	8f 81       	ldd	r24, Y+7	; 0x07
    3168:	98 85       	ldd	r25, Y+8	; 0x08
    316a:	08 96       	adiw	r24, 0x08	; 8
    316c:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    3170:	81 30       	cpi	r24, 0x01	; 1
    3172:	b9 f4       	brne	.+46     	; 0x31a2 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3174:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
    3178:	14 c0       	rjmp	.+40     	; 0x31a2 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    317a:	ef 81       	ldd	r30, Y+7	; 0x07
    317c:	f8 85       	ldd	r31, Y+8	; 0x08
    317e:	89 81       	ldd	r24, Y+1	; 0x01
    3180:	9a 81       	ldd	r25, Y+2	; 0x02
    3182:	97 83       	std	Z+7, r25	; 0x07
    3184:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3186:	ef 81       	ldd	r30, Y+7	; 0x07
    3188:	f8 85       	ldd	r31, Y+8	; 0x08
    318a:	81 89       	ldd	r24, Z+17	; 0x11
    318c:	88 23       	and	r24, r24
    318e:	49 f0       	breq	.+18     	; 0x31a2 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3190:	8f 81       	ldd	r24, Y+7	; 0x07
    3192:	98 85       	ldd	r25, Y+8	; 0x08
    3194:	41 96       	adiw	r24, 0x11	; 17
    3196:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    319a:	88 23       	and	r24, r24
    319c:	11 f0       	breq	.+4      	; 0x31a2 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    319e:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    31a2:	0f 90       	pop	r0
    31a4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    31a6:	81 e0       	ldi	r24, 0x01	; 1
    31a8:	8e 87       	std	Y+14, r24	; 0x0e
    31aa:	5c c0       	rjmp	.+184    	; 0x3264 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    31ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    31ae:	9c 85       	ldd	r25, Y+12	; 0x0c
    31b0:	00 97       	sbiw	r24, 0x00	; 0
    31b2:	21 f4       	brne	.+8      	; 0x31bc <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    31b4:	0f 90       	pop	r0
    31b6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    31b8:	1e 86       	std	Y+14, r1	; 0x0e
    31ba:	54 c0       	rjmp	.+168    	; 0x3264 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    31bc:	8b 81       	ldd	r24, Y+3	; 0x03
    31be:	88 23       	and	r24, r24
    31c0:	31 f4       	brne	.+12     	; 0x31ce <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    31c2:	ce 01       	movw	r24, r28
    31c4:	04 96       	adiw	r24, 0x04	; 4
    31c6:	0e 94 49 20 	call	0x4092	; 0x4092 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    31ca:	81 e0       	ldi	r24, 0x01	; 1
    31cc:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    31ce:	0f 90       	pop	r0
    31d0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    31d2:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    31d6:	0f b6       	in	r0, 0x3f	; 63
    31d8:	f8 94       	cli
    31da:	0f 92       	push	r0
    31dc:	ef 81       	ldd	r30, Y+7	; 0x07
    31de:	f8 85       	ldd	r31, Y+8	; 0x08
    31e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    31e2:	8f 3f       	cpi	r24, 0xFF	; 255
    31e4:	19 f4       	brne	.+6      	; 0x31ec <xQueueGenericReceive+0xf4>
    31e6:	ef 81       	ldd	r30, Y+7	; 0x07
    31e8:	f8 85       	ldd	r31, Y+8	; 0x08
    31ea:	15 8e       	std	Z+29, r1	; 0x1d
    31ec:	ef 81       	ldd	r30, Y+7	; 0x07
    31ee:	f8 85       	ldd	r31, Y+8	; 0x08
    31f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    31f2:	8f 3f       	cpi	r24, 0xFF	; 255
    31f4:	19 f4       	brne	.+6      	; 0x31fc <xQueueGenericReceive+0x104>
    31f6:	ef 81       	ldd	r30, Y+7	; 0x07
    31f8:	f8 85       	ldd	r31, Y+8	; 0x08
    31fa:	16 8e       	std	Z+30, r1	; 0x1e
    31fc:	0f 90       	pop	r0
    31fe:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3200:	ce 01       	movw	r24, r28
    3202:	04 96       	adiw	r24, 0x04	; 4
    3204:	9e 01       	movw	r18, r28
    3206:	25 5f       	subi	r18, 0xF5	; 245
    3208:	3f 4f       	sbci	r19, 0xFF	; 255
    320a:	b9 01       	movw	r22, r18
    320c:	0e 94 62 20 	call	0x40c4	; 0x40c4 <xTaskCheckForTimeOut>
    3210:	88 23       	and	r24, r24
    3212:	09 f5       	brne	.+66     	; 0x3256 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3214:	8f 81       	ldd	r24, Y+7	; 0x07
    3216:	98 85       	ldd	r25, Y+8	; 0x08
    3218:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <prvIsQueueEmpty>
    321c:	88 23       	and	r24, r24
    321e:	a1 f0       	breq	.+40     	; 0x3248 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3220:	8f 81       	ldd	r24, Y+7	; 0x07
    3222:	98 85       	ldd	r25, Y+8	; 0x08
    3224:	41 96       	adiw	r24, 0x11	; 17
    3226:	2b 85       	ldd	r18, Y+11	; 0x0b
    3228:	3c 85       	ldd	r19, Y+12	; 0x0c
    322a:	b9 01       	movw	r22, r18
    322c:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3230:	8f 81       	ldd	r24, Y+7	; 0x07
    3232:	98 85       	ldd	r25, Y+8	; 0x08
    3234:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3238:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    323c:	88 23       	and	r24, r24
    323e:	09 f0       	breq	.+2      	; 0x3242 <xQueueGenericReceive+0x14a>
    3240:	6d cf       	rjmp	.-294    	; 0x311c <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    3242:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
    3246:	6a cf       	rjmp	.-300    	; 0x311c <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3248:	8f 81       	ldd	r24, Y+7	; 0x07
    324a:	98 85       	ldd	r25, Y+8	; 0x08
    324c:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3250:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    3254:	63 cf       	rjmp	.-314    	; 0x311c <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3256:	8f 81       	ldd	r24, Y+7	; 0x07
    3258:	98 85       	ldd	r25, Y+8	; 0x08
    325a:	0e 94 a9 1a 	call	0x3552	; 0x3552 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    325e:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3262:	1e 86       	std	Y+14, r1	; 0x0e
    3264:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    3266:	2e 96       	adiw	r28, 0x0e	; 14
    3268:	0f b6       	in	r0, 0x3f	; 63
    326a:	f8 94       	cli
    326c:	de bf       	out	0x3e, r29	; 62
    326e:	0f be       	out	0x3f, r0	; 63
    3270:	cd bf       	out	0x3d, r28	; 61
    3272:	cf 91       	pop	r28
    3274:	df 91       	pop	r29
    3276:	08 95       	ret

00003278 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    3278:	df 93       	push	r29
    327a:	cf 93       	push	r28
    327c:	cd b7       	in	r28, 0x3d	; 61
    327e:	de b7       	in	r29, 0x3e	; 62
    3280:	28 97       	sbiw	r28, 0x08	; 8
    3282:	0f b6       	in	r0, 0x3f	; 63
    3284:	f8 94       	cli
    3286:	de bf       	out	0x3e, r29	; 62
    3288:	0f be       	out	0x3f, r0	; 63
    328a:	cd bf       	out	0x3d, r28	; 61
    328c:	9c 83       	std	Y+4, r25	; 0x04
    328e:	8b 83       	std	Y+3, r24	; 0x03
    3290:	7e 83       	std	Y+6, r23	; 0x06
    3292:	6d 83       	std	Y+5, r22	; 0x05
    3294:	58 87       	std	Y+8, r21	; 0x08
    3296:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3298:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    329a:	eb 81       	ldd	r30, Y+3	; 0x03
    329c:	fc 81       	ldd	r31, Y+4	; 0x04
    329e:	82 8d       	ldd	r24, Z+26	; 0x1a
    32a0:	88 23       	and	r24, r24
    32a2:	71 f1       	breq	.+92     	; 0x3300 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    32a4:	8b 81       	ldd	r24, Y+3	; 0x03
    32a6:	9c 81       	ldd	r25, Y+4	; 0x04
    32a8:	2d 81       	ldd	r18, Y+5	; 0x05
    32aa:	3e 81       	ldd	r19, Y+6	; 0x06
    32ac:	b9 01       	movw	r22, r18
    32ae:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    32b2:	eb 81       	ldd	r30, Y+3	; 0x03
    32b4:	fc 81       	ldd	r31, Y+4	; 0x04
    32b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    32b8:	81 50       	subi	r24, 0x01	; 1
    32ba:	eb 81       	ldd	r30, Y+3	; 0x03
    32bc:	fc 81       	ldd	r31, Y+4	; 0x04
    32be:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    32c0:	eb 81       	ldd	r30, Y+3	; 0x03
    32c2:	fc 81       	ldd	r31, Y+4	; 0x04
    32c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    32c6:	8f 3f       	cpi	r24, 0xFF	; 255
    32c8:	89 f4       	brne	.+34     	; 0x32ec <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    32ca:	eb 81       	ldd	r30, Y+3	; 0x03
    32cc:	fc 81       	ldd	r31, Y+4	; 0x04
    32ce:	80 85       	ldd	r24, Z+8	; 0x08
    32d0:	88 23       	and	r24, r24
    32d2:	99 f0       	breq	.+38     	; 0x32fa <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    32d4:	8b 81       	ldd	r24, Y+3	; 0x03
    32d6:	9c 81       	ldd	r25, Y+4	; 0x04
    32d8:	08 96       	adiw	r24, 0x08	; 8
    32da:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    32de:	88 23       	and	r24, r24
    32e0:	61 f0       	breq	.+24     	; 0x32fa <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    32e2:	ef 81       	ldd	r30, Y+7	; 0x07
    32e4:	f8 85       	ldd	r31, Y+8	; 0x08
    32e6:	81 e0       	ldi	r24, 0x01	; 1
    32e8:	80 83       	st	Z, r24
    32ea:	07 c0       	rjmp	.+14     	; 0x32fa <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    32ec:	eb 81       	ldd	r30, Y+3	; 0x03
    32ee:	fc 81       	ldd	r31, Y+4	; 0x04
    32f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    32f2:	8f 5f       	subi	r24, 0xFF	; 255
    32f4:	eb 81       	ldd	r30, Y+3	; 0x03
    32f6:	fc 81       	ldd	r31, Y+4	; 0x04
    32f8:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    32fa:	81 e0       	ldi	r24, 0x01	; 1
    32fc:	8a 83       	std	Y+2, r24	; 0x02
    32fe:	01 c0       	rjmp	.+2      	; 0x3302 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    3300:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3302:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3304:	28 96       	adiw	r28, 0x08	; 8
    3306:	0f b6       	in	r0, 0x3f	; 63
    3308:	f8 94       	cli
    330a:	de bf       	out	0x3e, r29	; 62
    330c:	0f be       	out	0x3f, r0	; 63
    330e:	cd bf       	out	0x3d, r28	; 61
    3310:	cf 91       	pop	r28
    3312:	df 91       	pop	r29
    3314:	08 95       	ret

00003316 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    3316:	df 93       	push	r29
    3318:	cf 93       	push	r28
    331a:	00 d0       	rcall	.+0      	; 0x331c <uxQueueMessagesWaiting+0x6>
    331c:	0f 92       	push	r0
    331e:	cd b7       	in	r28, 0x3d	; 61
    3320:	de b7       	in	r29, 0x3e	; 62
    3322:	9b 83       	std	Y+3, r25	; 0x03
    3324:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    3326:	0f b6       	in	r0, 0x3f	; 63
    3328:	f8 94       	cli
    332a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    332c:	ea 81       	ldd	r30, Y+2	; 0x02
    332e:	fb 81       	ldd	r31, Y+3	; 0x03
    3330:	82 8d       	ldd	r24, Z+26	; 0x1a
    3332:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3334:	0f 90       	pop	r0
    3336:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3338:	89 81       	ldd	r24, Y+1	; 0x01
}
    333a:	0f 90       	pop	r0
    333c:	0f 90       	pop	r0
    333e:	0f 90       	pop	r0
    3340:	cf 91       	pop	r28
    3342:	df 91       	pop	r29
    3344:	08 95       	ret

00003346 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    3346:	df 93       	push	r29
    3348:	cf 93       	push	r28
    334a:	00 d0       	rcall	.+0      	; 0x334c <uxQueueMessagesWaitingFromISR+0x6>
    334c:	0f 92       	push	r0
    334e:	cd b7       	in	r28, 0x3d	; 61
    3350:	de b7       	in	r29, 0x3e	; 62
    3352:	9b 83       	std	Y+3, r25	; 0x03
    3354:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    3356:	ea 81       	ldd	r30, Y+2	; 0x02
    3358:	fb 81       	ldd	r31, Y+3	; 0x03
    335a:	82 8d       	ldd	r24, Z+26	; 0x1a
    335c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    335e:	89 81       	ldd	r24, Y+1	; 0x01
}
    3360:	0f 90       	pop	r0
    3362:	0f 90       	pop	r0
    3364:	0f 90       	pop	r0
    3366:	cf 91       	pop	r28
    3368:	df 91       	pop	r29
    336a:	08 95       	ret

0000336c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    336c:	df 93       	push	r29
    336e:	cf 93       	push	r28
    3370:	00 d0       	rcall	.+0      	; 0x3372 <vQueueDelete+0x6>
    3372:	cd b7       	in	r28, 0x3d	; 61
    3374:	de b7       	in	r29, 0x3e	; 62
    3376:	9a 83       	std	Y+2, r25	; 0x02
    3378:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    337a:	e9 81       	ldd	r30, Y+1	; 0x01
    337c:	fa 81       	ldd	r31, Y+2	; 0x02
    337e:	80 81       	ld	r24, Z
    3380:	91 81       	ldd	r25, Z+1	; 0x01
    3382:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
	vPortFree( pxQueue );
    3386:	89 81       	ldd	r24, Y+1	; 0x01
    3388:	9a 81       	ldd	r25, Y+2	; 0x02
    338a:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
}
    338e:	0f 90       	pop	r0
    3390:	0f 90       	pop	r0
    3392:	cf 91       	pop	r28
    3394:	df 91       	pop	r29
    3396:	08 95       	ret

00003398 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3398:	df 93       	push	r29
    339a:	cf 93       	push	r28
    339c:	00 d0       	rcall	.+0      	; 0x339e <prvCopyDataToQueue+0x6>
    339e:	00 d0       	rcall	.+0      	; 0x33a0 <prvCopyDataToQueue+0x8>
    33a0:	0f 92       	push	r0
    33a2:	cd b7       	in	r28, 0x3d	; 61
    33a4:	de b7       	in	r29, 0x3e	; 62
    33a6:	9a 83       	std	Y+2, r25	; 0x02
    33a8:	89 83       	std	Y+1, r24	; 0x01
    33aa:	7c 83       	std	Y+4, r23	; 0x04
    33ac:	6b 83       	std	Y+3, r22	; 0x03
    33ae:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    33b0:	e9 81       	ldd	r30, Y+1	; 0x01
    33b2:	fa 81       	ldd	r31, Y+2	; 0x02
    33b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    33b6:	88 23       	and	r24, r24
    33b8:	09 f4       	brne	.+2      	; 0x33bc <prvCopyDataToQueue+0x24>
    33ba:	74 c0       	rjmp	.+232    	; 0x34a4 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    33bc:	8d 81       	ldd	r24, Y+5	; 0x05
    33be:	88 23       	and	r24, r24
    33c0:	99 f5       	brne	.+102    	; 0x3428 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    33c2:	e9 81       	ldd	r30, Y+1	; 0x01
    33c4:	fa 81       	ldd	r31, Y+2	; 0x02
    33c6:	64 81       	ldd	r22, Z+4	; 0x04
    33c8:	75 81       	ldd	r23, Z+5	; 0x05
    33ca:	e9 81       	ldd	r30, Y+1	; 0x01
    33cc:	fa 81       	ldd	r31, Y+2	; 0x02
    33ce:	84 8d       	ldd	r24, Z+28	; 0x1c
    33d0:	48 2f       	mov	r20, r24
    33d2:	50 e0       	ldi	r21, 0x00	; 0
    33d4:	2b 81       	ldd	r18, Y+3	; 0x03
    33d6:	3c 81       	ldd	r19, Y+4	; 0x04
    33d8:	cb 01       	movw	r24, r22
    33da:	b9 01       	movw	r22, r18
    33dc:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    33e0:	e9 81       	ldd	r30, Y+1	; 0x01
    33e2:	fa 81       	ldd	r31, Y+2	; 0x02
    33e4:	24 81       	ldd	r18, Z+4	; 0x04
    33e6:	35 81       	ldd	r19, Z+5	; 0x05
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    33ee:	88 2f       	mov	r24, r24
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	82 0f       	add	r24, r18
    33f4:	93 1f       	adc	r25, r19
    33f6:	e9 81       	ldd	r30, Y+1	; 0x01
    33f8:	fa 81       	ldd	r31, Y+2	; 0x02
    33fa:	95 83       	std	Z+5, r25	; 0x05
    33fc:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    33fe:	e9 81       	ldd	r30, Y+1	; 0x01
    3400:	fa 81       	ldd	r31, Y+2	; 0x02
    3402:	24 81       	ldd	r18, Z+4	; 0x04
    3404:	35 81       	ldd	r19, Z+5	; 0x05
    3406:	e9 81       	ldd	r30, Y+1	; 0x01
    3408:	fa 81       	ldd	r31, Y+2	; 0x02
    340a:	82 81       	ldd	r24, Z+2	; 0x02
    340c:	93 81       	ldd	r25, Z+3	; 0x03
    340e:	28 17       	cp	r18, r24
    3410:	39 07       	cpc	r19, r25
    3412:	08 f4       	brcc	.+2      	; 0x3416 <prvCopyDataToQueue+0x7e>
    3414:	47 c0       	rjmp	.+142    	; 0x34a4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    3416:	e9 81       	ldd	r30, Y+1	; 0x01
    3418:	fa 81       	ldd	r31, Y+2	; 0x02
    341a:	80 81       	ld	r24, Z
    341c:	91 81       	ldd	r25, Z+1	; 0x01
    341e:	e9 81       	ldd	r30, Y+1	; 0x01
    3420:	fa 81       	ldd	r31, Y+2	; 0x02
    3422:	95 83       	std	Z+5, r25	; 0x05
    3424:	84 83       	std	Z+4, r24	; 0x04
    3426:	3e c0       	rjmp	.+124    	; 0x34a4 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3428:	e9 81       	ldd	r30, Y+1	; 0x01
    342a:	fa 81       	ldd	r31, Y+2	; 0x02
    342c:	66 81       	ldd	r22, Z+6	; 0x06
    342e:	77 81       	ldd	r23, Z+7	; 0x07
    3430:	e9 81       	ldd	r30, Y+1	; 0x01
    3432:	fa 81       	ldd	r31, Y+2	; 0x02
    3434:	84 8d       	ldd	r24, Z+28	; 0x1c
    3436:	48 2f       	mov	r20, r24
    3438:	50 e0       	ldi	r21, 0x00	; 0
    343a:	2b 81       	ldd	r18, Y+3	; 0x03
    343c:	3c 81       	ldd	r19, Y+4	; 0x04
    343e:	cb 01       	movw	r24, r22
    3440:	b9 01       	movw	r22, r18
    3442:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    3446:	e9 81       	ldd	r30, Y+1	; 0x01
    3448:	fa 81       	ldd	r31, Y+2	; 0x02
    344a:	26 81       	ldd	r18, Z+6	; 0x06
    344c:	37 81       	ldd	r19, Z+7	; 0x07
    344e:	e9 81       	ldd	r30, Y+1	; 0x01
    3450:	fa 81       	ldd	r31, Y+2	; 0x02
    3452:	84 8d       	ldd	r24, Z+28	; 0x1c
    3454:	88 2f       	mov	r24, r24
    3456:	90 e0       	ldi	r25, 0x00	; 0
    3458:	90 95       	com	r25
    345a:	81 95       	neg	r24
    345c:	9f 4f       	sbci	r25, 0xFF	; 255
    345e:	82 0f       	add	r24, r18
    3460:	93 1f       	adc	r25, r19
    3462:	e9 81       	ldd	r30, Y+1	; 0x01
    3464:	fa 81       	ldd	r31, Y+2	; 0x02
    3466:	97 83       	std	Z+7, r25	; 0x07
    3468:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    346a:	e9 81       	ldd	r30, Y+1	; 0x01
    346c:	fa 81       	ldd	r31, Y+2	; 0x02
    346e:	26 81       	ldd	r18, Z+6	; 0x06
    3470:	37 81       	ldd	r19, Z+7	; 0x07
    3472:	e9 81       	ldd	r30, Y+1	; 0x01
    3474:	fa 81       	ldd	r31, Y+2	; 0x02
    3476:	80 81       	ld	r24, Z
    3478:	91 81       	ldd	r25, Z+1	; 0x01
    347a:	28 17       	cp	r18, r24
    347c:	39 07       	cpc	r19, r25
    347e:	90 f4       	brcc	.+36     	; 0x34a4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    3480:	e9 81       	ldd	r30, Y+1	; 0x01
    3482:	fa 81       	ldd	r31, Y+2	; 0x02
    3484:	22 81       	ldd	r18, Z+2	; 0x02
    3486:	33 81       	ldd	r19, Z+3	; 0x03
    3488:	e9 81       	ldd	r30, Y+1	; 0x01
    348a:	fa 81       	ldd	r31, Y+2	; 0x02
    348c:	84 8d       	ldd	r24, Z+28	; 0x1c
    348e:	88 2f       	mov	r24, r24
    3490:	90 e0       	ldi	r25, 0x00	; 0
    3492:	90 95       	com	r25
    3494:	81 95       	neg	r24
    3496:	9f 4f       	sbci	r25, 0xFF	; 255
    3498:	82 0f       	add	r24, r18
    349a:	93 1f       	adc	r25, r19
    349c:	e9 81       	ldd	r30, Y+1	; 0x01
    349e:	fa 81       	ldd	r31, Y+2	; 0x02
    34a0:	97 83       	std	Z+7, r25	; 0x07
    34a2:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    34a4:	e9 81       	ldd	r30, Y+1	; 0x01
    34a6:	fa 81       	ldd	r31, Y+2	; 0x02
    34a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    34aa:	8f 5f       	subi	r24, 0xFF	; 255
    34ac:	e9 81       	ldd	r30, Y+1	; 0x01
    34ae:	fa 81       	ldd	r31, Y+2	; 0x02
    34b0:	82 8f       	std	Z+26, r24	; 0x1a
}
    34b2:	0f 90       	pop	r0
    34b4:	0f 90       	pop	r0
    34b6:	0f 90       	pop	r0
    34b8:	0f 90       	pop	r0
    34ba:	0f 90       	pop	r0
    34bc:	cf 91       	pop	r28
    34be:	df 91       	pop	r29
    34c0:	08 95       	ret

000034c2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    34c2:	df 93       	push	r29
    34c4:	cf 93       	push	r28
    34c6:	00 d0       	rcall	.+0      	; 0x34c8 <prvCopyDataFromQueue+0x6>
    34c8:	00 d0       	rcall	.+0      	; 0x34ca <prvCopyDataFromQueue+0x8>
    34ca:	cd b7       	in	r28, 0x3d	; 61
    34cc:	de b7       	in	r29, 0x3e	; 62
    34ce:	9a 83       	std	Y+2, r25	; 0x02
    34d0:	89 83       	std	Y+1, r24	; 0x01
    34d2:	7c 83       	std	Y+4, r23	; 0x04
    34d4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    34d6:	e9 81       	ldd	r30, Y+1	; 0x01
    34d8:	fa 81       	ldd	r31, Y+2	; 0x02
    34da:	80 81       	ld	r24, Z
    34dc:	91 81       	ldd	r25, Z+1	; 0x01
    34de:	00 97       	sbiw	r24, 0x00	; 0
    34e0:	89 f1       	breq	.+98     	; 0x3544 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    34e2:	e9 81       	ldd	r30, Y+1	; 0x01
    34e4:	fa 81       	ldd	r31, Y+2	; 0x02
    34e6:	26 81       	ldd	r18, Z+6	; 0x06
    34e8:	37 81       	ldd	r19, Z+7	; 0x07
    34ea:	e9 81       	ldd	r30, Y+1	; 0x01
    34ec:	fa 81       	ldd	r31, Y+2	; 0x02
    34ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    34f0:	88 2f       	mov	r24, r24
    34f2:	90 e0       	ldi	r25, 0x00	; 0
    34f4:	82 0f       	add	r24, r18
    34f6:	93 1f       	adc	r25, r19
    34f8:	e9 81       	ldd	r30, Y+1	; 0x01
    34fa:	fa 81       	ldd	r31, Y+2	; 0x02
    34fc:	97 83       	std	Z+7, r25	; 0x07
    34fe:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    3500:	e9 81       	ldd	r30, Y+1	; 0x01
    3502:	fa 81       	ldd	r31, Y+2	; 0x02
    3504:	26 81       	ldd	r18, Z+6	; 0x06
    3506:	37 81       	ldd	r19, Z+7	; 0x07
    3508:	e9 81       	ldd	r30, Y+1	; 0x01
    350a:	fa 81       	ldd	r31, Y+2	; 0x02
    350c:	82 81       	ldd	r24, Z+2	; 0x02
    350e:	93 81       	ldd	r25, Z+3	; 0x03
    3510:	28 17       	cp	r18, r24
    3512:	39 07       	cpc	r19, r25
    3514:	40 f0       	brcs	.+16     	; 0x3526 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    3516:	e9 81       	ldd	r30, Y+1	; 0x01
    3518:	fa 81       	ldd	r31, Y+2	; 0x02
    351a:	80 81       	ld	r24, Z
    351c:	91 81       	ldd	r25, Z+1	; 0x01
    351e:	e9 81       	ldd	r30, Y+1	; 0x01
    3520:	fa 81       	ldd	r31, Y+2	; 0x02
    3522:	97 83       	std	Z+7, r25	; 0x07
    3524:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    3526:	e9 81       	ldd	r30, Y+1	; 0x01
    3528:	fa 81       	ldd	r31, Y+2	; 0x02
    352a:	46 81       	ldd	r20, Z+6	; 0x06
    352c:	57 81       	ldd	r21, Z+7	; 0x07
    352e:	e9 81       	ldd	r30, Y+1	; 0x01
    3530:	fa 81       	ldd	r31, Y+2	; 0x02
    3532:	84 8d       	ldd	r24, Z+28	; 0x1c
    3534:	28 2f       	mov	r18, r24
    3536:	30 e0       	ldi	r19, 0x00	; 0
    3538:	8b 81       	ldd	r24, Y+3	; 0x03
    353a:	9c 81       	ldd	r25, Y+4	; 0x04
    353c:	ba 01       	movw	r22, r20
    353e:	a9 01       	movw	r20, r18
    3540:	0e 94 fb 22 	call	0x45f6	; 0x45f6 <memcpy>
	}
}
    3544:	0f 90       	pop	r0
    3546:	0f 90       	pop	r0
    3548:	0f 90       	pop	r0
    354a:	0f 90       	pop	r0
    354c:	cf 91       	pop	r28
    354e:	df 91       	pop	r29
    3550:	08 95       	ret

00003552 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    3552:	df 93       	push	r29
    3554:	cf 93       	push	r28
    3556:	00 d0       	rcall	.+0      	; 0x3558 <prvUnlockQueue+0x6>
    3558:	cd b7       	in	r28, 0x3d	; 61
    355a:	de b7       	in	r29, 0x3e	; 62
    355c:	9a 83       	std	Y+2, r25	; 0x02
    355e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3560:	0f b6       	in	r0, 0x3f	; 63
    3562:	f8 94       	cli
    3564:	0f 92       	push	r0
    3566:	15 c0       	rjmp	.+42     	; 0x3592 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3568:	e9 81       	ldd	r30, Y+1	; 0x01
    356a:	fa 81       	ldd	r31, Y+2	; 0x02
    356c:	81 89       	ldd	r24, Z+17	; 0x11
    356e:	88 23       	and	r24, r24
    3570:	a9 f0       	breq	.+42     	; 0x359c <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3572:	89 81       	ldd	r24, Y+1	; 0x01
    3574:	9a 81       	ldd	r25, Y+2	; 0x02
    3576:	41 96       	adiw	r24, 0x11	; 17
    3578:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    357c:	88 23       	and	r24, r24
    357e:	11 f0       	breq	.+4      	; 0x3584 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    3580:	0e 94 bf 20 	call	0x417e	; 0x417e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    3584:	e9 81       	ldd	r30, Y+1	; 0x01
    3586:	fa 81       	ldd	r31, Y+2	; 0x02
    3588:	86 8d       	ldd	r24, Z+30	; 0x1e
    358a:	81 50       	subi	r24, 0x01	; 1
    358c:	e9 81       	ldd	r30, Y+1	; 0x01
    358e:	fa 81       	ldd	r31, Y+2	; 0x02
    3590:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3592:	e9 81       	ldd	r30, Y+1	; 0x01
    3594:	fa 81       	ldd	r31, Y+2	; 0x02
    3596:	86 8d       	ldd	r24, Z+30	; 0x1e
    3598:	18 16       	cp	r1, r24
    359a:	34 f3       	brlt	.-52     	; 0x3568 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    359c:	e9 81       	ldd	r30, Y+1	; 0x01
    359e:	fa 81       	ldd	r31, Y+2	; 0x02
    35a0:	8f ef       	ldi	r24, 0xFF	; 255
    35a2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    35a4:	0f 90       	pop	r0
    35a6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    35a8:	0f b6       	in	r0, 0x3f	; 63
    35aa:	f8 94       	cli
    35ac:	0f 92       	push	r0
    35ae:	15 c0       	rjmp	.+42     	; 0x35da <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    35b0:	e9 81       	ldd	r30, Y+1	; 0x01
    35b2:	fa 81       	ldd	r31, Y+2	; 0x02
    35b4:	80 85       	ldd	r24, Z+8	; 0x08
    35b6:	88 23       	and	r24, r24
    35b8:	a9 f0       	breq	.+42     	; 0x35e4 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    35ba:	89 81       	ldd	r24, Y+1	; 0x01
    35bc:	9a 81       	ldd	r25, Y+2	; 0x02
    35be:	08 96       	adiw	r24, 0x08	; 8
    35c0:	0e 94 e1 1f 	call	0x3fc2	; 0x3fc2 <xTaskRemoveFromEventList>
    35c4:	88 23       	and	r24, r24
    35c6:	11 f0       	breq	.+4      	; 0x35cc <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    35c8:	0e 94 bf 20 	call	0x417e	; 0x417e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    35cc:	e9 81       	ldd	r30, Y+1	; 0x01
    35ce:	fa 81       	ldd	r31, Y+2	; 0x02
    35d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    35d2:	81 50       	subi	r24, 0x01	; 1
    35d4:	e9 81       	ldd	r30, Y+1	; 0x01
    35d6:	fa 81       	ldd	r31, Y+2	; 0x02
    35d8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    35da:	e9 81       	ldd	r30, Y+1	; 0x01
    35dc:	fa 81       	ldd	r31, Y+2	; 0x02
    35de:	85 8d       	ldd	r24, Z+29	; 0x1d
    35e0:	18 16       	cp	r1, r24
    35e2:	34 f3       	brlt	.-52     	; 0x35b0 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    35e4:	e9 81       	ldd	r30, Y+1	; 0x01
    35e6:	fa 81       	ldd	r31, Y+2	; 0x02
    35e8:	8f ef       	ldi	r24, 0xFF	; 255
    35ea:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    35ec:	0f 90       	pop	r0
    35ee:	0f be       	out	0x3f, r0	; 63
}
    35f0:	0f 90       	pop	r0
    35f2:	0f 90       	pop	r0
    35f4:	cf 91       	pop	r28
    35f6:	df 91       	pop	r29
    35f8:	08 95       	ret

000035fa <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    35fa:	df 93       	push	r29
    35fc:	cf 93       	push	r28
    35fe:	00 d0       	rcall	.+0      	; 0x3600 <prvIsQueueEmpty+0x6>
    3600:	0f 92       	push	r0
    3602:	cd b7       	in	r28, 0x3d	; 61
    3604:	de b7       	in	r29, 0x3e	; 62
    3606:	9b 83       	std	Y+3, r25	; 0x03
    3608:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    360a:	0f b6       	in	r0, 0x3f	; 63
    360c:	f8 94       	cli
    360e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3610:	ea 81       	ldd	r30, Y+2	; 0x02
    3612:	fb 81       	ldd	r31, Y+3	; 0x03
    3614:	82 8d       	ldd	r24, Z+26	; 0x1a
    3616:	19 82       	std	Y+1, r1	; 0x01
    3618:	88 23       	and	r24, r24
    361a:	11 f4       	brne	.+4      	; 0x3620 <prvIsQueueEmpty+0x26>
    361c:	81 e0       	ldi	r24, 0x01	; 1
    361e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3620:	0f 90       	pop	r0
    3622:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3624:	89 81       	ldd	r24, Y+1	; 0x01
}
    3626:	0f 90       	pop	r0
    3628:	0f 90       	pop	r0
    362a:	0f 90       	pop	r0
    362c:	cf 91       	pop	r28
    362e:	df 91       	pop	r29
    3630:	08 95       	ret

00003632 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    3632:	df 93       	push	r29
    3634:	cf 93       	push	r28
    3636:	00 d0       	rcall	.+0      	; 0x3638 <xQueueIsQueueEmptyFromISR+0x6>
    3638:	0f 92       	push	r0
    363a:	cd b7       	in	r28, 0x3d	; 61
    363c:	de b7       	in	r29, 0x3e	; 62
    363e:	9b 83       	std	Y+3, r25	; 0x03
    3640:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    3642:	ea 81       	ldd	r30, Y+2	; 0x02
    3644:	fb 81       	ldd	r31, Y+3	; 0x03
    3646:	82 8d       	ldd	r24, Z+26	; 0x1a
    3648:	19 82       	std	Y+1, r1	; 0x01
    364a:	88 23       	and	r24, r24
    364c:	11 f4       	brne	.+4      	; 0x3652 <xQueueIsQueueEmptyFromISR+0x20>
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    3652:	89 81       	ldd	r24, Y+1	; 0x01
}
    3654:	0f 90       	pop	r0
    3656:	0f 90       	pop	r0
    3658:	0f 90       	pop	r0
    365a:	cf 91       	pop	r28
    365c:	df 91       	pop	r29
    365e:	08 95       	ret

00003660 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    3660:	df 93       	push	r29
    3662:	cf 93       	push	r28
    3664:	00 d0       	rcall	.+0      	; 0x3666 <prvIsQueueFull+0x6>
    3666:	0f 92       	push	r0
    3668:	cd b7       	in	r28, 0x3d	; 61
    366a:	de b7       	in	r29, 0x3e	; 62
    366c:	9b 83       	std	Y+3, r25	; 0x03
    366e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    3670:	0f b6       	in	r0, 0x3f	; 63
    3672:	f8 94       	cli
    3674:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    3676:	ea 81       	ldd	r30, Y+2	; 0x02
    3678:	fb 81       	ldd	r31, Y+3	; 0x03
    367a:	92 8d       	ldd	r25, Z+26	; 0x1a
    367c:	ea 81       	ldd	r30, Y+2	; 0x02
    367e:	fb 81       	ldd	r31, Y+3	; 0x03
    3680:	83 8d       	ldd	r24, Z+27	; 0x1b
    3682:	19 82       	std	Y+1, r1	; 0x01
    3684:	98 17       	cp	r25, r24
    3686:	11 f4       	brne	.+4      	; 0x368c <prvIsQueueFull+0x2c>
    3688:	81 e0       	ldi	r24, 0x01	; 1
    368a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    368c:	0f 90       	pop	r0
    368e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3690:	89 81       	ldd	r24, Y+1	; 0x01
}
    3692:	0f 90       	pop	r0
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	cf 91       	pop	r28
    369a:	df 91       	pop	r29
    369c:	08 95       	ret

0000369e <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    369e:	df 93       	push	r29
    36a0:	cf 93       	push	r28
    36a2:	00 d0       	rcall	.+0      	; 0x36a4 <xQueueIsQueueFullFromISR+0x6>
    36a4:	0f 92       	push	r0
    36a6:	cd b7       	in	r28, 0x3d	; 61
    36a8:	de b7       	in	r29, 0x3e	; 62
    36aa:	9b 83       	std	Y+3, r25	; 0x03
    36ac:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    36ae:	ea 81       	ldd	r30, Y+2	; 0x02
    36b0:	fb 81       	ldd	r31, Y+3	; 0x03
    36b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    36b4:	ea 81       	ldd	r30, Y+2	; 0x02
    36b6:	fb 81       	ldd	r31, Y+3	; 0x03
    36b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    36ba:	19 82       	std	Y+1, r1	; 0x01
    36bc:	98 17       	cp	r25, r24
    36be:	11 f4       	brne	.+4      	; 0x36c4 <xQueueIsQueueFullFromISR+0x26>
    36c0:	81 e0       	ldi	r24, 0x01	; 1
    36c2:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    36c4:	89 81       	ldd	r24, Y+1	; 0x01
}
    36c6:	0f 90       	pop	r0
    36c8:	0f 90       	pop	r0
    36ca:	0f 90       	pop	r0
    36cc:	cf 91       	pop	r28
    36ce:	df 91       	pop	r29
    36d0:	08 95       	ret

000036d2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    36d2:	af 92       	push	r10
    36d4:	bf 92       	push	r11
    36d6:	cf 92       	push	r12
    36d8:	df 92       	push	r13
    36da:	ef 92       	push	r14
    36dc:	ff 92       	push	r15
    36de:	0f 93       	push	r16
    36e0:	1f 93       	push	r17
    36e2:	df 93       	push	r29
    36e4:	cf 93       	push	r28
    36e6:	cd b7       	in	r28, 0x3d	; 61
    36e8:	de b7       	in	r29, 0x3e	; 62
    36ea:	64 97       	sbiw	r28, 0x14	; 20
    36ec:	0f b6       	in	r0, 0x3f	; 63
    36ee:	f8 94       	cli
    36f0:	de bf       	out	0x3e, r29	; 62
    36f2:	0f be       	out	0x3f, r0	; 63
    36f4:	cd bf       	out	0x3d, r28	; 61
    36f6:	9f 83       	std	Y+7, r25	; 0x07
    36f8:	8e 83       	std	Y+6, r24	; 0x06
    36fa:	79 87       	std	Y+9, r23	; 0x09
    36fc:	68 87       	std	Y+8, r22	; 0x08
    36fe:	5b 87       	std	Y+11, r21	; 0x0b
    3700:	4a 87       	std	Y+10, r20	; 0x0a
    3702:	3d 87       	std	Y+13, r19	; 0x0d
    3704:	2c 87       	std	Y+12, r18	; 0x0c
    3706:	0e 87       	std	Y+14, r16	; 0x0e
    3708:	f8 8a       	std	Y+16, r15	; 0x10
    370a:	ef 86       	std	Y+15, r14	; 0x0f
    370c:	da 8a       	std	Y+18, r13	; 0x12
    370e:	c9 8a       	std	Y+17, r12	; 0x11
    3710:	bc 8a       	std	Y+20, r11	; 0x14
    3712:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    3714:	8a 85       	ldd	r24, Y+10	; 0x0a
    3716:	9b 85       	ldd	r25, Y+11	; 0x0b
    3718:	29 89       	ldd	r18, Y+17	; 0x11
    371a:	3a 89       	ldd	r19, Y+18	; 0x12
    371c:	b9 01       	movw	r22, r18
    371e:	0e 94 ee 21 	call	0x43dc	; 0x43dc <prvAllocateTCBAndStack>
    3722:	9c 83       	std	Y+4, r25	; 0x04
    3724:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    3726:	8b 81       	ldd	r24, Y+3	; 0x03
    3728:	9c 81       	ldd	r25, Y+4	; 0x04
    372a:	00 97       	sbiw	r24, 0x00	; 0
    372c:	09 f4       	brne	.+2      	; 0x3730 <xTaskGenericCreate+0x5e>
    372e:	99 c0       	rjmp	.+306    	; 0x3862 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    3730:	eb 81       	ldd	r30, Y+3	; 0x03
    3732:	fc 81       	ldd	r31, Y+4	; 0x04
    3734:	27 89       	ldd	r18, Z+23	; 0x17
    3736:	30 8d       	ldd	r19, Z+24	; 0x18
    3738:	8a 85       	ldd	r24, Y+10	; 0x0a
    373a:	9b 85       	ldd	r25, Y+11	; 0x0b
    373c:	01 97       	sbiw	r24, 0x01	; 1
    373e:	82 0f       	add	r24, r18
    3740:	93 1f       	adc	r25, r19
    3742:	9a 83       	std	Y+2, r25	; 0x02
    3744:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    3746:	8b 81       	ldd	r24, Y+3	; 0x03
    3748:	9c 81       	ldd	r25, Y+4	; 0x04
    374a:	28 85       	ldd	r18, Y+8	; 0x08
    374c:	39 85       	ldd	r19, Y+9	; 0x09
    374e:	eb 89       	ldd	r30, Y+19	; 0x13
    3750:	fc 89       	ldd	r31, Y+20	; 0x14
    3752:	aa 85       	ldd	r26, Y+10	; 0x0a
    3754:	bb 85       	ldd	r27, Y+11	; 0x0b
    3756:	b9 01       	movw	r22, r18
    3758:	4e 85       	ldd	r20, Y+14	; 0x0e
    375a:	9f 01       	movw	r18, r30
    375c:	8d 01       	movw	r16, r26
    375e:	0e 94 d3 20 	call	0x41a6	; 0x41a6 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3762:	89 81       	ldd	r24, Y+1	; 0x01
    3764:	9a 81       	ldd	r25, Y+2	; 0x02
    3766:	2e 81       	ldd	r18, Y+6	; 0x06
    3768:	3f 81       	ldd	r19, Y+7	; 0x07
    376a:	4c 85       	ldd	r20, Y+12	; 0x0c
    376c:	5d 85       	ldd	r21, Y+13	; 0x0d
    376e:	b9 01       	movw	r22, r18
    3770:	0e 94 16 14 	call	0x282c	; 0x282c <pxPortInitialiseStack>
    3774:	eb 81       	ldd	r30, Y+3	; 0x03
    3776:	fc 81       	ldd	r31, Y+4	; 0x04
    3778:	91 83       	std	Z+1, r25	; 0x01
    377a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    377c:	8f 85       	ldd	r24, Y+15	; 0x0f
    377e:	98 89       	ldd	r25, Y+16	; 0x10
    3780:	00 97       	sbiw	r24, 0x00	; 0
    3782:	31 f0       	breq	.+12     	; 0x3790 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    3784:	ef 85       	ldd	r30, Y+15	; 0x0f
    3786:	f8 89       	ldd	r31, Y+16	; 0x10
    3788:	8b 81       	ldd	r24, Y+3	; 0x03
    378a:	9c 81       	ldd	r25, Y+4	; 0x04
    378c:	91 83       	std	Z+1, r25	; 0x01
    378e:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    3790:	0f b6       	in	r0, 0x3f	; 63
    3792:	f8 94       	cli
    3794:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    3796:	80 91 a5 04 	lds	r24, 0x04A5
    379a:	8f 5f       	subi	r24, 0xFF	; 255
    379c:	80 93 a5 04 	sts	0x04A5, r24
			if( pxCurrentTCB == NULL )
    37a0:	80 91 a2 04 	lds	r24, 0x04A2
    37a4:	90 91 a3 04 	lds	r25, 0x04A3
    37a8:	00 97       	sbiw	r24, 0x00	; 0
    37aa:	69 f4       	brne	.+26     	; 0x37c6 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    37ac:	8b 81       	ldd	r24, Y+3	; 0x03
    37ae:	9c 81       	ldd	r25, Y+4	; 0x04
    37b0:	90 93 a3 04 	sts	0x04A3, r25
    37b4:	80 93 a2 04 	sts	0x04A2, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    37b8:	80 91 a5 04 	lds	r24, 0x04A5
    37bc:	81 30       	cpi	r24, 0x01	; 1
    37be:	a9 f4       	brne	.+42     	; 0x37ea <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    37c0:	0e 94 2a 21 	call	0x4254	; 0x4254 <prvInitialiseTaskLists>
    37c4:	12 c0       	rjmp	.+36     	; 0x37ea <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    37c6:	80 91 aa 04 	lds	r24, 0x04AA
    37ca:	88 23       	and	r24, r24
    37cc:	71 f4       	brne	.+28     	; 0x37ea <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    37ce:	e0 91 a2 04 	lds	r30, 0x04A2
    37d2:	f0 91 a3 04 	lds	r31, 0x04A3
    37d6:	96 89       	ldd	r25, Z+22	; 0x16
    37d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    37da:	89 17       	cp	r24, r25
    37dc:	30 f0       	brcs	.+12     	; 0x37ea <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    37de:	8b 81       	ldd	r24, Y+3	; 0x03
    37e0:	9c 81       	ldd	r25, Y+4	; 0x04
    37e2:	90 93 a3 04 	sts	0x04A3, r25
    37e6:	80 93 a2 04 	sts	0x04A2, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    37ea:	eb 81       	ldd	r30, Y+3	; 0x03
    37ec:	fc 81       	ldd	r31, Y+4	; 0x04
    37ee:	96 89       	ldd	r25, Z+22	; 0x16
    37f0:	80 91 a8 04 	lds	r24, 0x04A8
    37f4:	89 17       	cp	r24, r25
    37f6:	28 f4       	brcc	.+10     	; 0x3802 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    37f8:	eb 81       	ldd	r30, Y+3	; 0x03
    37fa:	fc 81       	ldd	r31, Y+4	; 0x04
    37fc:	86 89       	ldd	r24, Z+22	; 0x16
    37fe:	80 93 a8 04 	sts	0x04A8, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    3802:	80 91 af 04 	lds	r24, 0x04AF
    3806:	8f 5f       	subi	r24, 0xFF	; 255
    3808:	80 93 af 04 	sts	0x04AF, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    380c:	eb 81       	ldd	r30, Y+3	; 0x03
    380e:	fc 81       	ldd	r31, Y+4	; 0x04
    3810:	96 89       	ldd	r25, Z+22	; 0x16
    3812:	80 91 a9 04 	lds	r24, 0x04A9
    3816:	89 17       	cp	r24, r25
    3818:	28 f4       	brcc	.+10     	; 0x3824 <xTaskGenericCreate+0x152>
    381a:	eb 81       	ldd	r30, Y+3	; 0x03
    381c:	fc 81       	ldd	r31, Y+4	; 0x04
    381e:	86 89       	ldd	r24, Z+22	; 0x16
    3820:	80 93 a9 04 	sts	0x04A9, r24
    3824:	eb 81       	ldd	r30, Y+3	; 0x03
    3826:	fc 81       	ldd	r31, Y+4	; 0x04
    3828:	86 89       	ldd	r24, Z+22	; 0x16
    382a:	28 2f       	mov	r18, r24
    382c:	30 e0       	ldi	r19, 0x00	; 0
    382e:	c9 01       	movw	r24, r18
    3830:	88 0f       	add	r24, r24
    3832:	99 1f       	adc	r25, r25
    3834:	88 0f       	add	r24, r24
    3836:	99 1f       	adc	r25, r25
    3838:	88 0f       	add	r24, r24
    383a:	99 1f       	adc	r25, r25
    383c:	82 0f       	add	r24, r18
    383e:	93 1f       	adc	r25, r19
    3840:	ac 01       	movw	r20, r24
    3842:	40 55       	subi	r20, 0x50	; 80
    3844:	5b 4f       	sbci	r21, 0xFB	; 251
    3846:	8b 81       	ldd	r24, Y+3	; 0x03
    3848:	9c 81       	ldd	r25, Y+4	; 0x04
    384a:	9c 01       	movw	r18, r24
    384c:	2e 5f       	subi	r18, 0xFE	; 254
    384e:	3f 4f       	sbci	r19, 0xFF	; 255
    3850:	ca 01       	movw	r24, r20
    3852:	b9 01       	movw	r22, r18
    3854:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>

			xReturn = pdPASS;
    3858:	81 e0       	ldi	r24, 0x01	; 1
    385a:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    385c:	0f 90       	pop	r0
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	02 c0       	rjmp	.+4      	; 0x3866 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3862:	8f ef       	ldi	r24, 0xFF	; 255
    3864:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    3866:	8d 81       	ldd	r24, Y+5	; 0x05
    3868:	81 30       	cpi	r24, 0x01	; 1
    386a:	71 f4       	brne	.+28     	; 0x3888 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    386c:	80 91 aa 04 	lds	r24, 0x04AA
    3870:	88 23       	and	r24, r24
    3872:	51 f0       	breq	.+20     	; 0x3888 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    3874:	e0 91 a2 04 	lds	r30, 0x04A2
    3878:	f0 91 a3 04 	lds	r31, 0x04A3
    387c:	96 89       	ldd	r25, Z+22	; 0x16
    387e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3880:	98 17       	cp	r25, r24
    3882:	10 f4       	brcc	.+4      	; 0x3888 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    3884:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
			}
		}
	}

	return xReturn;
    3888:	8d 81       	ldd	r24, Y+5	; 0x05
}
    388a:	64 96       	adiw	r28, 0x14	; 20
    388c:	0f b6       	in	r0, 0x3f	; 63
    388e:	f8 94       	cli
    3890:	de bf       	out	0x3e, r29	; 62
    3892:	0f be       	out	0x3f, r0	; 63
    3894:	cd bf       	out	0x3d, r28	; 61
    3896:	cf 91       	pop	r28
    3898:	df 91       	pop	r29
    389a:	1f 91       	pop	r17
    389c:	0f 91       	pop	r16
    389e:	ff 90       	pop	r15
    38a0:	ef 90       	pop	r14
    38a2:	df 90       	pop	r13
    38a4:	cf 90       	pop	r12
    38a6:	bf 90       	pop	r11
    38a8:	af 90       	pop	r10
    38aa:	08 95       	ret

000038ac <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    38ac:	df 93       	push	r29
    38ae:	cf 93       	push	r28
    38b0:	00 d0       	rcall	.+0      	; 0x38b2 <vTaskDelete+0x6>
    38b2:	00 d0       	rcall	.+0      	; 0x38b4 <vTaskDelete+0x8>
    38b4:	00 d0       	rcall	.+0      	; 0x38b6 <vTaskDelete+0xa>
    38b6:	cd b7       	in	r28, 0x3d	; 61
    38b8:	de b7       	in	r29, 0x3e	; 62
    38ba:	9c 83       	std	Y+4, r25	; 0x04
    38bc:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    38be:	0f b6       	in	r0, 0x3f	; 63
    38c0:	f8 94       	cli
    38c2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    38c4:	20 91 a2 04 	lds	r18, 0x04A2
    38c8:	30 91 a3 04 	lds	r19, 0x04A3
    38cc:	8b 81       	ldd	r24, Y+3	; 0x03
    38ce:	9c 81       	ldd	r25, Y+4	; 0x04
    38d0:	82 17       	cp	r24, r18
    38d2:	93 07       	cpc	r25, r19
    38d4:	11 f4       	brne	.+4      	; 0x38da <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    38d6:	1c 82       	std	Y+4, r1	; 0x04
    38d8:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    38da:	8b 81       	ldd	r24, Y+3	; 0x03
    38dc:	9c 81       	ldd	r25, Y+4	; 0x04
    38de:	00 97       	sbiw	r24, 0x00	; 0
    38e0:	39 f4       	brne	.+14     	; 0x38f0 <vTaskDelete+0x44>
    38e2:	80 91 a2 04 	lds	r24, 0x04A2
    38e6:	90 91 a3 04 	lds	r25, 0x04A3
    38ea:	9e 83       	std	Y+6, r25	; 0x06
    38ec:	8d 83       	std	Y+5, r24	; 0x05
    38ee:	04 c0       	rjmp	.+8      	; 0x38f8 <vTaskDelete+0x4c>
    38f0:	8b 81       	ldd	r24, Y+3	; 0x03
    38f2:	9c 81       	ldd	r25, Y+4	; 0x04
    38f4:	9e 83       	std	Y+6, r25	; 0x06
    38f6:	8d 83       	std	Y+5, r24	; 0x05
    38f8:	8d 81       	ldd	r24, Y+5	; 0x05
    38fa:	9e 81       	ldd	r25, Y+6	; 0x06
    38fc:	9a 83       	std	Y+2, r25	; 0x02
    38fe:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    3900:	89 81       	ldd	r24, Y+1	; 0x01
    3902:	9a 81       	ldd	r25, Y+2	; 0x02
    3904:	02 96       	adiw	r24, 0x02	; 2
    3906:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    390a:	e9 81       	ldd	r30, Y+1	; 0x01
    390c:	fa 81       	ldd	r31, Y+2	; 0x02
    390e:	84 89       	ldd	r24, Z+20	; 0x14
    3910:	95 89       	ldd	r25, Z+21	; 0x15
    3912:	00 97       	sbiw	r24, 0x00	; 0
    3914:	29 f0       	breq	.+10     	; 0x3920 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    3916:	89 81       	ldd	r24, Y+1	; 0x01
    3918:	9a 81       	ldd	r25, Y+2	; 0x02
    391a:	0c 96       	adiw	r24, 0x0c	; 12
    391c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    3920:	89 81       	ldd	r24, Y+1	; 0x01
    3922:	9a 81       	ldd	r25, Y+2	; 0x02
    3924:	9c 01       	movw	r18, r24
    3926:	2e 5f       	subi	r18, 0xFE	; 254
    3928:	3f 4f       	sbci	r19, 0xFF	; 255
    392a:	85 e0       	ldi	r24, 0x05	; 5
    392c:	95 e0       	ldi	r25, 0x05	; 5
    392e:	b9 01       	movw	r22, r18
    3930:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    3934:	80 91 a4 04 	lds	r24, 0x04A4
    3938:	8f 5f       	subi	r24, 0xFF	; 255
    393a:	80 93 a4 04 	sts	0x04A4, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    393e:	80 91 af 04 	lds	r24, 0x04AF
    3942:	8f 5f       	subi	r24, 0xFF	; 255
    3944:	80 93 af 04 	sts	0x04AF, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    3948:	0f 90       	pop	r0
    394a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    394c:	80 91 aa 04 	lds	r24, 0x04AA
    3950:	88 23       	and	r24, r24
    3952:	31 f0       	breq	.+12     	; 0x3960 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    3954:	8b 81       	ldd	r24, Y+3	; 0x03
    3956:	9c 81       	ldd	r25, Y+4	; 0x04
    3958:	00 97       	sbiw	r24, 0x00	; 0
    395a:	11 f4       	brne	.+4      	; 0x3960 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    395c:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
			}
		}
	}
    3960:	26 96       	adiw	r28, 0x06	; 6
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	f8 94       	cli
    3966:	de bf       	out	0x3e, r29	; 62
    3968:	0f be       	out	0x3f, r0	; 63
    396a:	cd bf       	out	0x3d, r28	; 61
    396c:	cf 91       	pop	r28
    396e:	df 91       	pop	r29
    3970:	08 95       	ret

00003972 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3972:	df 93       	push	r29
    3974:	cf 93       	push	r28
    3976:	cd b7       	in	r28, 0x3d	; 61
    3978:	de b7       	in	r29, 0x3e	; 62
    397a:	28 97       	sbiw	r28, 0x08	; 8
    397c:	0f b6       	in	r0, 0x3f	; 63
    397e:	f8 94       	cli
    3980:	de bf       	out	0x3e, r29	; 62
    3982:	0f be       	out	0x3f, r0	; 63
    3984:	cd bf       	out	0x3d, r28	; 61
    3986:	9e 83       	std	Y+6, r25	; 0x06
    3988:	8d 83       	std	Y+5, r24	; 0x05
    398a:	78 87       	std	Y+8, r23	; 0x08
    398c:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    398e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3990:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3994:	ed 81       	ldd	r30, Y+5	; 0x05
    3996:	fe 81       	ldd	r31, Y+6	; 0x06
    3998:	20 81       	ld	r18, Z
    399a:	31 81       	ldd	r19, Z+1	; 0x01
    399c:	8f 81       	ldd	r24, Y+7	; 0x07
    399e:	98 85       	ldd	r25, Y+8	; 0x08
    39a0:	82 0f       	add	r24, r18
    39a2:	93 1f       	adc	r25, r19
    39a4:	9c 83       	std	Y+4, r25	; 0x04
    39a6:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    39a8:	ed 81       	ldd	r30, Y+5	; 0x05
    39aa:	fe 81       	ldd	r31, Y+6	; 0x06
    39ac:	20 81       	ld	r18, Z
    39ae:	31 81       	ldd	r19, Z+1	; 0x01
    39b0:	80 91 a6 04 	lds	r24, 0x04A6
    39b4:	90 91 a7 04 	lds	r25, 0x04A7
    39b8:	82 17       	cp	r24, r18
    39ba:	93 07       	cpc	r25, r19
    39bc:	a8 f4       	brcc	.+42     	; 0x39e8 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    39be:	ed 81       	ldd	r30, Y+5	; 0x05
    39c0:	fe 81       	ldd	r31, Y+6	; 0x06
    39c2:	20 81       	ld	r18, Z
    39c4:	31 81       	ldd	r19, Z+1	; 0x01
    39c6:	8b 81       	ldd	r24, Y+3	; 0x03
    39c8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ca:	82 17       	cp	r24, r18
    39cc:	93 07       	cpc	r25, r19
    39ce:	00 f5       	brcc	.+64     	; 0x3a10 <vTaskDelayUntil+0x9e>
    39d0:	20 91 a6 04 	lds	r18, 0x04A6
    39d4:	30 91 a7 04 	lds	r19, 0x04A7
    39d8:	8b 81       	ldd	r24, Y+3	; 0x03
    39da:	9c 81       	ldd	r25, Y+4	; 0x04
    39dc:	28 17       	cp	r18, r24
    39de:	39 07       	cpc	r19, r25
    39e0:	b8 f4       	brcc	.+46     	; 0x3a10 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    39e2:	81 e0       	ldi	r24, 0x01	; 1
    39e4:	89 83       	std	Y+1, r24	; 0x01
    39e6:	14 c0       	rjmp	.+40     	; 0x3a10 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    39e8:	ed 81       	ldd	r30, Y+5	; 0x05
    39ea:	fe 81       	ldd	r31, Y+6	; 0x06
    39ec:	20 81       	ld	r18, Z
    39ee:	31 81       	ldd	r19, Z+1	; 0x01
    39f0:	8b 81       	ldd	r24, Y+3	; 0x03
    39f2:	9c 81       	ldd	r25, Y+4	; 0x04
    39f4:	82 17       	cp	r24, r18
    39f6:	93 07       	cpc	r25, r19
    39f8:	48 f0       	brcs	.+18     	; 0x3a0c <vTaskDelayUntil+0x9a>
    39fa:	20 91 a6 04 	lds	r18, 0x04A6
    39fe:	30 91 a7 04 	lds	r19, 0x04A7
    3a02:	8b 81       	ldd	r24, Y+3	; 0x03
    3a04:	9c 81       	ldd	r25, Y+4	; 0x04
    3a06:	28 17       	cp	r18, r24
    3a08:	39 07       	cpc	r19, r25
    3a0a:	10 f4       	brcc	.+4      	; 0x3a10 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    3a0c:	81 e0       	ldi	r24, 0x01	; 1
    3a0e:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3a10:	ed 81       	ldd	r30, Y+5	; 0x05
    3a12:	fe 81       	ldd	r31, Y+6	; 0x06
    3a14:	8b 81       	ldd	r24, Y+3	; 0x03
    3a16:	9c 81       	ldd	r25, Y+4	; 0x04
    3a18:	91 83       	std	Z+1, r25	; 0x01
    3a1a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    3a1c:	89 81       	ldd	r24, Y+1	; 0x01
    3a1e:	88 23       	and	r24, r24
    3a20:	59 f0       	breq	.+22     	; 0x3a38 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3a22:	80 91 a2 04 	lds	r24, 0x04A2
    3a26:	90 91 a3 04 	lds	r25, 0x04A3
    3a2a:	02 96       	adiw	r24, 0x02	; 2
    3a2c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a30:	8b 81       	ldd	r24, Y+3	; 0x03
    3a32:	9c 81       	ldd	r25, Y+4	; 0x04
    3a34:	0e 94 a5 21 	call	0x434a	; 0x434a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3a38:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    3a3c:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a40:	88 23       	and	r24, r24
    3a42:	11 f4       	brne	.+4      	; 0x3a48 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    3a44:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
		}
	}
    3a48:	28 96       	adiw	r28, 0x08	; 8
    3a4a:	0f b6       	in	r0, 0x3f	; 63
    3a4c:	f8 94       	cli
    3a4e:	de bf       	out	0x3e, r29	; 62
    3a50:	0f be       	out	0x3f, r0	; 63
    3a52:	cd bf       	out	0x3d, r28	; 61
    3a54:	cf 91       	pop	r28
    3a56:	df 91       	pop	r29
    3a58:	08 95       	ret

00003a5a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    3a5a:	df 93       	push	r29
    3a5c:	cf 93       	push	r28
    3a5e:	00 d0       	rcall	.+0      	; 0x3a60 <vTaskDelay+0x6>
    3a60:	00 d0       	rcall	.+0      	; 0x3a62 <vTaskDelay+0x8>
    3a62:	0f 92       	push	r0
    3a64:	cd b7       	in	r28, 0x3d	; 61
    3a66:	de b7       	in	r29, 0x3e	; 62
    3a68:	9d 83       	std	Y+5, r25	; 0x05
    3a6a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3a6c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    3a6e:	8c 81       	ldd	r24, Y+4	; 0x04
    3a70:	9d 81       	ldd	r25, Y+5	; 0x05
    3a72:	00 97       	sbiw	r24, 0x00	; 0
    3a74:	d1 f0       	breq	.+52     	; 0x3aaa <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    3a76:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    3a7a:	20 91 a6 04 	lds	r18, 0x04A6
    3a7e:	30 91 a7 04 	lds	r19, 0x04A7
    3a82:	8c 81       	ldd	r24, Y+4	; 0x04
    3a84:	9d 81       	ldd	r25, Y+5	; 0x05
    3a86:	82 0f       	add	r24, r18
    3a88:	93 1f       	adc	r25, r19
    3a8a:	9b 83       	std	Y+3, r25	; 0x03
    3a8c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3a8e:	80 91 a2 04 	lds	r24, 0x04A2
    3a92:	90 91 a3 04 	lds	r25, 0x04A3
    3a96:	02 96       	adiw	r24, 0x02	; 2
    3a98:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    3a9c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a9e:	9b 81       	ldd	r25, Y+3	; 0x03
    3aa0:	0e 94 a5 21 	call	0x434a	; 0x434a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3aa4:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>
    3aa8:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3aaa:	89 81       	ldd	r24, Y+1	; 0x01
    3aac:	88 23       	and	r24, r24
    3aae:	11 f4       	brne	.+4      	; 0x3ab4 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    3ab0:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
		}
	}
    3ab4:	0f 90       	pop	r0
    3ab6:	0f 90       	pop	r0
    3ab8:	0f 90       	pop	r0
    3aba:	0f 90       	pop	r0
    3abc:	0f 90       	pop	r0
    3abe:	cf 91       	pop	r28
    3ac0:	df 91       	pop	r29
    3ac2:	08 95       	ret

00003ac4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    3ac4:	af 92       	push	r10
    3ac6:	bf 92       	push	r11
    3ac8:	cf 92       	push	r12
    3aca:	df 92       	push	r13
    3acc:	ef 92       	push	r14
    3ace:	ff 92       	push	r15
    3ad0:	0f 93       	push	r16
    3ad2:	df 93       	push	r29
    3ad4:	cf 93       	push	r28
    3ad6:	0f 92       	push	r0
    3ad8:	cd b7       	in	r28, 0x3d	; 61
    3ada:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    3adc:	2a e6       	ldi	r18, 0x6A	; 106
    3ade:	30 e0       	ldi	r19, 0x00	; 0
    3ae0:	89 ec       	ldi	r24, 0xC9	; 201
    3ae2:	90 e2       	ldi	r25, 0x20	; 32
    3ae4:	b9 01       	movw	r22, r18
    3ae6:	4a ef       	ldi	r20, 0xFA	; 250
    3ae8:	50 e0       	ldi	r21, 0x00	; 0
    3aea:	20 e0       	ldi	r18, 0x00	; 0
    3aec:	30 e0       	ldi	r19, 0x00	; 0
    3aee:	00 e0       	ldi	r16, 0x00	; 0
    3af0:	ee 24       	eor	r14, r14
    3af2:	ff 24       	eor	r15, r15
    3af4:	cc 24       	eor	r12, r12
    3af6:	dd 24       	eor	r13, r13
    3af8:	aa 24       	eor	r10, r10
    3afa:	bb 24       	eor	r11, r11
    3afc:	0e 94 69 1b 	call	0x36d2	; 0x36d2 <xTaskGenericCreate>
    3b00:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    3b02:	89 81       	ldd	r24, Y+1	; 0x01
    3b04:	81 30       	cpi	r24, 0x01	; 1
    3b06:	51 f4       	brne	.+20     	; 0x3b1c <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    3b08:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    3b0a:	81 e0       	ldi	r24, 0x01	; 1
    3b0c:	80 93 aa 04 	sts	0x04AA, r24
		xTickCount = ( portTickType ) 0U;
    3b10:	10 92 a7 04 	sts	0x04A7, r1
    3b14:	10 92 a6 04 	sts	0x04A6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    3b18:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    3b1c:	0f 90       	pop	r0
    3b1e:	cf 91       	pop	r28
    3b20:	df 91       	pop	r29
    3b22:	0f 91       	pop	r16
    3b24:	ff 90       	pop	r15
    3b26:	ef 90       	pop	r14
    3b28:	df 90       	pop	r13
    3b2a:	cf 90       	pop	r12
    3b2c:	bf 90       	pop	r11
    3b2e:	af 90       	pop	r10
    3b30:	08 95       	ret

00003b32 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3b32:	df 93       	push	r29
    3b34:	cf 93       	push	r28
    3b36:	cd b7       	in	r28, 0x3d	; 61
    3b38:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    3b3a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3b3c:	10 92 aa 04 	sts	0x04AA, r1
	vPortEndScheduler();
    3b40:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <vPortEndScheduler>
}
    3b44:	cf 91       	pop	r28
    3b46:	df 91       	pop	r29
    3b48:	08 95       	ret

00003b4a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3b4a:	df 93       	push	r29
    3b4c:	cf 93       	push	r28
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    3b52:	80 91 ab 04 	lds	r24, 0x04AB
    3b56:	8f 5f       	subi	r24, 0xFF	; 255
    3b58:	80 93 ab 04 	sts	0x04AB, r24
}
    3b5c:	cf 91       	pop	r28
    3b5e:	df 91       	pop	r29
    3b60:	08 95       	ret

00003b62 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    3b62:	df 93       	push	r29
    3b64:	cf 93       	push	r28
    3b66:	00 d0       	rcall	.+0      	; 0x3b68 <xTaskResumeAll+0x6>
    3b68:	00 d0       	rcall	.+0      	; 0x3b6a <xTaskResumeAll+0x8>
    3b6a:	cd b7       	in	r28, 0x3d	; 61
    3b6c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    3b6e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    3b70:	0f b6       	in	r0, 0x3f	; 63
    3b72:	f8 94       	cli
    3b74:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3b76:	80 91 ab 04 	lds	r24, 0x04AB
    3b7a:	81 50       	subi	r24, 0x01	; 1
    3b7c:	80 93 ab 04 	sts	0x04AB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3b80:	80 91 ab 04 	lds	r24, 0x04AB
    3b84:	88 23       	and	r24, r24
    3b86:	09 f0       	breq	.+2      	; 0x3b8a <xTaskResumeAll+0x28>
    3b88:	6c c0       	rjmp	.+216    	; 0x3c62 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    3b8a:	80 91 a5 04 	lds	r24, 0x04A5
    3b8e:	88 23       	and	r24, r24
    3b90:	09 f4       	brne	.+2      	; 0x3b94 <xTaskResumeAll+0x32>
    3b92:	67 c0       	rjmp	.+206    	; 0x3c62 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    3b94:	19 82       	std	Y+1, r1	; 0x01
    3b96:	41 c0       	rjmp	.+130    	; 0x3c1a <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    3b98:	e0 91 01 05 	lds	r30, 0x0501
    3b9c:	f0 91 02 05 	lds	r31, 0x0502
    3ba0:	86 81       	ldd	r24, Z+6	; 0x06
    3ba2:	97 81       	ldd	r25, Z+7	; 0x07
    3ba4:	9c 83       	std	Y+4, r25	; 0x04
    3ba6:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    3ba8:	8b 81       	ldd	r24, Y+3	; 0x03
    3baa:	9c 81       	ldd	r25, Y+4	; 0x04
    3bac:	0c 96       	adiw	r24, 0x0c	; 12
    3bae:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    3bb2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bb4:	9c 81       	ldd	r25, Y+4	; 0x04
    3bb6:	02 96       	adiw	r24, 0x02	; 2
    3bb8:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    3bbc:	eb 81       	ldd	r30, Y+3	; 0x03
    3bbe:	fc 81       	ldd	r31, Y+4	; 0x04
    3bc0:	96 89       	ldd	r25, Z+22	; 0x16
    3bc2:	80 91 a9 04 	lds	r24, 0x04A9
    3bc6:	89 17       	cp	r24, r25
    3bc8:	28 f4       	brcc	.+10     	; 0x3bd4 <xTaskResumeAll+0x72>
    3bca:	eb 81       	ldd	r30, Y+3	; 0x03
    3bcc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bce:	86 89       	ldd	r24, Z+22	; 0x16
    3bd0:	80 93 a9 04 	sts	0x04A9, r24
    3bd4:	eb 81       	ldd	r30, Y+3	; 0x03
    3bd6:	fc 81       	ldd	r31, Y+4	; 0x04
    3bd8:	86 89       	ldd	r24, Z+22	; 0x16
    3bda:	28 2f       	mov	r18, r24
    3bdc:	30 e0       	ldi	r19, 0x00	; 0
    3bde:	c9 01       	movw	r24, r18
    3be0:	88 0f       	add	r24, r24
    3be2:	99 1f       	adc	r25, r25
    3be4:	88 0f       	add	r24, r24
    3be6:	99 1f       	adc	r25, r25
    3be8:	88 0f       	add	r24, r24
    3bea:	99 1f       	adc	r25, r25
    3bec:	82 0f       	add	r24, r18
    3bee:	93 1f       	adc	r25, r19
    3bf0:	80 55       	subi	r24, 0x50	; 80
    3bf2:	9b 4f       	sbci	r25, 0xFB	; 251
    3bf4:	2b 81       	ldd	r18, Y+3	; 0x03
    3bf6:	3c 81       	ldd	r19, Y+4	; 0x04
    3bf8:	2e 5f       	subi	r18, 0xFE	; 254
    3bfa:	3f 4f       	sbci	r19, 0xFF	; 255
    3bfc:	b9 01       	movw	r22, r18
    3bfe:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3c02:	eb 81       	ldd	r30, Y+3	; 0x03
    3c04:	fc 81       	ldd	r31, Y+4	; 0x04
    3c06:	96 89       	ldd	r25, Z+22	; 0x16
    3c08:	e0 91 a2 04 	lds	r30, 0x04A2
    3c0c:	f0 91 a3 04 	lds	r31, 0x04A3
    3c10:	86 89       	ldd	r24, Z+22	; 0x16
    3c12:	98 17       	cp	r25, r24
    3c14:	10 f0       	brcs	.+4      	; 0x3c1a <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    3c16:	81 e0       	ldi	r24, 0x01	; 1
    3c18:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    3c1a:	80 91 fc 04 	lds	r24, 0x04FC
    3c1e:	88 23       	and	r24, r24
    3c20:	09 f0       	breq	.+2      	; 0x3c24 <xTaskResumeAll+0xc2>
    3c22:	ba cf       	rjmp	.-140    	; 0x3b98 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3c24:	80 91 ac 04 	lds	r24, 0x04AC
    3c28:	88 23       	and	r24, r24
    3c2a:	71 f0       	breq	.+28     	; 0x3c48 <xTaskResumeAll+0xe6>
    3c2c:	07 c0       	rjmp	.+14     	; 0x3c3c <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    3c2e:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <vTaskIncrementTick>
						--uxMissedTicks;
    3c32:	80 91 ac 04 	lds	r24, 0x04AC
    3c36:	81 50       	subi	r24, 0x01	; 1
    3c38:	80 93 ac 04 	sts	0x04AC, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3c3c:	80 91 ac 04 	lds	r24, 0x04AC
    3c40:	88 23       	and	r24, r24
    3c42:	a9 f7       	brne	.-22     	; 0x3c2e <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    3c44:	81 e0       	ldi	r24, 0x01	; 1
    3c46:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    3c48:	89 81       	ldd	r24, Y+1	; 0x01
    3c4a:	81 30       	cpi	r24, 0x01	; 1
    3c4c:	21 f0       	breq	.+8      	; 0x3c56 <xTaskResumeAll+0xf4>
    3c4e:	80 91 ad 04 	lds	r24, 0x04AD
    3c52:	81 30       	cpi	r24, 0x01	; 1
    3c54:	31 f4       	brne	.+12     	; 0x3c62 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    3c56:	81 e0       	ldi	r24, 0x01	; 1
    3c58:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    3c5a:	10 92 ad 04 	sts	0x04AD, r1
					portYIELD_WITHIN_API();
    3c5e:	0e 94 d5 15 	call	0x2baa	; 0x2baa <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    3c62:	0f 90       	pop	r0
    3c64:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3c66:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3c68:	0f 90       	pop	r0
    3c6a:	0f 90       	pop	r0
    3c6c:	0f 90       	pop	r0
    3c6e:	0f 90       	pop	r0
    3c70:	cf 91       	pop	r28
    3c72:	df 91       	pop	r29
    3c74:	08 95       	ret

00003c76 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    3c76:	df 93       	push	r29
    3c78:	cf 93       	push	r28
    3c7a:	00 d0       	rcall	.+0      	; 0x3c7c <xTaskGetTickCount+0x6>
    3c7c:	cd b7       	in	r28, 0x3d	; 61
    3c7e:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    3c80:	0f b6       	in	r0, 0x3f	; 63
    3c82:	f8 94       	cli
    3c84:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3c86:	80 91 a6 04 	lds	r24, 0x04A6
    3c8a:	90 91 a7 04 	lds	r25, 0x04A7
    3c8e:	9a 83       	std	Y+2, r25	; 0x02
    3c90:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3c92:	0f 90       	pop	r0
    3c94:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3c96:	89 81       	ldd	r24, Y+1	; 0x01
    3c98:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c9a:	0f 90       	pop	r0
    3c9c:	0f 90       	pop	r0
    3c9e:	cf 91       	pop	r28
    3ca0:	df 91       	pop	r29
    3ca2:	08 95       	ret

00003ca4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    3ca4:	df 93       	push	r29
    3ca6:	cf 93       	push	r28
    3ca8:	00 d0       	rcall	.+0      	; 0x3caa <xTaskGetTickCountFromISR+0x6>
    3caa:	0f 92       	push	r0
    3cac:	cd b7       	in	r28, 0x3d	; 61
    3cae:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3cb0:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    3cb2:	80 91 a6 04 	lds	r24, 0x04A6
    3cb6:	90 91 a7 04 	lds	r25, 0x04A7
    3cba:	9b 83       	std	Y+3, r25	; 0x03
    3cbc:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3cbe:	8a 81       	ldd	r24, Y+2	; 0x02
    3cc0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3cc2:	0f 90       	pop	r0
    3cc4:	0f 90       	pop	r0
    3cc6:	0f 90       	pop	r0
    3cc8:	cf 91       	pop	r28
    3cca:	df 91       	pop	r29
    3ccc:	08 95       	ret

00003cce <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3cce:	df 93       	push	r29
    3cd0:	cf 93       	push	r28
    3cd2:	cd b7       	in	r28, 0x3d	; 61
    3cd4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    3cd6:	80 91 a5 04 	lds	r24, 0x04A5
}
    3cda:	cf 91       	pop	r28
    3cdc:	df 91       	pop	r29
    3cde:	08 95       	ret

00003ce0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3ce0:	df 93       	push	r29
    3ce2:	cf 93       	push	r28
    3ce4:	00 d0       	rcall	.+0      	; 0x3ce6 <vTaskIncrementTick+0x6>
    3ce6:	00 d0       	rcall	.+0      	; 0x3ce8 <vTaskIncrementTick+0x8>
    3ce8:	00 d0       	rcall	.+0      	; 0x3cea <vTaskIncrementTick+0xa>
    3cea:	cd b7       	in	r28, 0x3d	; 61
    3cec:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3cee:	80 91 ab 04 	lds	r24, 0x04AB
    3cf2:	88 23       	and	r24, r24
    3cf4:	09 f0       	breq	.+2      	; 0x3cf8 <vTaskIncrementTick+0x18>
    3cf6:	bb c0       	rjmp	.+374    	; 0x3e6e <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3cf8:	80 91 a6 04 	lds	r24, 0x04A6
    3cfc:	90 91 a7 04 	lds	r25, 0x04A7
    3d00:	01 96       	adiw	r24, 0x01	; 1
    3d02:	90 93 a7 04 	sts	0x04A7, r25
    3d06:	80 93 a6 04 	sts	0x04A6, r24
		if( xTickCount == ( portTickType ) 0U )
    3d0a:	80 91 a6 04 	lds	r24, 0x04A6
    3d0e:	90 91 a7 04 	lds	r25, 0x04A7
    3d12:	00 97       	sbiw	r24, 0x00	; 0
    3d14:	d1 f5       	brne	.+116    	; 0x3d8a <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    3d16:	80 91 f8 04 	lds	r24, 0x04F8
    3d1a:	90 91 f9 04 	lds	r25, 0x04F9
    3d1e:	9c 83       	std	Y+4, r25	; 0x04
    3d20:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3d22:	80 91 fa 04 	lds	r24, 0x04FA
    3d26:	90 91 fb 04 	lds	r25, 0x04FB
    3d2a:	90 93 f9 04 	sts	0x04F9, r25
    3d2e:	80 93 f8 04 	sts	0x04F8, r24
			pxOverflowDelayedTaskList = pxTemp;
    3d32:	8b 81       	ldd	r24, Y+3	; 0x03
    3d34:	9c 81       	ldd	r25, Y+4	; 0x04
    3d36:	90 93 fb 04 	sts	0x04FB, r25
    3d3a:	80 93 fa 04 	sts	0x04FA, r24
			xNumOfOverflows++;
    3d3e:	80 91 ae 04 	lds	r24, 0x04AE
    3d42:	8f 5f       	subi	r24, 0xFF	; 255
    3d44:	80 93 ae 04 	sts	0x04AE, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3d48:	e0 91 f8 04 	lds	r30, 0x04F8
    3d4c:	f0 91 f9 04 	lds	r31, 0x04F9
    3d50:	80 81       	ld	r24, Z
    3d52:	88 23       	and	r24, r24
    3d54:	39 f4       	brne	.+14     	; 0x3d64 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    3d56:	8f ef       	ldi	r24, 0xFF	; 255
    3d58:	9f ef       	ldi	r25, 0xFF	; 255
    3d5a:	90 93 78 00 	sts	0x0078, r25
    3d5e:	80 93 77 00 	sts	0x0077, r24
    3d62:	13 c0       	rjmp	.+38     	; 0x3d8a <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    3d64:	e0 91 f8 04 	lds	r30, 0x04F8
    3d68:	f0 91 f9 04 	lds	r31, 0x04F9
    3d6c:	05 80       	ldd	r0, Z+5	; 0x05
    3d6e:	f6 81       	ldd	r31, Z+6	; 0x06
    3d70:	e0 2d       	mov	r30, r0
    3d72:	86 81       	ldd	r24, Z+6	; 0x06
    3d74:	97 81       	ldd	r25, Z+7	; 0x07
    3d76:	9e 83       	std	Y+6, r25	; 0x06
    3d78:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3d7a:	ed 81       	ldd	r30, Y+5	; 0x05
    3d7c:	fe 81       	ldd	r31, Y+6	; 0x06
    3d7e:	82 81       	ldd	r24, Z+2	; 0x02
    3d80:	93 81       	ldd	r25, Z+3	; 0x03
    3d82:	90 93 78 00 	sts	0x0078, r25
    3d86:	80 93 77 00 	sts	0x0077, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    3d8a:	20 91 a6 04 	lds	r18, 0x04A6
    3d8e:	30 91 a7 04 	lds	r19, 0x04A7
    3d92:	80 91 77 00 	lds	r24, 0x0077
    3d96:	90 91 78 00 	lds	r25, 0x0078
    3d9a:	28 17       	cp	r18, r24
    3d9c:	39 07       	cpc	r19, r25
    3d9e:	08 f4       	brcc	.+2      	; 0x3da2 <vTaskIncrementTick+0xc2>
    3da0:	6b c0       	rjmp	.+214    	; 0x3e78 <vTaskIncrementTick+0x198>
    3da2:	e0 91 f8 04 	lds	r30, 0x04F8
    3da6:	f0 91 f9 04 	lds	r31, 0x04F9
    3daa:	80 81       	ld	r24, Z
    3dac:	88 23       	and	r24, r24
    3dae:	39 f4       	brne	.+14     	; 0x3dbe <vTaskIncrementTick+0xde>
    3db0:	8f ef       	ldi	r24, 0xFF	; 255
    3db2:	9f ef       	ldi	r25, 0xFF	; 255
    3db4:	90 93 78 00 	sts	0x0078, r25
    3db8:	80 93 77 00 	sts	0x0077, r24
    3dbc:	5d c0       	rjmp	.+186    	; 0x3e78 <vTaskIncrementTick+0x198>
    3dbe:	e0 91 f8 04 	lds	r30, 0x04F8
    3dc2:	f0 91 f9 04 	lds	r31, 0x04F9
    3dc6:	05 80       	ldd	r0, Z+5	; 0x05
    3dc8:	f6 81       	ldd	r31, Z+6	; 0x06
    3dca:	e0 2d       	mov	r30, r0
    3dcc:	86 81       	ldd	r24, Z+6	; 0x06
    3dce:	97 81       	ldd	r25, Z+7	; 0x07
    3dd0:	9e 83       	std	Y+6, r25	; 0x06
    3dd2:	8d 83       	std	Y+5, r24	; 0x05
    3dd4:	ed 81       	ldd	r30, Y+5	; 0x05
    3dd6:	fe 81       	ldd	r31, Y+6	; 0x06
    3dd8:	82 81       	ldd	r24, Z+2	; 0x02
    3dda:	93 81       	ldd	r25, Z+3	; 0x03
    3ddc:	9a 83       	std	Y+2, r25	; 0x02
    3dde:	89 83       	std	Y+1, r24	; 0x01
    3de0:	20 91 a6 04 	lds	r18, 0x04A6
    3de4:	30 91 a7 04 	lds	r19, 0x04A7
    3de8:	89 81       	ldd	r24, Y+1	; 0x01
    3dea:	9a 81       	ldd	r25, Y+2	; 0x02
    3dec:	28 17       	cp	r18, r24
    3dee:	39 07       	cpc	r19, r25
    3df0:	38 f4       	brcc	.+14     	; 0x3e00 <vTaskIncrementTick+0x120>
    3df2:	89 81       	ldd	r24, Y+1	; 0x01
    3df4:	9a 81       	ldd	r25, Y+2	; 0x02
    3df6:	90 93 78 00 	sts	0x0078, r25
    3dfa:	80 93 77 00 	sts	0x0077, r24
    3dfe:	3c c0       	rjmp	.+120    	; 0x3e78 <vTaskIncrementTick+0x198>
    3e00:	8d 81       	ldd	r24, Y+5	; 0x05
    3e02:	9e 81       	ldd	r25, Y+6	; 0x06
    3e04:	02 96       	adiw	r24, 0x02	; 2
    3e06:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
    3e0a:	ed 81       	ldd	r30, Y+5	; 0x05
    3e0c:	fe 81       	ldd	r31, Y+6	; 0x06
    3e0e:	84 89       	ldd	r24, Z+20	; 0x14
    3e10:	95 89       	ldd	r25, Z+21	; 0x15
    3e12:	00 97       	sbiw	r24, 0x00	; 0
    3e14:	29 f0       	breq	.+10     	; 0x3e20 <vTaskIncrementTick+0x140>
    3e16:	8d 81       	ldd	r24, Y+5	; 0x05
    3e18:	9e 81       	ldd	r25, Y+6	; 0x06
    3e1a:	0c 96       	adiw	r24, 0x0c	; 12
    3e1c:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
    3e20:	ed 81       	ldd	r30, Y+5	; 0x05
    3e22:	fe 81       	ldd	r31, Y+6	; 0x06
    3e24:	96 89       	ldd	r25, Z+22	; 0x16
    3e26:	80 91 a9 04 	lds	r24, 0x04A9
    3e2a:	89 17       	cp	r24, r25
    3e2c:	28 f4       	brcc	.+10     	; 0x3e38 <vTaskIncrementTick+0x158>
    3e2e:	ed 81       	ldd	r30, Y+5	; 0x05
    3e30:	fe 81       	ldd	r31, Y+6	; 0x06
    3e32:	86 89       	ldd	r24, Z+22	; 0x16
    3e34:	80 93 a9 04 	sts	0x04A9, r24
    3e38:	ed 81       	ldd	r30, Y+5	; 0x05
    3e3a:	fe 81       	ldd	r31, Y+6	; 0x06
    3e3c:	86 89       	ldd	r24, Z+22	; 0x16
    3e3e:	28 2f       	mov	r18, r24
    3e40:	30 e0       	ldi	r19, 0x00	; 0
    3e42:	c9 01       	movw	r24, r18
    3e44:	88 0f       	add	r24, r24
    3e46:	99 1f       	adc	r25, r25
    3e48:	88 0f       	add	r24, r24
    3e4a:	99 1f       	adc	r25, r25
    3e4c:	88 0f       	add	r24, r24
    3e4e:	99 1f       	adc	r25, r25
    3e50:	82 0f       	add	r24, r18
    3e52:	93 1f       	adc	r25, r19
    3e54:	ac 01       	movw	r20, r24
    3e56:	40 55       	subi	r20, 0x50	; 80
    3e58:	5b 4f       	sbci	r21, 0xFB	; 251
    3e5a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e5c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e5e:	9c 01       	movw	r18, r24
    3e60:	2e 5f       	subi	r18, 0xFE	; 254
    3e62:	3f 4f       	sbci	r19, 0xFF	; 255
    3e64:	ca 01       	movw	r24, r20
    3e66:	b9 01       	movw	r22, r18
    3e68:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>
    3e6c:	9a cf       	rjmp	.-204    	; 0x3da2 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3e6e:	80 91 ac 04 	lds	r24, 0x04AC
    3e72:	8f 5f       	subi	r24, 0xFF	; 255
    3e74:	80 93 ac 04 	sts	0x04AC, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    3e78:	26 96       	adiw	r28, 0x06	; 6
    3e7a:	0f b6       	in	r0, 0x3f	; 63
    3e7c:	f8 94       	cli
    3e7e:	de bf       	out	0x3e, r29	; 62
    3e80:	0f be       	out	0x3f, r0	; 63
    3e82:	cd bf       	out	0x3d, r28	; 61
    3e84:	cf 91       	pop	r28
    3e86:	df 91       	pop	r29
    3e88:	08 95       	ret

00003e8a <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3e8a:	df 93       	push	r29
    3e8c:	cf 93       	push	r28
    3e8e:	00 d0       	rcall	.+0      	; 0x3e90 <vTaskSwitchContext+0x6>
    3e90:	cd b7       	in	r28, 0x3d	; 61
    3e92:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    3e94:	80 91 ab 04 	lds	r24, 0x04AB
    3e98:	88 23       	and	r24, r24
    3e9a:	49 f0       	breq	.+18     	; 0x3eae <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3e9c:	81 e0       	ldi	r24, 0x01	; 1
    3e9e:	80 93 ad 04 	sts	0x04AD, r24
    3ea2:	54 c0       	rjmp	.+168    	; 0x3f4c <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    3ea4:	80 91 a9 04 	lds	r24, 0x04A9
    3ea8:	81 50       	subi	r24, 0x01	; 1
    3eaa:	80 93 a9 04 	sts	0x04A9, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3eae:	80 91 a9 04 	lds	r24, 0x04A9
    3eb2:	28 2f       	mov	r18, r24
    3eb4:	30 e0       	ldi	r19, 0x00	; 0
    3eb6:	c9 01       	movw	r24, r18
    3eb8:	88 0f       	add	r24, r24
    3eba:	99 1f       	adc	r25, r25
    3ebc:	88 0f       	add	r24, r24
    3ebe:	99 1f       	adc	r25, r25
    3ec0:	88 0f       	add	r24, r24
    3ec2:	99 1f       	adc	r25, r25
    3ec4:	82 0f       	add	r24, r18
    3ec6:	93 1f       	adc	r25, r19
    3ec8:	fc 01       	movw	r30, r24
    3eca:	e0 55       	subi	r30, 0x50	; 80
    3ecc:	fb 4f       	sbci	r31, 0xFB	; 251
    3ece:	80 81       	ld	r24, Z
    3ed0:	88 23       	and	r24, r24
    3ed2:	41 f3       	breq	.-48     	; 0x3ea4 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    3ed4:	80 91 a9 04 	lds	r24, 0x04A9
    3ed8:	28 2f       	mov	r18, r24
    3eda:	30 e0       	ldi	r19, 0x00	; 0
    3edc:	c9 01       	movw	r24, r18
    3ede:	88 0f       	add	r24, r24
    3ee0:	99 1f       	adc	r25, r25
    3ee2:	88 0f       	add	r24, r24
    3ee4:	99 1f       	adc	r25, r25
    3ee6:	88 0f       	add	r24, r24
    3ee8:	99 1f       	adc	r25, r25
    3eea:	82 0f       	add	r24, r18
    3eec:	93 1f       	adc	r25, r19
    3eee:	80 55       	subi	r24, 0x50	; 80
    3ef0:	9b 4f       	sbci	r25, 0xFB	; 251
    3ef2:	9a 83       	std	Y+2, r25	; 0x02
    3ef4:	89 83       	std	Y+1, r24	; 0x01
    3ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    3ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    3efa:	01 80       	ldd	r0, Z+1	; 0x01
    3efc:	f2 81       	ldd	r31, Z+2	; 0x02
    3efe:	e0 2d       	mov	r30, r0
    3f00:	82 81       	ldd	r24, Z+2	; 0x02
    3f02:	93 81       	ldd	r25, Z+3	; 0x03
    3f04:	e9 81       	ldd	r30, Y+1	; 0x01
    3f06:	fa 81       	ldd	r31, Y+2	; 0x02
    3f08:	92 83       	std	Z+2, r25	; 0x02
    3f0a:	81 83       	std	Z+1, r24	; 0x01
    3f0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3f10:	21 81       	ldd	r18, Z+1	; 0x01
    3f12:	32 81       	ldd	r19, Z+2	; 0x02
    3f14:	89 81       	ldd	r24, Y+1	; 0x01
    3f16:	9a 81       	ldd	r25, Y+2	; 0x02
    3f18:	03 96       	adiw	r24, 0x03	; 3
    3f1a:	28 17       	cp	r18, r24
    3f1c:	39 07       	cpc	r19, r25
    3f1e:	59 f4       	brne	.+22     	; 0x3f36 <vTaskSwitchContext+0xac>
    3f20:	e9 81       	ldd	r30, Y+1	; 0x01
    3f22:	fa 81       	ldd	r31, Y+2	; 0x02
    3f24:	01 80       	ldd	r0, Z+1	; 0x01
    3f26:	f2 81       	ldd	r31, Z+2	; 0x02
    3f28:	e0 2d       	mov	r30, r0
    3f2a:	82 81       	ldd	r24, Z+2	; 0x02
    3f2c:	93 81       	ldd	r25, Z+3	; 0x03
    3f2e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f30:	fa 81       	ldd	r31, Y+2	; 0x02
    3f32:	92 83       	std	Z+2, r25	; 0x02
    3f34:	81 83       	std	Z+1, r24	; 0x01
    3f36:	e9 81       	ldd	r30, Y+1	; 0x01
    3f38:	fa 81       	ldd	r31, Y+2	; 0x02
    3f3a:	01 80       	ldd	r0, Z+1	; 0x01
    3f3c:	f2 81       	ldd	r31, Z+2	; 0x02
    3f3e:	e0 2d       	mov	r30, r0
    3f40:	86 81       	ldd	r24, Z+6	; 0x06
    3f42:	97 81       	ldd	r25, Z+7	; 0x07
    3f44:	90 93 a3 04 	sts	0x04A3, r25
    3f48:	80 93 a2 04 	sts	0x04A2, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3f4c:	0f 90       	pop	r0
    3f4e:	0f 90       	pop	r0
    3f50:	cf 91       	pop	r28
    3f52:	df 91       	pop	r29
    3f54:	08 95       	ret

00003f56 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    3f56:	df 93       	push	r29
    3f58:	cf 93       	push	r28
    3f5a:	00 d0       	rcall	.+0      	; 0x3f5c <vTaskPlaceOnEventList+0x6>
    3f5c:	00 d0       	rcall	.+0      	; 0x3f5e <vTaskPlaceOnEventList+0x8>
    3f5e:	00 d0       	rcall	.+0      	; 0x3f60 <vTaskPlaceOnEventList+0xa>
    3f60:	cd b7       	in	r28, 0x3d	; 61
    3f62:	de b7       	in	r29, 0x3e	; 62
    3f64:	9c 83       	std	Y+4, r25	; 0x04
    3f66:	8b 83       	std	Y+3, r24	; 0x03
    3f68:	7e 83       	std	Y+6, r23	; 0x06
    3f6a:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3f6c:	4b 81       	ldd	r20, Y+3	; 0x03
    3f6e:	5c 81       	ldd	r21, Y+4	; 0x04
    3f70:	80 91 a2 04 	lds	r24, 0x04A2
    3f74:	90 91 a3 04 	lds	r25, 0x04A3
    3f78:	9c 01       	movw	r18, r24
    3f7a:	24 5f       	subi	r18, 0xF4	; 244
    3f7c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f7e:	ca 01       	movw	r24, r20
    3f80:	b9 01       	movw	r22, r18
    3f82:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3f86:	80 91 a2 04 	lds	r24, 0x04A2
    3f8a:	90 91 a3 04 	lds	r25, 0x04A3
    3f8e:	02 96       	adiw	r24, 0x02	; 2
    3f90:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3f94:	20 91 a6 04 	lds	r18, 0x04A6
    3f98:	30 91 a7 04 	lds	r19, 0x04A7
    3f9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3f9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3fa0:	82 0f       	add	r24, r18
    3fa2:	93 1f       	adc	r25, r19
    3fa4:	9a 83       	std	Y+2, r25	; 0x02
    3fa6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3fa8:	89 81       	ldd	r24, Y+1	; 0x01
    3faa:	9a 81       	ldd	r25, Y+2	; 0x02
    3fac:	0e 94 a5 21 	call	0x434a	; 0x434a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3fb0:	26 96       	adiw	r28, 0x06	; 6
    3fb2:	0f b6       	in	r0, 0x3f	; 63
    3fb4:	f8 94       	cli
    3fb6:	de bf       	out	0x3e, r29	; 62
    3fb8:	0f be       	out	0x3f, r0	; 63
    3fba:	cd bf       	out	0x3d, r28	; 61
    3fbc:	cf 91       	pop	r28
    3fbe:	df 91       	pop	r29
    3fc0:	08 95       	ret

00003fc2 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    3fc2:	df 93       	push	r29
    3fc4:	cf 93       	push	r28
    3fc6:	00 d0       	rcall	.+0      	; 0x3fc8 <xTaskRemoveFromEventList+0x6>
    3fc8:	00 d0       	rcall	.+0      	; 0x3fca <xTaskRemoveFromEventList+0x8>
    3fca:	0f 92       	push	r0
    3fcc:	cd b7       	in	r28, 0x3d	; 61
    3fce:	de b7       	in	r29, 0x3e	; 62
    3fd0:	9d 83       	std	Y+5, r25	; 0x05
    3fd2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3fd4:	ec 81       	ldd	r30, Y+4	; 0x04
    3fd6:	fd 81       	ldd	r31, Y+5	; 0x05
    3fd8:	05 80       	ldd	r0, Z+5	; 0x05
    3fda:	f6 81       	ldd	r31, Z+6	; 0x06
    3fdc:	e0 2d       	mov	r30, r0
    3fde:	86 81       	ldd	r24, Z+6	; 0x06
    3fe0:	97 81       	ldd	r25, Z+7	; 0x07
    3fe2:	9b 83       	std	Y+3, r25	; 0x03
    3fe4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3fe6:	8a 81       	ldd	r24, Y+2	; 0x02
    3fe8:	9b 81       	ldd	r25, Y+3	; 0x03
    3fea:	0c 96       	adiw	r24, 0x0c	; 12
    3fec:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3ff0:	80 91 ab 04 	lds	r24, 0x04AB
    3ff4:	88 23       	and	r24, r24
    3ff6:	61 f5       	brne	.+88     	; 0x4050 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3ff8:	8a 81       	ldd	r24, Y+2	; 0x02
    3ffa:	9b 81       	ldd	r25, Y+3	; 0x03
    3ffc:	02 96       	adiw	r24, 0x02	; 2
    3ffe:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4002:	ea 81       	ldd	r30, Y+2	; 0x02
    4004:	fb 81       	ldd	r31, Y+3	; 0x03
    4006:	96 89       	ldd	r25, Z+22	; 0x16
    4008:	80 91 a9 04 	lds	r24, 0x04A9
    400c:	89 17       	cp	r24, r25
    400e:	28 f4       	brcc	.+10     	; 0x401a <xTaskRemoveFromEventList+0x58>
    4010:	ea 81       	ldd	r30, Y+2	; 0x02
    4012:	fb 81       	ldd	r31, Y+3	; 0x03
    4014:	86 89       	ldd	r24, Z+22	; 0x16
    4016:	80 93 a9 04 	sts	0x04A9, r24
    401a:	ea 81       	ldd	r30, Y+2	; 0x02
    401c:	fb 81       	ldd	r31, Y+3	; 0x03
    401e:	86 89       	ldd	r24, Z+22	; 0x16
    4020:	28 2f       	mov	r18, r24
    4022:	30 e0       	ldi	r19, 0x00	; 0
    4024:	c9 01       	movw	r24, r18
    4026:	88 0f       	add	r24, r24
    4028:	99 1f       	adc	r25, r25
    402a:	88 0f       	add	r24, r24
    402c:	99 1f       	adc	r25, r25
    402e:	88 0f       	add	r24, r24
    4030:	99 1f       	adc	r25, r25
    4032:	82 0f       	add	r24, r18
    4034:	93 1f       	adc	r25, r19
    4036:	ac 01       	movw	r20, r24
    4038:	40 55       	subi	r20, 0x50	; 80
    403a:	5b 4f       	sbci	r21, 0xFB	; 251
    403c:	8a 81       	ldd	r24, Y+2	; 0x02
    403e:	9b 81       	ldd	r25, Y+3	; 0x03
    4040:	9c 01       	movw	r18, r24
    4042:	2e 5f       	subi	r18, 0xFE	; 254
    4044:	3f 4f       	sbci	r19, 0xFF	; 255
    4046:	ca 01       	movw	r24, r20
    4048:	b9 01       	movw	r22, r18
    404a:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>
    404e:	0a c0       	rjmp	.+20     	; 0x4064 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4050:	8a 81       	ldd	r24, Y+2	; 0x02
    4052:	9b 81       	ldd	r25, Y+3	; 0x03
    4054:	9c 01       	movw	r18, r24
    4056:	24 5f       	subi	r18, 0xF4	; 244
    4058:	3f 4f       	sbci	r19, 0xFF	; 255
    405a:	8c ef       	ldi	r24, 0xFC	; 252
    405c:	94 e0       	ldi	r25, 0x04	; 4
    405e:	b9 01       	movw	r22, r18
    4060:	0e 94 2d 12 	call	0x245a	; 0x245a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4064:	ea 81       	ldd	r30, Y+2	; 0x02
    4066:	fb 81       	ldd	r31, Y+3	; 0x03
    4068:	96 89       	ldd	r25, Z+22	; 0x16
    406a:	e0 91 a2 04 	lds	r30, 0x04A2
    406e:	f0 91 a3 04 	lds	r31, 0x04A3
    4072:	86 89       	ldd	r24, Z+22	; 0x16
    4074:	98 17       	cp	r25, r24
    4076:	18 f0       	brcs	.+6      	; 0x407e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4078:	81 e0       	ldi	r24, 0x01	; 1
    407a:	89 83       	std	Y+1, r24	; 0x01
    407c:	01 c0       	rjmp	.+2      	; 0x4080 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    407e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4080:	89 81       	ldd	r24, Y+1	; 0x01
}
    4082:	0f 90       	pop	r0
    4084:	0f 90       	pop	r0
    4086:	0f 90       	pop	r0
    4088:	0f 90       	pop	r0
    408a:	0f 90       	pop	r0
    408c:	cf 91       	pop	r28
    408e:	df 91       	pop	r29
    4090:	08 95       	ret

00004092 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4092:	df 93       	push	r29
    4094:	cf 93       	push	r28
    4096:	00 d0       	rcall	.+0      	; 0x4098 <vTaskSetTimeOutState+0x6>
    4098:	cd b7       	in	r28, 0x3d	; 61
    409a:	de b7       	in	r29, 0x3e	; 62
    409c:	9a 83       	std	Y+2, r25	; 0x02
    409e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    40a0:	80 91 ae 04 	lds	r24, 0x04AE
    40a4:	e9 81       	ldd	r30, Y+1	; 0x01
    40a6:	fa 81       	ldd	r31, Y+2	; 0x02
    40a8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    40aa:	80 91 a6 04 	lds	r24, 0x04A6
    40ae:	90 91 a7 04 	lds	r25, 0x04A7
    40b2:	e9 81       	ldd	r30, Y+1	; 0x01
    40b4:	fa 81       	ldd	r31, Y+2	; 0x02
    40b6:	92 83       	std	Z+2, r25	; 0x02
    40b8:	81 83       	std	Z+1, r24	; 0x01
}
    40ba:	0f 90       	pop	r0
    40bc:	0f 90       	pop	r0
    40be:	cf 91       	pop	r28
    40c0:	df 91       	pop	r29
    40c2:	08 95       	ret

000040c4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    40c4:	df 93       	push	r29
    40c6:	cf 93       	push	r28
    40c8:	00 d0       	rcall	.+0      	; 0x40ca <xTaskCheckForTimeOut+0x6>
    40ca:	00 d0       	rcall	.+0      	; 0x40cc <xTaskCheckForTimeOut+0x8>
    40cc:	0f 92       	push	r0
    40ce:	cd b7       	in	r28, 0x3d	; 61
    40d0:	de b7       	in	r29, 0x3e	; 62
    40d2:	9b 83       	std	Y+3, r25	; 0x03
    40d4:	8a 83       	std	Y+2, r24	; 0x02
    40d6:	7d 83       	std	Y+5, r23	; 0x05
    40d8:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    40da:	0f b6       	in	r0, 0x3f	; 63
    40dc:	f8 94       	cli
    40de:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    40e0:	ea 81       	ldd	r30, Y+2	; 0x02
    40e2:	fb 81       	ldd	r31, Y+3	; 0x03
    40e4:	90 81       	ld	r25, Z
    40e6:	80 91 ae 04 	lds	r24, 0x04AE
    40ea:	98 17       	cp	r25, r24
    40ec:	71 f0       	breq	.+28     	; 0x410a <xTaskCheckForTimeOut+0x46>
    40ee:	ea 81       	ldd	r30, Y+2	; 0x02
    40f0:	fb 81       	ldd	r31, Y+3	; 0x03
    40f2:	21 81       	ldd	r18, Z+1	; 0x01
    40f4:	32 81       	ldd	r19, Z+2	; 0x02
    40f6:	80 91 a6 04 	lds	r24, 0x04A6
    40fa:	90 91 a7 04 	lds	r25, 0x04A7
    40fe:	82 17       	cp	r24, r18
    4100:	93 07       	cpc	r25, r19
    4102:	18 f0       	brcs	.+6      	; 0x410a <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4104:	81 e0       	ldi	r24, 0x01	; 1
    4106:	89 83       	std	Y+1, r24	; 0x01
    4108:	2f c0       	rjmp	.+94     	; 0x4168 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    410a:	20 91 a6 04 	lds	r18, 0x04A6
    410e:	30 91 a7 04 	lds	r19, 0x04A7
    4112:	ea 81       	ldd	r30, Y+2	; 0x02
    4114:	fb 81       	ldd	r31, Y+3	; 0x03
    4116:	81 81       	ldd	r24, Z+1	; 0x01
    4118:	92 81       	ldd	r25, Z+2	; 0x02
    411a:	28 1b       	sub	r18, r24
    411c:	39 0b       	sbc	r19, r25
    411e:	ec 81       	ldd	r30, Y+4	; 0x04
    4120:	fd 81       	ldd	r31, Y+5	; 0x05
    4122:	80 81       	ld	r24, Z
    4124:	91 81       	ldd	r25, Z+1	; 0x01
    4126:	28 17       	cp	r18, r24
    4128:	39 07       	cpc	r19, r25
    412a:	e0 f4       	brcc	.+56     	; 0x4164 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    412c:	ec 81       	ldd	r30, Y+4	; 0x04
    412e:	fd 81       	ldd	r31, Y+5	; 0x05
    4130:	40 81       	ld	r20, Z
    4132:	51 81       	ldd	r21, Z+1	; 0x01
    4134:	ea 81       	ldd	r30, Y+2	; 0x02
    4136:	fb 81       	ldd	r31, Y+3	; 0x03
    4138:	21 81       	ldd	r18, Z+1	; 0x01
    413a:	32 81       	ldd	r19, Z+2	; 0x02
    413c:	80 91 a6 04 	lds	r24, 0x04A6
    4140:	90 91 a7 04 	lds	r25, 0x04A7
    4144:	b9 01       	movw	r22, r18
    4146:	68 1b       	sub	r22, r24
    4148:	79 0b       	sbc	r23, r25
    414a:	cb 01       	movw	r24, r22
    414c:	84 0f       	add	r24, r20
    414e:	95 1f       	adc	r25, r21
    4150:	ec 81       	ldd	r30, Y+4	; 0x04
    4152:	fd 81       	ldd	r31, Y+5	; 0x05
    4154:	91 83       	std	Z+1, r25	; 0x01
    4156:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    4158:	8a 81       	ldd	r24, Y+2	; 0x02
    415a:	9b 81       	ldd	r25, Y+3	; 0x03
    415c:	0e 94 49 20 	call	0x4092	; 0x4092 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4160:	19 82       	std	Y+1, r1	; 0x01
    4162:	02 c0       	rjmp	.+4      	; 0x4168 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    4164:	81 e0       	ldi	r24, 0x01	; 1
    4166:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4168:	0f 90       	pop	r0
    416a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    416c:	89 81       	ldd	r24, Y+1	; 0x01
}
    416e:	0f 90       	pop	r0
    4170:	0f 90       	pop	r0
    4172:	0f 90       	pop	r0
    4174:	0f 90       	pop	r0
    4176:	0f 90       	pop	r0
    4178:	cf 91       	pop	r28
    417a:	df 91       	pop	r29
    417c:	08 95       	ret

0000417e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    417e:	df 93       	push	r29
    4180:	cf 93       	push	r28
    4182:	cd b7       	in	r28, 0x3d	; 61
    4184:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4186:	81 e0       	ldi	r24, 0x01	; 1
    4188:	80 93 ad 04 	sts	0x04AD, r24
}
    418c:	cf 91       	pop	r28
    418e:	df 91       	pop	r29
    4190:	08 95       	ret

00004192 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4192:	df 93       	push	r29
    4194:	cf 93       	push	r28
    4196:	00 d0       	rcall	.+0      	; 0x4198 <prvIdleTask+0x6>
    4198:	cd b7       	in	r28, 0x3d	; 61
    419a:	de b7       	in	r29, 0x3e	; 62
    419c:	9a 83       	std	Y+2, r25	; 0x02
    419e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    41a0:	0e 94 67 21 	call	0x42ce	; 0x42ce <prvCheckTasksWaitingTermination>
    41a4:	fd cf       	rjmp	.-6      	; 0x41a0 <prvIdleTask+0xe>

000041a6 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    41a6:	0f 93       	push	r16
    41a8:	1f 93       	push	r17
    41aa:	df 93       	push	r29
    41ac:	cf 93       	push	r28
    41ae:	cd b7       	in	r28, 0x3d	; 61
    41b0:	de b7       	in	r29, 0x3e	; 62
    41b2:	29 97       	sbiw	r28, 0x09	; 9
    41b4:	0f b6       	in	r0, 0x3f	; 63
    41b6:	f8 94       	cli
    41b8:	de bf       	out	0x3e, r29	; 62
    41ba:	0f be       	out	0x3f, r0	; 63
    41bc:	cd bf       	out	0x3d, r28	; 61
    41be:	9a 83       	std	Y+2, r25	; 0x02
    41c0:	89 83       	std	Y+1, r24	; 0x01
    41c2:	7c 83       	std	Y+4, r23	; 0x04
    41c4:	6b 83       	std	Y+3, r22	; 0x03
    41c6:	4d 83       	std	Y+5, r20	; 0x05
    41c8:	3f 83       	std	Y+7, r19	; 0x07
    41ca:	2e 83       	std	Y+6, r18	; 0x06
    41cc:	19 87       	std	Y+9, r17	; 0x09
    41ce:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    41d0:	89 81       	ldd	r24, Y+1	; 0x01
    41d2:	9a 81       	ldd	r25, Y+2	; 0x02
    41d4:	49 96       	adiw	r24, 0x19	; 25
    41d6:	2b 81       	ldd	r18, Y+3	; 0x03
    41d8:	3c 81       	ldd	r19, Y+4	; 0x04
    41da:	b9 01       	movw	r22, r18
    41dc:	48 e0       	ldi	r20, 0x08	; 8
    41de:	50 e0       	ldi	r21, 0x00	; 0
    41e0:	0e 94 0b 23 	call	0x4616	; 0x4616 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    41e4:	e9 81       	ldd	r30, Y+1	; 0x01
    41e6:	fa 81       	ldd	r31, Y+2	; 0x02
    41e8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    41ea:	8d 81       	ldd	r24, Y+5	; 0x05
    41ec:	86 30       	cpi	r24, 0x06	; 6
    41ee:	10 f0       	brcs	.+4      	; 0x41f4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    41f0:	85 e0       	ldi	r24, 0x05	; 5
    41f2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    41f4:	e9 81       	ldd	r30, Y+1	; 0x01
    41f6:	fa 81       	ldd	r31, Y+2	; 0x02
    41f8:	8d 81       	ldd	r24, Y+5	; 0x05
    41fa:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    41fc:	89 81       	ldd	r24, Y+1	; 0x01
    41fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4200:	02 96       	adiw	r24, 0x02	; 2
    4202:	0e 94 1d 12 	call	0x243a	; 0x243a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4206:	89 81       	ldd	r24, Y+1	; 0x01
    4208:	9a 81       	ldd	r25, Y+2	; 0x02
    420a:	0c 96       	adiw	r24, 0x0c	; 12
    420c:	0e 94 1d 12 	call	0x243a	; 0x243a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4210:	e9 81       	ldd	r30, Y+1	; 0x01
    4212:	fa 81       	ldd	r31, Y+2	; 0x02
    4214:	89 81       	ldd	r24, Y+1	; 0x01
    4216:	9a 81       	ldd	r25, Y+2	; 0x02
    4218:	91 87       	std	Z+9, r25	; 0x09
    421a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    421c:	8d 81       	ldd	r24, Y+5	; 0x05
    421e:	28 2f       	mov	r18, r24
    4220:	30 e0       	ldi	r19, 0x00	; 0
    4222:	86 e0       	ldi	r24, 0x06	; 6
    4224:	90 e0       	ldi	r25, 0x00	; 0
    4226:	82 1b       	sub	r24, r18
    4228:	93 0b       	sbc	r25, r19
    422a:	e9 81       	ldd	r30, Y+1	; 0x01
    422c:	fa 81       	ldd	r31, Y+2	; 0x02
    422e:	95 87       	std	Z+13, r25	; 0x0d
    4230:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4232:	e9 81       	ldd	r30, Y+1	; 0x01
    4234:	fa 81       	ldd	r31, Y+2	; 0x02
    4236:	89 81       	ldd	r24, Y+1	; 0x01
    4238:	9a 81       	ldd	r25, Y+2	; 0x02
    423a:	93 8b       	std	Z+19, r25	; 0x13
    423c:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    423e:	29 96       	adiw	r28, 0x09	; 9
    4240:	0f b6       	in	r0, 0x3f	; 63
    4242:	f8 94       	cli
    4244:	de bf       	out	0x3e, r29	; 62
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	cd bf       	out	0x3d, r28	; 61
    424a:	cf 91       	pop	r28
    424c:	df 91       	pop	r29
    424e:	1f 91       	pop	r17
    4250:	0f 91       	pop	r16
    4252:	08 95       	ret

00004254 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    4254:	df 93       	push	r29
    4256:	cf 93       	push	r28
    4258:	0f 92       	push	r0
    425a:	cd b7       	in	r28, 0x3d	; 61
    425c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    425e:	19 82       	std	Y+1, r1	; 0x01
    4260:	13 c0       	rjmp	.+38     	; 0x4288 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4262:	89 81       	ldd	r24, Y+1	; 0x01
    4264:	28 2f       	mov	r18, r24
    4266:	30 e0       	ldi	r19, 0x00	; 0
    4268:	c9 01       	movw	r24, r18
    426a:	88 0f       	add	r24, r24
    426c:	99 1f       	adc	r25, r25
    426e:	88 0f       	add	r24, r24
    4270:	99 1f       	adc	r25, r25
    4272:	88 0f       	add	r24, r24
    4274:	99 1f       	adc	r25, r25
    4276:	82 0f       	add	r24, r18
    4278:	93 1f       	adc	r25, r19
    427a:	80 55       	subi	r24, 0x50	; 80
    427c:	9b 4f       	sbci	r25, 0xFB	; 251
    427e:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4282:	89 81       	ldd	r24, Y+1	; 0x01
    4284:	8f 5f       	subi	r24, 0xFF	; 255
    4286:	89 83       	std	Y+1, r24	; 0x01
    4288:	89 81       	ldd	r24, Y+1	; 0x01
    428a:	86 30       	cpi	r24, 0x06	; 6
    428c:	50 f3       	brcs	.-44     	; 0x4262 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    428e:	86 ee       	ldi	r24, 0xE6	; 230
    4290:	94 e0       	ldi	r25, 0x04	; 4
    4292:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4296:	8f ee       	ldi	r24, 0xEF	; 239
    4298:	94 e0       	ldi	r25, 0x04	; 4
    429a:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    429e:	8c ef       	ldi	r24, 0xFC	; 252
    42a0:	94 e0       	ldi	r25, 0x04	; 4
    42a2:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    42a6:	85 e0       	ldi	r24, 0x05	; 5
    42a8:	95 e0       	ldi	r25, 0x05	; 5
    42aa:	0e 94 f3 11 	call	0x23e6	; 0x23e6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    42ae:	86 ee       	ldi	r24, 0xE6	; 230
    42b0:	94 e0       	ldi	r25, 0x04	; 4
    42b2:	90 93 f9 04 	sts	0x04F9, r25
    42b6:	80 93 f8 04 	sts	0x04F8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    42ba:	8f ee       	ldi	r24, 0xEF	; 239
    42bc:	94 e0       	ldi	r25, 0x04	; 4
    42be:	90 93 fb 04 	sts	0x04FB, r25
    42c2:	80 93 fa 04 	sts	0x04FA, r24
}
    42c6:	0f 90       	pop	r0
    42c8:	cf 91       	pop	r28
    42ca:	df 91       	pop	r29
    42cc:	08 95       	ret

000042ce <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    42ce:	df 93       	push	r29
    42d0:	cf 93       	push	r28
    42d2:	00 d0       	rcall	.+0      	; 0x42d4 <prvCheckTasksWaitingTermination+0x6>
    42d4:	0f 92       	push	r0
    42d6:	cd b7       	in	r28, 0x3d	; 61
    42d8:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    42da:	80 91 a4 04 	lds	r24, 0x04A4
    42de:	88 23       	and	r24, r24
    42e0:	71 f1       	breq	.+92     	; 0x433e <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    42e2:	0e 94 a5 1d 	call	0x3b4a	; 0x3b4a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    42e6:	80 91 05 05 	lds	r24, 0x0505
    42ea:	1b 82       	std	Y+3, r1	; 0x03
    42ec:	88 23       	and	r24, r24
    42ee:	11 f4       	brne	.+4      	; 0x42f4 <prvCheckTasksWaitingTermination+0x26>
    42f0:	81 e0       	ldi	r24, 0x01	; 1
    42f2:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    42f4:	0e 94 b1 1d 	call	0x3b62	; 0x3b62 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    42f8:	8b 81       	ldd	r24, Y+3	; 0x03
    42fa:	88 23       	and	r24, r24
    42fc:	01 f5       	brne	.+64     	; 0x433e <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    42fe:	0f b6       	in	r0, 0x3f	; 63
    4300:	f8 94       	cli
    4302:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4304:	e0 91 0a 05 	lds	r30, 0x050A
    4308:	f0 91 0b 05 	lds	r31, 0x050B
    430c:	86 81       	ldd	r24, Z+6	; 0x06
    430e:	97 81       	ldd	r25, Z+7	; 0x07
    4310:	9a 83       	std	Y+2, r25	; 0x02
    4312:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    4314:	89 81       	ldd	r24, Y+1	; 0x01
    4316:	9a 81       	ldd	r25, Y+2	; 0x02
    4318:	02 96       	adiw	r24, 0x02	; 2
    431a:	0e 94 e5 12 	call	0x25ca	; 0x25ca <vListRemove>
					--uxCurrentNumberOfTasks;
    431e:	80 91 a5 04 	lds	r24, 0x04A5
    4322:	81 50       	subi	r24, 0x01	; 1
    4324:	80 93 a5 04 	sts	0x04A5, r24
					--uxTasksDeleted;
    4328:	80 91 a4 04 	lds	r24, 0x04A4
    432c:	81 50       	subi	r24, 0x01	; 1
    432e:	80 93 a4 04 	sts	0x04A4, r24
				}
				taskEXIT_CRITICAL();
    4332:	0f 90       	pop	r0
    4334:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    4336:	89 81       	ldd	r24, Y+1	; 0x01
    4338:	9a 81       	ldd	r25, Y+2	; 0x02
    433a:	0e 94 3e 22 	call	0x447c	; 0x447c <prvDeleteTCB>
			}
		}
	}
	#endif
}
    433e:	0f 90       	pop	r0
    4340:	0f 90       	pop	r0
    4342:	0f 90       	pop	r0
    4344:	cf 91       	pop	r28
    4346:	df 91       	pop	r29
    4348:	08 95       	ret

0000434a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    434a:	df 93       	push	r29
    434c:	cf 93       	push	r28
    434e:	00 d0       	rcall	.+0      	; 0x4350 <prvAddCurrentTaskToDelayedList+0x6>
    4350:	cd b7       	in	r28, 0x3d	; 61
    4352:	de b7       	in	r29, 0x3e	; 62
    4354:	9a 83       	std	Y+2, r25	; 0x02
    4356:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    4358:	e0 91 a2 04 	lds	r30, 0x04A2
    435c:	f0 91 a3 04 	lds	r31, 0x04A3
    4360:	89 81       	ldd	r24, Y+1	; 0x01
    4362:	9a 81       	ldd	r25, Y+2	; 0x02
    4364:	93 83       	std	Z+3, r25	; 0x03
    4366:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    4368:	20 91 a6 04 	lds	r18, 0x04A6
    436c:	30 91 a7 04 	lds	r19, 0x04A7
    4370:	89 81       	ldd	r24, Y+1	; 0x01
    4372:	9a 81       	ldd	r25, Y+2	; 0x02
    4374:	82 17       	cp	r24, r18
    4376:	93 07       	cpc	r25, r19
    4378:	70 f4       	brcc	.+28     	; 0x4396 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    437a:	80 91 fa 04 	lds	r24, 0x04FA
    437e:	90 91 fb 04 	lds	r25, 0x04FB
    4382:	20 91 a2 04 	lds	r18, 0x04A2
    4386:	30 91 a3 04 	lds	r19, 0x04A3
    438a:	2e 5f       	subi	r18, 0xFE	; 254
    438c:	3f 4f       	sbci	r19, 0xFF	; 255
    438e:	b9 01       	movw	r22, r18
    4390:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>
    4394:	1e c0       	rjmp	.+60     	; 0x43d2 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4396:	40 91 f8 04 	lds	r20, 0x04F8
    439a:	50 91 f9 04 	lds	r21, 0x04F9
    439e:	80 91 a2 04 	lds	r24, 0x04A2
    43a2:	90 91 a3 04 	lds	r25, 0x04A3
    43a6:	9c 01       	movw	r18, r24
    43a8:	2e 5f       	subi	r18, 0xFE	; 254
    43aa:	3f 4f       	sbci	r19, 0xFF	; 255
    43ac:	ca 01       	movw	r24, r20
    43ae:	b9 01       	movw	r22, r18
    43b0:	0e 94 79 12 	call	0x24f2	; 0x24f2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    43b4:	20 91 77 00 	lds	r18, 0x0077
    43b8:	30 91 78 00 	lds	r19, 0x0078
    43bc:	89 81       	ldd	r24, Y+1	; 0x01
    43be:	9a 81       	ldd	r25, Y+2	; 0x02
    43c0:	82 17       	cp	r24, r18
    43c2:	93 07       	cpc	r25, r19
    43c4:	30 f4       	brcc	.+12     	; 0x43d2 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    43c6:	89 81       	ldd	r24, Y+1	; 0x01
    43c8:	9a 81       	ldd	r25, Y+2	; 0x02
    43ca:	90 93 78 00 	sts	0x0078, r25
    43ce:	80 93 77 00 	sts	0x0077, r24
		}
	}
}
    43d2:	0f 90       	pop	r0
    43d4:	0f 90       	pop	r0
    43d6:	cf 91       	pop	r28
    43d8:	df 91       	pop	r29
    43da:	08 95       	ret

000043dc <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    43dc:	df 93       	push	r29
    43de:	cf 93       	push	r28
    43e0:	cd b7       	in	r28, 0x3d	; 61
    43e2:	de b7       	in	r29, 0x3e	; 62
    43e4:	28 97       	sbiw	r28, 0x08	; 8
    43e6:	0f b6       	in	r0, 0x3f	; 63
    43e8:	f8 94       	cli
    43ea:	de bf       	out	0x3e, r29	; 62
    43ec:	0f be       	out	0x3f, r0	; 63
    43ee:	cd bf       	out	0x3d, r28	; 61
    43f0:	9c 83       	std	Y+4, r25	; 0x04
    43f2:	8b 83       	std	Y+3, r24	; 0x03
    43f4:	7e 83       	std	Y+6, r23	; 0x06
    43f6:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    43f8:	81 e2       	ldi	r24, 0x21	; 33
    43fa:	90 e0       	ldi	r25, 0x00	; 0
    43fc:	0e 94 87 11 	call	0x230e	; 0x230e <pvPortMalloc>
    4400:	9a 83       	std	Y+2, r25	; 0x02
    4402:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    4404:	89 81       	ldd	r24, Y+1	; 0x01
    4406:	9a 81       	ldd	r25, Y+2	; 0x02
    4408:	00 97       	sbiw	r24, 0x00	; 0
    440a:	69 f1       	breq	.+90     	; 0x4466 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    440c:	8d 81       	ldd	r24, Y+5	; 0x05
    440e:	9e 81       	ldd	r25, Y+6	; 0x06
    4410:	00 97       	sbiw	r24, 0x00	; 0
    4412:	39 f4       	brne	.+14     	; 0x4422 <prvAllocateTCBAndStack+0x46>
    4414:	8b 81       	ldd	r24, Y+3	; 0x03
    4416:	9c 81       	ldd	r25, Y+4	; 0x04
    4418:	0e 94 87 11 	call	0x230e	; 0x230e <pvPortMalloc>
    441c:	98 87       	std	Y+8, r25	; 0x08
    441e:	8f 83       	std	Y+7, r24	; 0x07
    4420:	04 c0       	rjmp	.+8      	; 0x442a <prvAllocateTCBAndStack+0x4e>
    4422:	8d 81       	ldd	r24, Y+5	; 0x05
    4424:	9e 81       	ldd	r25, Y+6	; 0x06
    4426:	98 87       	std	Y+8, r25	; 0x08
    4428:	8f 83       	std	Y+7, r24	; 0x07
    442a:	e9 81       	ldd	r30, Y+1	; 0x01
    442c:	fa 81       	ldd	r31, Y+2	; 0x02
    442e:	8f 81       	ldd	r24, Y+7	; 0x07
    4430:	98 85       	ldd	r25, Y+8	; 0x08
    4432:	90 8f       	std	Z+24, r25	; 0x18
    4434:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    4436:	e9 81       	ldd	r30, Y+1	; 0x01
    4438:	fa 81       	ldd	r31, Y+2	; 0x02
    443a:	87 89       	ldd	r24, Z+23	; 0x17
    443c:	90 8d       	ldd	r25, Z+24	; 0x18
    443e:	00 97       	sbiw	r24, 0x00	; 0
    4440:	39 f4       	brne	.+14     	; 0x4450 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    4442:	89 81       	ldd	r24, Y+1	; 0x01
    4444:	9a 81       	ldd	r25, Y+2	; 0x02
    4446:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
			pxNewTCB = NULL;
    444a:	1a 82       	std	Y+2, r1	; 0x02
    444c:	19 82       	std	Y+1, r1	; 0x01
    444e:	0b c0       	rjmp	.+22     	; 0x4466 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    4450:	e9 81       	ldd	r30, Y+1	; 0x01
    4452:	fa 81       	ldd	r31, Y+2	; 0x02
    4454:	87 89       	ldd	r24, Z+23	; 0x17
    4456:	90 8d       	ldd	r25, Z+24	; 0x18
    4458:	2b 81       	ldd	r18, Y+3	; 0x03
    445a:	3c 81       	ldd	r19, Y+4	; 0x04
    445c:	65 ea       	ldi	r22, 0xA5	; 165
    445e:	70 e0       	ldi	r23, 0x00	; 0
    4460:	a9 01       	movw	r20, r18
    4462:	0e 94 04 23 	call	0x4608	; 0x4608 <memset>
		}
	}

	return pxNewTCB;
    4466:	89 81       	ldd	r24, Y+1	; 0x01
    4468:	9a 81       	ldd	r25, Y+2	; 0x02
}
    446a:	28 96       	adiw	r28, 0x08	; 8
    446c:	0f b6       	in	r0, 0x3f	; 63
    446e:	f8 94       	cli
    4470:	de bf       	out	0x3e, r29	; 62
    4472:	0f be       	out	0x3f, r0	; 63
    4474:	cd bf       	out	0x3d, r28	; 61
    4476:	cf 91       	pop	r28
    4478:	df 91       	pop	r29
    447a:	08 95       	ret

0000447c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    447c:	df 93       	push	r29
    447e:	cf 93       	push	r28
    4480:	00 d0       	rcall	.+0      	; 0x4482 <prvDeleteTCB+0x6>
    4482:	cd b7       	in	r28, 0x3d	; 61
    4484:	de b7       	in	r29, 0x3e	; 62
    4486:	9a 83       	std	Y+2, r25	; 0x02
    4488:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    448a:	e9 81       	ldd	r30, Y+1	; 0x01
    448c:	fa 81       	ldd	r31, Y+2	; 0x02
    448e:	87 89       	ldd	r24, Z+23	; 0x17
    4490:	90 8d       	ldd	r25, Z+24	; 0x18
    4492:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
		vPortFree( pxTCB );
    4496:	89 81       	ldd	r24, Y+1	; 0x01
    4498:	9a 81       	ldd	r25, Y+2	; 0x02
    449a:	0e 94 cd 11 	call	0x239a	; 0x239a <vPortFree>
	}
    449e:	0f 90       	pop	r0
    44a0:	0f 90       	pop	r0
    44a2:	cf 91       	pop	r28
    44a4:	df 91       	pop	r29
    44a6:	08 95       	ret

000044a8 <__mulsi3>:
    44a8:	62 9f       	mul	r22, r18
    44aa:	d0 01       	movw	r26, r0
    44ac:	73 9f       	mul	r23, r19
    44ae:	f0 01       	movw	r30, r0
    44b0:	82 9f       	mul	r24, r18
    44b2:	e0 0d       	add	r30, r0
    44b4:	f1 1d       	adc	r31, r1
    44b6:	64 9f       	mul	r22, r20
    44b8:	e0 0d       	add	r30, r0
    44ba:	f1 1d       	adc	r31, r1
    44bc:	92 9f       	mul	r25, r18
    44be:	f0 0d       	add	r31, r0
    44c0:	83 9f       	mul	r24, r19
    44c2:	f0 0d       	add	r31, r0
    44c4:	74 9f       	mul	r23, r20
    44c6:	f0 0d       	add	r31, r0
    44c8:	65 9f       	mul	r22, r21
    44ca:	f0 0d       	add	r31, r0
    44cc:	99 27       	eor	r25, r25
    44ce:	72 9f       	mul	r23, r18
    44d0:	b0 0d       	add	r27, r0
    44d2:	e1 1d       	adc	r30, r1
    44d4:	f9 1f       	adc	r31, r25
    44d6:	63 9f       	mul	r22, r19
    44d8:	b0 0d       	add	r27, r0
    44da:	e1 1d       	adc	r30, r1
    44dc:	f9 1f       	adc	r31, r25
    44de:	bd 01       	movw	r22, r26
    44e0:	cf 01       	movw	r24, r30
    44e2:	11 24       	eor	r1, r1
    44e4:	08 95       	ret

000044e6 <__udivmodhi4>:
    44e6:	aa 1b       	sub	r26, r26
    44e8:	bb 1b       	sub	r27, r27
    44ea:	51 e1       	ldi	r21, 0x11	; 17
    44ec:	07 c0       	rjmp	.+14     	; 0x44fc <__udivmodhi4_ep>

000044ee <__udivmodhi4_loop>:
    44ee:	aa 1f       	adc	r26, r26
    44f0:	bb 1f       	adc	r27, r27
    44f2:	a6 17       	cp	r26, r22
    44f4:	b7 07       	cpc	r27, r23
    44f6:	10 f0       	brcs	.+4      	; 0x44fc <__udivmodhi4_ep>
    44f8:	a6 1b       	sub	r26, r22
    44fa:	b7 0b       	sbc	r27, r23

000044fc <__udivmodhi4_ep>:
    44fc:	88 1f       	adc	r24, r24
    44fe:	99 1f       	adc	r25, r25
    4500:	5a 95       	dec	r21
    4502:	a9 f7       	brne	.-22     	; 0x44ee <__udivmodhi4_loop>
    4504:	80 95       	com	r24
    4506:	90 95       	com	r25
    4508:	bc 01       	movw	r22, r24
    450a:	cd 01       	movw	r24, r26
    450c:	08 95       	ret

0000450e <__udivmodsi4>:
    450e:	a1 e2       	ldi	r26, 0x21	; 33
    4510:	1a 2e       	mov	r1, r26
    4512:	aa 1b       	sub	r26, r26
    4514:	bb 1b       	sub	r27, r27
    4516:	fd 01       	movw	r30, r26
    4518:	0d c0       	rjmp	.+26     	; 0x4534 <__udivmodsi4_ep>

0000451a <__udivmodsi4_loop>:
    451a:	aa 1f       	adc	r26, r26
    451c:	bb 1f       	adc	r27, r27
    451e:	ee 1f       	adc	r30, r30
    4520:	ff 1f       	adc	r31, r31
    4522:	a2 17       	cp	r26, r18
    4524:	b3 07       	cpc	r27, r19
    4526:	e4 07       	cpc	r30, r20
    4528:	f5 07       	cpc	r31, r21
    452a:	20 f0       	brcs	.+8      	; 0x4534 <__udivmodsi4_ep>
    452c:	a2 1b       	sub	r26, r18
    452e:	b3 0b       	sbc	r27, r19
    4530:	e4 0b       	sbc	r30, r20
    4532:	f5 0b       	sbc	r31, r21

00004534 <__udivmodsi4_ep>:
    4534:	66 1f       	adc	r22, r22
    4536:	77 1f       	adc	r23, r23
    4538:	88 1f       	adc	r24, r24
    453a:	99 1f       	adc	r25, r25
    453c:	1a 94       	dec	r1
    453e:	69 f7       	brne	.-38     	; 0x451a <__udivmodsi4_loop>
    4540:	60 95       	com	r22
    4542:	70 95       	com	r23
    4544:	80 95       	com	r24
    4546:	90 95       	com	r25
    4548:	9b 01       	movw	r18, r22
    454a:	ac 01       	movw	r20, r24
    454c:	bd 01       	movw	r22, r26
    454e:	cf 01       	movw	r24, r30
    4550:	08 95       	ret

00004552 <__divmodsi4>:
    4552:	97 fb       	bst	r25, 7
    4554:	09 2e       	mov	r0, r25
    4556:	05 26       	eor	r0, r21
    4558:	0e d0       	rcall	.+28     	; 0x4576 <__divmodsi4_neg1>
    455a:	57 fd       	sbrc	r21, 7
    455c:	04 d0       	rcall	.+8      	; 0x4566 <__divmodsi4_neg2>
    455e:	d7 df       	rcall	.-82     	; 0x450e <__udivmodsi4>
    4560:	0a d0       	rcall	.+20     	; 0x4576 <__divmodsi4_neg1>
    4562:	00 1c       	adc	r0, r0
    4564:	38 f4       	brcc	.+14     	; 0x4574 <__divmodsi4_exit>

00004566 <__divmodsi4_neg2>:
    4566:	50 95       	com	r21
    4568:	40 95       	com	r20
    456a:	30 95       	com	r19
    456c:	21 95       	neg	r18
    456e:	3f 4f       	sbci	r19, 0xFF	; 255
    4570:	4f 4f       	sbci	r20, 0xFF	; 255
    4572:	5f 4f       	sbci	r21, 0xFF	; 255

00004574 <__divmodsi4_exit>:
    4574:	08 95       	ret

00004576 <__divmodsi4_neg1>:
    4576:	f6 f7       	brtc	.-4      	; 0x4574 <__divmodsi4_exit>
    4578:	90 95       	com	r25
    457a:	80 95       	com	r24
    457c:	70 95       	com	r23
    457e:	61 95       	neg	r22
    4580:	7f 4f       	sbci	r23, 0xFF	; 255
    4582:	8f 4f       	sbci	r24, 0xFF	; 255
    4584:	9f 4f       	sbci	r25, 0xFF	; 255
    4586:	08 95       	ret

00004588 <__prologue_saves__>:
    4588:	2f 92       	push	r2
    458a:	3f 92       	push	r3
    458c:	4f 92       	push	r4
    458e:	5f 92       	push	r5
    4590:	6f 92       	push	r6
    4592:	7f 92       	push	r7
    4594:	8f 92       	push	r8
    4596:	9f 92       	push	r9
    4598:	af 92       	push	r10
    459a:	bf 92       	push	r11
    459c:	cf 92       	push	r12
    459e:	df 92       	push	r13
    45a0:	ef 92       	push	r14
    45a2:	ff 92       	push	r15
    45a4:	0f 93       	push	r16
    45a6:	1f 93       	push	r17
    45a8:	cf 93       	push	r28
    45aa:	df 93       	push	r29
    45ac:	cd b7       	in	r28, 0x3d	; 61
    45ae:	de b7       	in	r29, 0x3e	; 62
    45b0:	ca 1b       	sub	r28, r26
    45b2:	db 0b       	sbc	r29, r27
    45b4:	0f b6       	in	r0, 0x3f	; 63
    45b6:	f8 94       	cli
    45b8:	de bf       	out	0x3e, r29	; 62
    45ba:	0f be       	out	0x3f, r0	; 63
    45bc:	cd bf       	out	0x3d, r28	; 61
    45be:	09 94       	ijmp

000045c0 <__epilogue_restores__>:
    45c0:	2a 88       	ldd	r2, Y+18	; 0x12
    45c2:	39 88       	ldd	r3, Y+17	; 0x11
    45c4:	48 88       	ldd	r4, Y+16	; 0x10
    45c6:	5f 84       	ldd	r5, Y+15	; 0x0f
    45c8:	6e 84       	ldd	r6, Y+14	; 0x0e
    45ca:	7d 84       	ldd	r7, Y+13	; 0x0d
    45cc:	8c 84       	ldd	r8, Y+12	; 0x0c
    45ce:	9b 84       	ldd	r9, Y+11	; 0x0b
    45d0:	aa 84       	ldd	r10, Y+10	; 0x0a
    45d2:	b9 84       	ldd	r11, Y+9	; 0x09
    45d4:	c8 84       	ldd	r12, Y+8	; 0x08
    45d6:	df 80       	ldd	r13, Y+7	; 0x07
    45d8:	ee 80       	ldd	r14, Y+6	; 0x06
    45da:	fd 80       	ldd	r15, Y+5	; 0x05
    45dc:	0c 81       	ldd	r16, Y+4	; 0x04
    45de:	1b 81       	ldd	r17, Y+3	; 0x03
    45e0:	aa 81       	ldd	r26, Y+2	; 0x02
    45e2:	b9 81       	ldd	r27, Y+1	; 0x01
    45e4:	ce 0f       	add	r28, r30
    45e6:	d1 1d       	adc	r29, r1
    45e8:	0f b6       	in	r0, 0x3f	; 63
    45ea:	f8 94       	cli
    45ec:	de bf       	out	0x3e, r29	; 62
    45ee:	0f be       	out	0x3f, r0	; 63
    45f0:	cd bf       	out	0x3d, r28	; 61
    45f2:	ed 01       	movw	r28, r26
    45f4:	08 95       	ret

000045f6 <memcpy>:
    45f6:	fb 01       	movw	r30, r22
    45f8:	dc 01       	movw	r26, r24
    45fa:	02 c0       	rjmp	.+4      	; 0x4600 <memcpy+0xa>
    45fc:	01 90       	ld	r0, Z+
    45fe:	0d 92       	st	X+, r0
    4600:	41 50       	subi	r20, 0x01	; 1
    4602:	50 40       	sbci	r21, 0x00	; 0
    4604:	d8 f7       	brcc	.-10     	; 0x45fc <memcpy+0x6>
    4606:	08 95       	ret

00004608 <memset>:
    4608:	dc 01       	movw	r26, r24
    460a:	01 c0       	rjmp	.+2      	; 0x460e <memset+0x6>
    460c:	6d 93       	st	X+, r22
    460e:	41 50       	subi	r20, 0x01	; 1
    4610:	50 40       	sbci	r21, 0x00	; 0
    4612:	e0 f7       	brcc	.-8      	; 0x460c <memset+0x4>
    4614:	08 95       	ret

00004616 <strncpy>:
    4616:	fb 01       	movw	r30, r22
    4618:	dc 01       	movw	r26, r24
    461a:	41 50       	subi	r20, 0x01	; 1
    461c:	50 40       	sbci	r21, 0x00	; 0
    461e:	48 f0       	brcs	.+18     	; 0x4632 <strncpy+0x1c>
    4620:	01 90       	ld	r0, Z+
    4622:	0d 92       	st	X+, r0
    4624:	00 20       	and	r0, r0
    4626:	c9 f7       	brne	.-14     	; 0x461a <strncpy+0x4>
    4628:	01 c0       	rjmp	.+2      	; 0x462c <strncpy+0x16>
    462a:	1d 92       	st	X+, r1
    462c:	41 50       	subi	r20, 0x01	; 1
    462e:	50 40       	sbci	r21, 0x00	; 0
    4630:	e0 f7       	brcc	.-8      	; 0x462a <strncpy+0x14>
    4632:	08 95       	ret

00004634 <_exit>:
    4634:	f8 94       	cli

00004636 <__stop_program>:
    4636:	ff cf       	rjmp	.-2      	; 0x4636 <__stop_program>
